#!/bin/bash -e false syntax highlighting 

[[ -z ${-//[^i]} ]] && return

shopt -s extdebug
shopt -s checkwinsize



if [[ -r /etc/debian_chroot ]]; then
	debian_chroot=${debian_chroot:-$(cat /etc/debian_chroot)}
elif ! shopt -oq posix; then
  if [[ -f /usr/share/bash-completion/bash_completion ]]; then
    . /usr/share/bash-completion/bash_completion
  elif [[ -f /etc/bash_completion ]]; then
    . /etc/bash_completion
  fi
fi

if (groups | grep -q sudo) && [[ ! -r ~/.hushlogin ]]; then
    case " $(groups) " in 
			# i guess standard bashrc only want this information emitted to users in the 'admin' group
			# so i decided to keep it this way as to not invite problems into the script by accidental members
			*" admin "*)
			  if [ -x /usr/bin/sudo ]; then
					echo 'To run a command as administrator (user "root"), use "sudo <command>".'
					echo 'See "man sudo_root" for details.'					
		    fi
				;;				
	    esac
fi


####################### BEGIN bash.bashrc CUSTOMIZATIONS #####################################################################################

# these are experimental, dont use if you dont want problems potentially out of nowhere
# however they should not physically harm your computer but data loss can occur due to 
# this especially in the case of AUTOMATED systems!

if [[ -x /usr/lib/command-not-found ]] || [[ -x /usr/share/command-not-found/command-not-found ]]; then

	#
	# command_not_found_handle [command name] [args]
	# requires the command_not_found python script
	#
	function command_not_found_handle()
	{
		# prevent interaction when not in interactive mode
		case $- in *i*) 
			true #is interactive, go ahead and continue execution
			;;		
		*)
			# not interactive, do not attempt interaction mode
			echo "$BASH_SOURCE: command not found: $* (non interactive)"
			return 127;;
		esac
		# PREVENT interactive install mode when extdebug is disabled
		# because using it recklessly in scripts without this extra
		# information could cause bad things to happen, like big unwanted
		# programs being installed. Note that never would the situation
		# cause anything to be uninstalled or removed, and all installs
		# are logged and marked so they can be undone easily.
		if (! shopt -q extdebug); then
			echo "$BASH_SOURCE: command not found: $*"
			echo "Notice: extdebug is disabled, it is needed for the GXBASE interactive installer to work!"
			return 127
		fi
    #prevent interaction when sourcing from .bashrc
		# this MUST have extdebug on
		if [[ $BASH_ARGV[*] ]]; then
			for ((i=0;i<=$BASH_ARGC;i++)); do
				j=${BASH_ARGV[i]}	  		
				if [[ $j ]] && [[ $(basename "$j") == ".bashrc" ]]; then					
					echo "COMMAND NOT FOUND: $1 (bashrc loop prevention)"
					return 127
				fi
			done
		fi

			
		if [[ $DO_NOT_CNF == YES ]]; then
			echo "Command not found (loop prevention)"
			return 127
		fi
		# check because c-n-f could've been removed in the meantime
  	if [ -x /usr/lib/command-not-found ]; then			
			RESPONSE=$(/usr/lib/command-not-found -- "$1" 2>&1 | tr '\n' ' ' | tr -s ' ')
			echo "$RESPONSE" > /dev/stdout
			if (echo "$RESPONSE" | grep -q "apt-get" &> /dev/null); then				
				echo "Make a choice:"
				echo
				echo "1. Install Now"
				echo "2. Do Not Install"
				echo	
				sleep 1
				read -sn1 REPLY
				sleep 1
				if [[ $REPLY == 1 ]]; then
					INSTALL=YES				
					echo "Installing (removal of packages disabled)"					
				else
					INSTALL=NO
					echo "Cancelled"
				fi			
				if [[ $INSTALL == "YES" ]]; then
					INSTALLCMD=$(echo $RESPONSE | grep -o "apt-get.*")
					PKGNAME=$(echo INSTALLCMD | grep -Po "(?<=apt-get install ).*")
					echo "Checking existence of package: $PKGNAME"
					if (apt-cache madison $PKGNAME -qq &> /dev/null); then
						echo "Package exists, starting download and install..."
						if [[ $UID -gt 0 ]]; then
							INSTALLCMD="sudo $INSTALLCMD"
						fi
						if (eval $INSTALLCMD --no-remove --yes); then
							echo "Updating auto-install records..."
							echo "$(date): $PKGNAME" >> ~/.autoinstalledpackages
							echo "Install Succeeded!"							
							echo "now running the command as originally requested... [press CTRL+BREAK or CTRL+C in 2 seconds to abort it]"
							sleep 2
							# use DO_NOT_CNF to prevent eternal loops in case some quirk manages to give us a bad exit code
							export DO_NOT_CNF=YES
							command "$@"
							ERR=$?
							export DO_NOT_CNF=NO							
							return $ERR
						else
							echo "Error: installer reported failure, you will need to install it manually!"
							return 127
						fi
					else
						echo "Error: package $PKGNAME does not have any actual packages assigned to it"
						echo "       probably because it is either unsupported, depreciated, or virtual!"
					fi
				fi							
			fi
	    return 127
    elif [ -x /usr/share/command-not-found/command-not-found ]; then
		   /usr/share/command-not-found/command-not-found -- "$1"
       return $?
		else
		   printf "%s: command not found\n" "$1" >&2
		   return 127
		fi
	}

fi
