function CRIT() 
{ 
    __echoer "DISABLE_CRITICAL_ERROR_MESSAGES" "$@"
}
function DEBM() 
{ 
    __echoer "ENABLE_DEBUG_MESSAGES" "$@"
}
function DETA() 
{ 
    __echoer "ENABLE_DETAILED_MESSAGES" "$@"
}
function HINT() 
{ 
    __echoer "DISABLE_HINTS" "$@"
}
function INFO() 
{ 
    __echoer "DISABLE_INFO_MESSAGES" "$@"
}
function WARN() 
{ 
    __echoer "IGNORE_WARNINGS" "$@"
}
function __BASH_EXT_HOOK() 
{ 
    unset SIGHOOKS SIGNAL SIGHOOK_NAME;
    local SIGNAL=$1;
    local SIGHOOK_NAME=${SIGNAL}_HOOKS;
    if [[ ! -v $SIGHOOK_NAME ]]; then
        return;
    fi;
    echo "SIGNAL NAME: $SIGNAL_NAME";
    declare -n SIGHOOKS=${SIGNAL_NAME};
    [[ -v BASHRC_FLAG_NOTIFY_ON_SIGNALS ]] && { 
        echo "Signal Catch $FUNCNAME : $1 : ${*: 2}"
    };
    if [[ $(declare -p $SIGHOOK_NAME) =~ .*(-a|--).* ]]; then
        if [[ ${#SIGHOOKS[@]} -ge 1 ]]; then
            for signalhook in "${SIGHOOKS[@]}";
            do
                if [[ $(declare -f $signalhook) == $signalhook ]]; then
                    $signalhook "$@";
                else
                    [[ -v BASHRC_FLAG_NOTIFY_ON_SIGNAL_MAPERRORS ]] && echo "Signal map error: hook $signalhook is not a bash callable function";
                fi;
            done;
        else
            [[ -v BASHRC_FLAG_NOTIFY_ON_SIGNAL_MAPERRORS ]] && echo "Signal map error: hook variable $SIGHOOK_NAME is empty or undefined, it must be a nonexported indexed array or single variable that contains a function name or array of names.";
        fi;
    else
        [[ -v BASHRC_FLAG_NOTIFY_ON_SIGNAL_MAPERRORS ]] && echo "Signal map error: hook variable $SIGHOOK_NAME must be a nonexported indexed array or single variable that contains a function name or array of names.";
    fi
}
declare -ft __BASH_EXT_HOOK
function __BASH_RELOAD_HOOK() 
{ 
    declare -xi BASH_KEY_RESOURCING=1;
    source ~/.bashrc;
    unset BASH_KEY_RESOURCING
}
declare -ft __BASH_RELOAD_HOOK
function __all_modules() 
{ 
    while read name; do
        name=${name%% *};
        printf "%s\n" "$name";
    done < <(pulseaudio --dump-modules 2> /dev/null)
}
function __bash_apply_local_completions() 
{ 
    if __isflag BASH_ENABLE_BUILTIN_LONGOPTS; then
        complete -F _dlgopt dialog;
        complete -F _longopt locate;
        complete -F _longopt ddd;
        complete -F _longopt ctags;
        complete -F _longopt ctags-exuberant;
        complete -F _longopt ./configure;
        complete -F _longopt chmod;
    fi;
    complete -A variable -A arrayvar __xlatv;
    complete -F _initshow show;
    complete -F _initshow defined;
    if __isflag BASH_ENABLE_GENERIC_COMPLETION_LOADER; then
        complete -D _completion_loader;
    fi;
    [[ _completion_loader != $(declare -F _completion_loader) ]] && [[ -r ~/.bash_completion ]] && source ~/.bash_completion;
    complete -F _debconf_show src;
    complete -F _longopt dialog
}
function __bashrc_ext_command_not_found_handler() 
{ 
    if [[ -v IN_CNFH_PROC ]]; then
        return;
    fi;
    declare -g IN_CNFH_PROC=1;
    if [[ -v CNFH_EXT_HOOKS ]]; then
        if [[ $(declare -p CNFH_EXT_HOOKS) =~ ^[a-r]{7}' '[-a]{2} ]]; then
            for hook in "${CNFH_EXT_HOOKS}";
            do
                [[ $(declare -F $hook) == $hook ]] && $hook "$@" || { 
                    [[ -v CNFH_HOOK_WARNINGS_FLAG ]] && echo "Warning: $hook uncallable hooktable entry in CNFH_EXT_HOOKS"
                };
            done;
        else
            [[ -v CNFH_HOOK_WARNINGS_FLAG ]] && echo "Warning: CNFH_EXT_HOOKS must be an indexed array or a single variable with no attributes (not exported, readonly, etc).";
        fi;
    else
        [[ -v CNFH_HOOK_WARNINGS_FLAG ]] && echo "Warning: CNFH_EXT_HOOKS not defined and CNFH_HOOK_WARNINGS_FLAG is defined (undefine it to disable this message).";
    fi;
    case $- in 
        *i*)
            case `tty` in 
                *tty* | *pts*)
                    echo "Command Not found: $*"
                ;;
                *)
                    return
                ;;
            esac
        ;;
        *)
            return $?
        ;;
    esac;
    [[ -r ~/.config/bashrc/flags/ALWAYS_CHECK_SESSION ]] && local ALWAYS_CHECK_SESSION=y;
    [[ -r ~/.config/bashrc/flags/ALWAYS_INSTALL_SESSION ]] && local ALWAYS_INSTALL_SESSION=y;
    [[ -r ~/.config/bashrc/flags/NEVER_CHECK_SESSION ]] && local ALWAYS_CHECK_SESSION=n;
    [[ -r ~/.config/bashrc/flags/NEVER_INSTALL_SESSION ]] && local ALWAYS_INSTALL_SESSION=n;
    local REPLY="";
    if [[ $ALWAYS_CHECK_SESSION == y ]]; then
        REPLY=y;
        echo "$* Not Found, Checking for possible match... (user forced 'always check')";
    else
        if [[ $ALWAYS_CHECK_SESSION == n ]]; then
            return 127;
        else
            echo -ne "Want to check [enter or N=skip, Y=check, A=always/session] ? ";
            read -sn1;
            if [[ $REPLY =~ [Aa] ]]; then
                REPLY=y;
                touch ~/.config/bashrc/flags/ALWAYS_CHECK_SESSION;
            fi;
        fi;
    fi;
    if [[ $REPLY =~ [Yy] ]]; then
        if [[ -x "/usr/lib/command-not-found" ]]; then
            echo "Searching database for this program...";
            RESULT=`/usr/lib/command-not-found "$@" 2>&1`;
            echo "$RESULT";
            if INSTALL_RESULT=`echo "$RESULT" | grep "(apt-get|sudo apt-get).*"`; then
                if [[ $ALWAYS_INSTALL_SESSION == y ]]; then
                    REPLY=y;
                    echo "Single Install Found, Starting Installer... (user forced 'always install')";
                else
                    if [[ $ALWAYS_INSTALL_SESSION == n ]]; then
                        return 127;
                    else
                        echo -ne "Want to Install? [enter or N=no, Y=install, A=always/session] ";
                        read -sn1;
                        if [[ $REPLY =~ [aA] ]]; then
                            REPLY=y;
                            touch ~/.config/bashrc/flags/ALWAYS_INSTALL_SESSION;
                        fi;
                    fi;
                fi;
                if [[ $REPLY =~ [yY] ]]; then
                    echo "Attempting install...";
                    if INSTALL_COMMAND=(`echo $RESULT | grep '(sudo )?apt-get.*'`); then
                        "${INSTALL_COMMAND[@]}";
                    else
                        echo "Error: install not possible! Please contact your system administrator!";
                        ( exit 1 );
                    fi;
                    local INSTALL_RESULT=$?;
                    if [[ $INSTALL_RESULT -eq 0 ]]; then
                        echo "Succeeded, re-invoking original command line...";
                        "$@";
                    else
                        echo "install completed with code $INSTALL_RESULT";
                    fi;
                fi;
            else
                echo "No install suggested, no further checks made.";
            fi;
        else
            echo "Can't check, command-not-found is not installed in usr/lib!";
        fi;
    else
        echo "Skipped";
    fi;
    unset IN_CNFH_PROC
}
function __builtin_helper() 
{ 
    local -n _BHSTACK=BASH_${1}_STACK;
    local _BHNAME=$2;
    shift 2;
    if [[ -v _BHSTACK ]]; then
        :;
    fi;
    if builtin $_BHNAME "$@"; then
        _BHSTACK+=("$*");
    fi
}
function __cards() 
{ 
    while IFS='	' read idx name _; do
        printf "%s %s\n" "$idx" "$name";
    done < <(pactl list cards short 2> /dev/null)
}
function __clear_traps() 
{ 
    for trapname in `compgen -A signal`;
    do
        [[ $trapname =~ (SIGTTOU|SIGTTIN|SIGTSTP) ]] || trap $trapname;
    done
}
declare -ft __clear_traps
function __echoer() 
{ 
    local __RET=$?;
    local __FLG=$1;
    shift;
    [[ -v __ECHOER_COLORCACHE ]] || declare -gAx __ECHOER_COLORCACHE;
    __isflag $__FLG && { 
        if [[ -v __ECHOER_COLORCACHE[$__FLG] ]]; then
            echo -n "${__ECHOER_COLORCACHE[$__FLG]}";
        else
            local __FLG_COLOR_V=`perl -e '$_='$__FLG'; s/_?(DISABLE|IGNORE|ENABLE|INCLUDE|ENFORCE)D?_?//g; print "$_" . "_COLOR"'`;
            [[ -v $__FLG_COLOR_V ]] && local __FLG_COLOR="${!__FLG_COLOR_V}";
            [[ -z "$__FLG_COLOR" ]] || { 
                echo -n "${__FLG_COLOR}"
            };
            __ECHOER_COLORCACHE[$__FLG]="$__FLG_COLOR";
        fi;
        if [[ $1 == "--cat" ]]; then
            shift;
            echo -ne "$@";
        else
            [[ -v "IFS" ]] && OLDIFS=$IFS || OLDIFS=NONE;
            IFS='
';
            for j in "$@";
            do
                echo $j;
            done;
            echo -ne "[0m";
            [[ $OLDIFS == NONE ]] && unset IFS || IFS=$OLDIFS;
        fi
    };
    return $__RET
}
function __expand_tilde_by_ref() 
{ 
    if [[ ${!1} == \~* ]]; then
        if [[ ${!1} == */* ]]; then
            eval $1="${!1/%\/*}"/'${!1#*/}';
        else
            eval $1="${!1}";
        fi;
    fi
}
function __generic_completion_loader() 
{ 
    local compfile=./completions;
    [[ $BASH_SOURCE == */* ]] && compfile="${BASH_SOURCE%/*}/completions";
    compfile+="/${1##*/}";
    [[ -f "$compfile" ]] && . "$compfile" &> /dev/null && return 124;
    if __isflag NO_LONGOPT_BY_DEFAULT_COMPLETION || MYVAL=`whereis bash -m | grep '(?<= |^)[^ ]*.[168](\.gz)?(?= |$)' --max-count=1 -o`; then
        if zcat -f "$MYVAL" | grep --color=auto -P -- '--[-a-z]+' -Pq; then
            complete -F __longopt "$1" && return 124;
        fi;
    else
        complete -F _minimal "$1" && return 124;
    fi
}
function __get_bindings() 
{ 
    bind -p | grep --color=auto -P '^(.*(\(not bound\)|self-insert|do-lowercase-version).*)$' -v | uniq --skip-fields=1 -u
}
function __get_cword_at_cursor_by_ref() 
{ 
    local cword words=();
    __reassemble_comp_words_by_ref "$1" words cword;
    local i cur index=$COMP_POINT lead=${COMP_LINE:0:$COMP_POINT};
    if [[ $index -gt 0 && ( -n $lead && -n ${lead//[[:space:]]} ) ]]; then
        cur=$COMP_LINE;
        for ((i = 0; i <= cword; ++i ))
        do
            while [[ ${#cur} -ge ${#words[i]} && "${cur:0:${#words[i]}}" != "${words[i]}" ]]; do
                cur="${cur:1}";
                ((index--));
            done;
            if [[ $i -lt $cword ]]; then
                local old_size=${#cur};
                cur="${cur#"${words[i]}"}";
                local new_size=${#cur};
                index=$(( index - old_size + new_size ));
            fi;
        done;
        [[ -n $cur && ! -n ${cur//[[:space:]]} ]] && cur=;
        [[ $index -lt 0 ]] && index=0;
    fi;
    local "$2" "$3" "$4" && _upvars -a${#words[@]} $2 "${words[@]}" -v $3 "$cword" -v $4 "${cur:0:$index}"
}
function __git_aliased_command() 
{ 
    local word cmdline=$(git --git-dir="$(__gitdir)" 			config --get "alias.$1");
    for word in $cmdline;
    do
        case "$word" in 
            \!gitk | gitk)
                echo "gitk";
                return
            ;;
            \!*)
                : shell command alias
            ;;
            -*)
                : option
            ;;
            *=*)
                : setting env
            ;;
            git)
                : git itself
            ;;
            *)
                echo "$word";
                return
            ;;
        esac;
    done
}
function __git_aliases() 
{ 
    local i IFS='
';
    for i in $(git --git-dir="$(__gitdir)" config --get-regexp "alias\..*" 2>/dev/null);
    do
        case "$i" in 
            alias.*)
                i="${i#alias.}";
                echo "${i/ */}"
            ;;
        esac;
    done
}
function __git_complete_file() 
{ 
    local pfx ls ref cur="${COMP_WORDS[COMP_CWORD]}";
    case "$cur" in 
        ?*:*)
            ref="${cur%%:*}";
            cur="${cur#*:}";
            case "$cur" in 
                ?*/*)
                    pfx="${cur%/*}";
                    cur="${cur##*/}";
                    ls="$ref:$pfx";
                    pfx="$pfx/"
                ;;
                *)
                    ls="$ref"
                ;;
            esac;
            case "$COMP_WORDBREAKS" in 
                *:*)
                    : great
                ;;
                *)
                    pfx="$ref:$pfx"
                ;;
            esac;
            local IFS='
';
            COMPREPLY=($(compgen -P "$pfx" 				-W "$(git --git-dir="$(__gitdir)" ls-tree "$ls" 					| sed '/^100... blob /{
										 s,^.*	,,
										 s,$, ,
								 }
								 /^120000 blob /{
										 s,^.*	,,
										 s,$, ,
								 }
								 /^040000 tree /{
										 s,^.*	,,
										 s,$,/,
								 }
								 s/^.*	//')" 				-- "$cur"))
        ;;
        *)
            __gitcomp "$(__git_refs)"
        ;;
    esac
}
function __git_complete_remote_or_refspec() 
{ 
    local cmd="${COMP_WORDS[0]}";
    local cur="${COMP_WORDS[COMP_CWORD]}";
    local i c=1 remote="" pfx="" lhs=1 no_complete_refspec=0;
    if [ "$cmd" = "git" ]; then
        cmd="${COMP_WORDS[1]}";
        c=2;
    fi;
    while [ $c -lt $COMP_CWORD ]; do
        i="${COMP_WORDS[c]}";
        case "$i" in 
            --mirror)
                [ "$cmd" = "push" ] && no_complete_refspec=1
            ;;
            --all)
                case "$cmd" in 
                    push)
                        no_complete_refspec=1
                    ;;
                    fetch)
                        COMPREPLY=();
                        return
                    ;;
                    *)

                    ;;
                esac
            ;;
            -*)

            ;;
            *)
                remote="$i";
                break
            ;;
        esac;
        c=$((++c));
    done;
    if [ -z "$remote" ]; then
        __gitcomp "$(__git_remotes)";
        return;
    fi;
    if [ $no_complete_refspec = 1 ]; then
        COMPREPLY=();
        return;
    fi;
    [ "$remote" = "." ] && remote=;
    case "$cur" in 
        *:*)
            case "$COMP_WORDBREAKS" in 
                *:*)
                    : great
                ;;
                *)
                    pfx="${cur%%:*}:"
                ;;
            esac;
            cur="${cur#*:}";
            lhs=0
        ;;
        +*)
            pfx="+";
            cur="${cur#+}"
        ;;
    esac;
    case "$cmd" in 
        fetch)
            if [ $lhs = 1 ]; then
                __gitcomp "$(__git_refs2 "$remote")" "$pfx" "$cur";
            else
                __gitcomp "$(__git_refs)" "$pfx" "$cur";
            fi
        ;;
        pull)
            if [ $lhs = 1 ]; then
                __gitcomp "$(__git_refs "$remote")" "$pfx" "$cur";
            else
                __gitcomp "$(__git_refs)" "$pfx" "$cur";
            fi
        ;;
        push)
            if [ $lhs = 1 ]; then
                __gitcomp "$(__git_refs)" "$pfx" "$cur";
            else
                __gitcomp "$(__git_refs "$remote")" "$pfx" "$cur";
            fi
        ;;
    esac
}
function __git_complete_revlist() 
{ 
    local pfx cur="${COMP_WORDS[COMP_CWORD]}";
    case "$cur" in 
        *...*)
            pfx="${cur%...*}...";
            cur="${cur#*...}";
            __gitcomp "$(__git_refs)" "$pfx" "$cur"
        ;;
        *..*)
            pfx="${cur%..*}..";
            cur="${cur#*..}";
            __gitcomp "$(__git_refs)" "$pfx" "$cur"
        ;;
        *)
            __gitcomp "$(__git_refs)"
        ;;
    esac
}
function __git_complete_strategy() 
{ 
    __git_compute_merge_strategies;
    case "${COMP_WORDS[COMP_CWORD-1]}" in 
        -s | --strategy)
            __gitcomp "$__git_merge_strategies";
            return 0
        ;;
    esac;
    local cur="${COMP_WORDS[COMP_CWORD]}";
    case "$cur" in 
        --strategy=*)
            __gitcomp "$__git_merge_strategies" "" "${cur##--strategy=}";
            return 0
        ;;
    esac;
    return 1
}
function __git_compute_all_commands() 
{ 
    : ${__git_all_commands:=$(__git_list_all_commands)}
}
function __git_compute_merge_strategies() 
{ 
    : ${__git_merge_strategies:=$(__git_list_merge_strategies)}
}
function __git_compute_porcelain_commands() 
{ 
    __git_compute_all_commands;
    : ${__git_porcelain_commands:=$(__git_list_porcelain_commands)}
}
function __git_config_get_set_variables() 
{ 
    local prevword word config_file= c=$COMP_CWORD;
    while [ $c -gt 1 ]; do
        word="${COMP_WORDS[c]}";
        case "$word" in 
            --global | --system | --file=*)
                config_file="$word";
                break
            ;;
            -f | --file)
                config_file="$word $prevword";
                break
            ;;
        esac;
        prevword=$word;
        c=$((--c));
    done;
    git --git-dir="$(__gitdir)" config $config_file --list 2> /dev/null | while read line; do
        case "$line" in 
            *.*=*)
                echo "${line/=*/}"
            ;;
        esac;
    done
}
function __git_find_on_cmdline() 
{ 
    local word subcommand c=1;
    while [ $c -lt $COMP_CWORD ]; do
        word="${COMP_WORDS[c]}";
        for subcommand in $1;
        do
            if [ "$subcommand" = "$word" ]; then
                echo "$subcommand";
                return;
            fi;
        done;
        c=$((++c));
    done
}
function __git_has_doubledash() 
{ 
    local c=1;
    while [ $c -lt $COMP_CWORD ]; do
        if [ "--" = "${COMP_WORDS[c]}" ]; then
            return 0;
        fi;
        c=$((++c));
    done;
    return 1
}
function __git_heads() 
{ 
    local cmd i is_hash=y dir="$(__gitdir "${1-}")";
    if [ -d "$dir" ]; then
        git --git-dir="$dir" for-each-ref --format='%(refname:short)' refs/heads;
        return;
    fi;
    for i in $(git ls-remote "${1-}" 2>/dev/null);
    do
        case "$is_hash,$i" in 
            y,*)
                is_hash=n
            ;;
            n,*^{})
                is_hash=y
            ;;
            n,refs/heads/*)
                is_hash=y;
                echo "${i#refs/heads/}"
            ;;
            n,*)
                is_hash=y;
                echo "$i"
            ;;
        esac;
    done
}
function __git_list_all_commands() 
{ 
    local i IFS=" "'
';
    for i in $(git help -a|egrep '^  [a-zA-Z0-9]');
    do
        case $i in 
            *--*)
                : helper pattern
            ;;
            *)
                echo $i
            ;;
        esac;
    done
}
function __git_list_merge_strategies() 
{ 
    git merge -s help 2>&1 | sed -n -e '/[Aa]vailable strategies are: /,/^$/{
			s/\.$//
			s/.*://
			s/^[ 	]*//
			s/[ 	]*$//
			p
		}'
}
function __git_list_porcelain_commands() 
{ 
    local i IFS=" "'
';
    __git_compute_all_commands;
    for i in "help" $__git_all_commands;
    do
        case $i in 
            *--*)
                : helper pattern
            ;;
            applymbox)
                : ask gittus
            ;;
            applypatch)
                : ask gittus
            ;;
            archimport)
                : import
            ;;
            cat-file)
                : plumbing
            ;;
            check-attr)
                : plumbing
            ;;
            check-ref-format)
                : plumbing
            ;;
            checkout-index)
                : plumbing
            ;;
            commit-tree)
                : plumbing
            ;;
            count-objects)
                : infrequent
            ;;
            cvsexportcommit)
                : export
            ;;
            cvsimport)
                : import
            ;;
            cvsserver)
                : daemon
            ;;
            daemon)
                : daemon
            ;;
            diff-files)
                : plumbing
            ;;
            diff-index)
                : plumbing
            ;;
            diff-tree)
                : plumbing
            ;;
            fast-import)
                : import
            ;;
            fast-export)
                : export
            ;;
            fsck-objects)
                : plumbing
            ;;
            fetch-pack)
                : plumbing
            ;;
            fmt-merge-msg)
                : plumbing
            ;;
            for-each-ref)
                : plumbing
            ;;
            hash-object)
                : plumbing
            ;;
            http-*)
                : transport
            ;;
            index-pack)
                : plumbing
            ;;
            init-db)
                : deprecated
            ;;
            local-fetch)
                : plumbing
            ;;
            lost-found)
                : infrequent
            ;;
            ls-files)
                : plumbing
            ;;
            ls-remote)
                : plumbing
            ;;
            ls-tree)
                : plumbing
            ;;
            mailinfo)
                : plumbing
            ;;
            mailsplit)
                : plumbing
            ;;
            merge-*)
                : plumbing
            ;;
            mktree)
                : plumbing
            ;;
            mktag)
                : plumbing
            ;;
            pack-objects)
                : plumbing
            ;;
            pack-redundant)
                : plumbing
            ;;
            pack-refs)
                : plumbing
            ;;
            parse-remote)
                : plumbing
            ;;
            patch-id)
                : plumbing
            ;;
            peek-remote)
                : plumbing
            ;;
            prune)
                : plumbing
            ;;
            prune-packed)
                : plumbing
            ;;
            quiltimport)
                : import
            ;;
            read-tree)
                : plumbing
            ;;
            receive-pack)
                : plumbing
            ;;
            reflog)
                : plumbing
            ;;
            remote-*)
                : transport
            ;;
            repo-config)
                : deprecated
            ;;
            rerere)
                : plumbing
            ;;
            rev-list)
                : plumbing
            ;;
            rev-parse)
                : plumbing
            ;;
            runstatus)
                : plumbing
            ;;
            sh-setup)
                : internal
            ;;
            shell)
                : daemon
            ;;
            show-ref)
                : plumbing
            ;;
            send-pack)
                : plumbing
            ;;
            show-index)
                : plumbing
            ;;
            ssh-*)
                : transport
            ;;
            stripspace)
                : plumbing
            ;;
            symbolic-ref)
                : plumbing
            ;;
            tar-tree)
                : deprecated
            ;;
            unpack-file)
                : plumbing
            ;;
            unpack-objects)
                : plumbing
            ;;
            update-index)
                : plumbing
            ;;
            update-ref)
                : plumbing
            ;;
            update-server-info)
                : daemon
            ;;
            upload-archive)
                : plumbing
            ;;
            upload-pack)
                : plumbing
            ;;
            write-tree)
                : plumbing
            ;;
            var)
                : infrequent
            ;;
            verify-pack)
                : infrequent
            ;;
            verify-tag)
                : plumbing
            ;;
            *)
                echo $i
            ;;
        esac;
    done
}
function __git_ps1() 
{ 
    local pcmode=no;
    local detached=no;
    local ps1pc_start='\u@\h:\w ';
    local ps1pc_end='\$ ';
    local printf_format=' (%s)';
    case "$#" in 
        2 | 3)
            pcmode=yes;
            ps1pc_start="$1";
            ps1pc_end="$2";
            printf_format="${3:-$printf_format}"
        ;;
        0 | 1)
            printf_format="${1:-$printf_format}"
        ;;
        *)
            return
        ;;
    esac;
    local repo_info rev_parse_exit_code;
    repo_info="$(git rev-parse --git-dir --is-inside-git-dir 		--is-bare-repository --is-inside-work-tree 		--short HEAD 2>/dev/null)";
    rev_parse_exit_code="$?";
    if [ -z "$repo_info" ]; then
        if [ $pcmode = yes ]; then
            PS1="$ps1pc_start$ps1pc_end";
        fi;
        return;
    fi;
    local short_sha;
    if [ "$rev_parse_exit_code" = "0" ]; then
        short_sha="${repo_info##*
}";
        repo_info="${repo_info%
*}";
    fi;
    local inside_worktree="${repo_info##*
}";
    repo_info="${repo_info%
*}";
    local bare_repo="${repo_info##*
}";
    repo_info="${repo_info%
*}";
    local inside_gitdir="${repo_info##*
}";
    local g="${repo_info%
*}";
    local r="";
    local b="";
    local step="";
    local total="";
    if [ -d "$g/rebase-merge" ]; then
        read b 2> /dev/null < "$g/rebase-merge/head-name";
        read step 2> /dev/null < "$g/rebase-merge/msgnum";
        read total 2> /dev/null < "$g/rebase-merge/end";
        if [ -f "$g/rebase-merge/interactive" ]; then
            r="|REBASE-i";
        else
            r="|REBASE-m";
        fi;
    else
        if [ -d "$g/rebase-apply" ]; then
            read step 2> /dev/null < "$g/rebase-apply/next";
            read total 2> /dev/null < "$g/rebase-apply/last";
            if [ -f "$g/rebase-apply/rebasing" ]; then
                read b 2> /dev/null < "$g/rebase-apply/head-name";
                r="|REBASE";
            else
                if [ -f "$g/rebase-apply/applying" ]; then
                    r="|AM";
                else
                    r="|AM/REBASE";
                fi;
            fi;
        else
            if [ -f "$g/MERGE_HEAD" ]; then
                r="|MERGING";
            else
                if [ -f "$g/CHERRY_PICK_HEAD" ]; then
                    r="|CHERRY-PICKING";
                else
                    if [ -f "$g/REVERT_HEAD" ]; then
                        r="|REVERTING";
                    else
                        if [ -f "$g/BISECT_LOG" ]; then
                            r="|BISECTING";
                        fi;
                    fi;
                fi;
            fi;
        fi;
        if [ -n "$b" ]; then
            :;
        else
            if [ -h "$g/HEAD" ]; then
                b="$(git symbolic-ref HEAD 2>/dev/null)";
            else
                local head="";
                if ! read head 2> /dev/null < "$g/HEAD"; then
                    if [ $pcmode = yes ]; then
                        PS1="$ps1pc_start$ps1pc_end";
                    fi;
                    return;
                fi;
                b="${head#ref: }";
                if [ "$head" = "$b" ]; then
                    detached=yes;
                    b="$(
				case "${GIT_PS1_DESCRIBE_STYLE-}" in
				(contains)
					git describe --contains HEAD ;;
				(branch)
					git describe --contains --all HEAD ;;
				(describe)
					git describe HEAD ;;
				(* | default)
					git describe --tags --exact-match HEAD ;;
				esac 2>/dev/null)" || b="$short_sha...";
                    b="($b)";
                fi;
            fi;
        fi;
    fi;
    if [ -n "$step" ] && [ -n "$total" ]; then
        r="$r $step/$total";
    fi;
    local w="";
    local i="";
    local s="";
    local u="";
    local c="";
    local p="";
    if [ "true" = "$inside_gitdir" ]; then
        if [ "true" = "$bare_repo" ]; then
            c="BARE:";
        else
            b="GIT_DIR!";
        fi;
    else
        if [ "true" = "$inside_worktree" ]; then
            if [ -n "${GIT_PS1_SHOWDIRTYSTATE-}" ] && [ "$(git config --bool bash.showDirtyState)" != "false" ]; then
                git diff --no-ext-diff --quiet --exit-code || w="*";
                if [ -n "$short_sha" ]; then
                    git diff-index --cached --quiet HEAD -- || i="+";
                else
                    i="#";
                fi;
            fi;
            if [ -n "${GIT_PS1_SHOWSTASHSTATE-}" ] && [ -r "$g/refs/stash" ]; then
                s="$";
            fi;
            if [ -n "${GIT_PS1_SHOWUNTRACKEDFILES-}" ] && [ "$(git config --bool bash.showUntrackedFiles)" != "false" ] && git ls-files --others --exclude-standard --error-unmatch -- '*' > /dev/null 2> /dev/null; then
                u="%${ZSH_VERSION+%}";
            fi;
            if [ -n "${GIT_PS1_SHOWUPSTREAM-}" ]; then
                __git_ps1_show_upstream;
            fi;
        fi;
    fi;
    local z="${GIT_PS1_STATESEPARATOR-" "}";
    if [ $pcmode = yes ] && [ -n "${GIT_PS1_SHOWCOLORHINTS-}" ]; then
        __git_ps1_colorize_gitstring;
    fi;
    local f="$w$i$s$u";
    local gitstring="$c${b##refs/heads/}${f:+$z$f}$r$p";
    if [ $pcmode = yes ]; then
        if [ "${__git_printf_supports_v-}" != yes ]; then
            gitstring=$(printf -- "$printf_format" "$gitstring");
        else
            printf -v gitstring -- "$printf_format" "$gitstring";
        fi;
        PS1="$ps1pc_start$gitstring$ps1pc_end";
    else
        printf -- "$printf_format" "$gitstring";
    fi
}
function __git_ps1_colorize_gitstring() 
{ 
    if [[ -n ${ZSH_VERSION-} ]]; then
        local c_red='%F{red}';
        local c_green='%F{green}';
        local c_lblue='%F{blue}';
        local c_clear='%f';
    else
        local c_red='\[\e[31m\]';
        local c_green='\[\e[32m\]';
        local c_lblue='\[\e[1;34m\]';
        local c_clear='\[\e[0m\]';
    fi;
    local bad_color=$c_red;
    local ok_color=$c_green;
    local flags_color="$c_lblue";
    local branch_color="";
    if [ $detached = no ]; then
        branch_color="$ok_color";
    else
        branch_color="$bad_color";
    fi;
    c="$branch_color$c";
    z="$c_clear$z";
    if [ "$w" = "*" ]; then
        w="$bad_color$w";
    fi;
    if [ -n "$i" ]; then
        i="$ok_color$i";
    fi;
    if [ -n "$s" ]; then
        s="$flags_color$s";
    fi;
    if [ -n "$u" ]; then
        u="$bad_color$u";
    fi;
    r="$c_clear$r"
}
function __git_ps1_show_upstream() 
{ 
    local key value;
    local svn_remote svn_url_pattern count n;
    local upstream=git legacy="" verbose="" name="";
    svn_remote=();
    local output="$(git config -z --get-regexp '^(svn-remote\..*\.url|bash\.showupstream)$' 2>/dev/null | tr '\0\n' '\n ')";
    while read -r key value; do
        case "$key" in 
            bash.showupstream)
                GIT_PS1_SHOWUPSTREAM="$value";
                if [[ -z "${GIT_PS1_SHOWUPSTREAM}" ]]; then
                    p="";
                    return;
                fi
            ;;
            svn-remote.*.url)
                svn_remote[$((${#svn_remote[@]} + 1))]="$value";
                svn_url_pattern="$svn_url_pattern\\|$value";
                upstream=svn+git
            ;;
        esac;
    done <<< "$output";
    for option in ${GIT_PS1_SHOWUPSTREAM};
    do
        case "$option" in 
            git | svn)
                upstream="$option"
            ;;
            verbose)
                verbose=1
            ;;
            legacy)
                legacy=1
            ;;
            name)
                name=1
            ;;
        esac;
    done;
    case "$upstream" in 
        git)
            upstream="@{upstream}"
        ;;
        svn*)
            local -a svn_upstream;
            svn_upstream=($(git log --first-parent -1 					--grep="^git-svn-id: \(${svn_url_pattern#??}\)" 2>/dev/null));
            if [[ 0 -ne ${#svn_upstream[@]} ]]; then
                svn_upstream=${svn_upstream[${#svn_upstream[@]} - 2]};
                svn_upstream=${svn_upstream%@*};
                local n_stop="${#svn_remote[@]}";
                for ((n=1; n <= n_stop; n++))
                do
                    svn_upstream=${svn_upstream#${svn_remote[$n]}};
                done;
                if [[ -z "$svn_upstream" ]]; then
                    upstream=${GIT_SVN_ID:-git-svn};
                else
                    upstream=${svn_upstream#/};
                fi;
            else
                if [[ "svn+git" = "$upstream" ]]; then
                    upstream="@{upstream}";
                fi;
            fi
        ;;
    esac;
    if [[ -z "$legacy" ]]; then
        count="$(git rev-list --count --left-right 				"$upstream"...HEAD 2>/dev/null)";
    else
        local commits;
        if commits="$(git rev-list --left-right "$upstream"...HEAD 2>/dev/null)"; then
            local commit behind=0 ahead=0;
            for commit in $commits;
            do
                case "$commit" in 
                    "<"*)
                        ((behind++))
                    ;;
                    *)
                        ((ahead++))
                    ;;
                esac;
            done;
            count="$behind	$ahead";
        else
            count="";
        fi;
    fi;
    if [[ -z "$verbose" ]]; then
        case "$count" in 
            "")
                p=""
            ;;
            "0	0")
                p="="
            ;;
            "0	"*)
                p=">"
            ;;
            *"	0")
                p="<"
            ;;
            *)
                p="<>"
            ;;
        esac;
    else
        case "$count" in 
            "")
                p=""
            ;;
            "0	0")
                p=" u="
            ;;
            "0	"*)
                p=" u+${count#0	}"
            ;;
            *"	0")
                p=" u-${count%	0}"
            ;;
            *)
                p=" u+${count#*	}-${count%	*}"
            ;;
        esac;
        if [[ -n "$count" && -n "$name" ]]; then
            p="$p $(git rev-parse --abbrev-ref "$upstream" 2>/dev/null)";
        fi;
    fi
}
function __git_refs() 
{ 
    local i is_hash=y dir="$(__gitdir "${1-}")";
    local cur="${COMP_WORDS[COMP_CWORD]}" format refs;
    if [ -d "$dir" ]; then
        case "$cur" in 
            refs | refs/*)
                format="refname";
                refs="${cur%/*}"
            ;;
            *)
                for i in HEAD FETCH_HEAD ORIG_HEAD MERGE_HEAD;
                do
                    if [ -e "$dir/$i" ]; then
                        echo $i;
                    fi;
                done;
                format="refname:short";
                refs="refs/tags refs/heads refs/remotes"
            ;;
        esac;
        git --git-dir="$dir" for-each-ref --format="%($format)" $refs;
        return;
    fi;
    for i in $(git ls-remote "$dir" 2>/dev/null);
    do
        case "$is_hash,$i" in 
            y,*)
                is_hash=n
            ;;
            n,*^{})
                is_hash=y
            ;;
            n,refs/tags/*)
                is_hash=y;
                echo "${i#refs/tags/}"
            ;;
            n,refs/heads/*)
                is_hash=y;
                echo "${i#refs/heads/}"
            ;;
            n,refs/remotes/*)
                is_hash=y;
                echo "${i#refs/remotes/}"
            ;;
            n,*)
                is_hash=y;
                echo "$i"
            ;;
        esac;
    done
}
function __git_refs2() 
{ 
    local i;
    for i in $(__git_refs "$1");
    do
        echo "$i:$i";
    done
}
function __git_refs_remotes() 
{ 
    local cmd i is_hash=y;
    for i in $(git ls-remote "$1" 2>/dev/null);
    do
        case "$is_hash,$i" in 
            n,refs/heads/*)
                is_hash=y;
                echo "$i:refs/remotes/$1/${i#refs/heads/}"
            ;;
            y,*)
                is_hash=n
            ;;
            n,*^{})
                is_hash=y
            ;;
            n,refs/tags/*)
                is_hash=y
            ;;
            n,*)
                is_hash=y
            ;;
        esac;
    done
}
function __git_remotes() 
{ 
    local i ngoff IFS='
' d="$(__gitdir)";
    shopt -q nullglob || ngoff=1;
    shopt -s nullglob;
    for i in "$d/remotes"/*;
    do
        echo ${i#$d/remotes/};
    done;
    [ "$ngoff" ] && shopt -u nullglob;
    for i in $(git --git-dir="$d" config --get-regexp 'remote\..*\.url' 2>/dev/null);
    do
        i="${i#remote.}";
        echo "${i/.url*/}";
    done
}
function __git_tags() 
{ 
    local cmd i is_hash=y dir="$(__gitdir "${1-}")";
    if [ -d "$dir" ]; then
        git --git-dir="$dir" for-each-ref --format='%(refname:short)' refs/tags;
        return;
    fi;
    for i in $(git ls-remote "${1-}" 2>/dev/null);
    do
        case "$is_hash,$i" in 
            y,*)
                is_hash=n
            ;;
            n,*^{})
                is_hash=y
            ;;
            n,refs/tags/*)
                is_hash=y;
                echo "${i#refs/tags/}"
            ;;
            n,*)
                is_hash=y;
                echo "$i"
            ;;
        esac;
    done
}
function __gitcomp() 
{ 
    local cur="${COMP_WORDS[COMP_CWORD]}";
    if [ $# -gt 2 ]; then
        cur="$3";
    fi;
    case "$cur" in 
        --*=)
            COMPREPLY=()
        ;;
        *)
            local IFS='
';
            COMPREPLY=($(compgen -P "${2-}" 				-W "$(__gitcomp_1 "${1-}" "${4-}")" 				-- "$cur"))
        ;;
    esac
}
function __gitcomp_1() 
{ 
    local c IFS=' ''	''
';
    for c in $1;
    do
        case "$c$2" in 
            --*=*)
                printf %s'
' "$c$2"
            ;;
            *.)
                printf %s'
' "$c$2"
            ;;
            *)
                printf %s'
' "$c$2 "
            ;;
        esac;
    done
}
function __gitdir() 
{ 
    if [ -z "${1-}" ]; then
        if [ -n "${__git_dir-}" ]; then
            echo "$__git_dir";
        else
            if [ -d .git ]; then
                echo .git;
            else
                git rev-parse --git-dir 2> /dev/null;
            fi;
        fi;
    else
        if [ -d "$1/.git" ]; then
            echo "$1/.git";
        else
            echo "$1";
        fi;
    fi
}
function __grub_dir() 
{ 
    local i c=1 boot_dir;
    for ((c=1; c <= ${#COMP_WORDS[@]}; c++ ))
    do
        i="${COMP_WORDS[c]}";
        case "$i" in 
            --boot-directory)
                c=$((++c));
                i="${COMP_WORDS[c]}";
                boot_dir="${i##*=}";
                break
            ;;
        esac;
    done;
    boot_dir=${boot_dir-/boot};
    echo "${boot_dir%/}/grub"
}
function __grub_get_last_option() 
{ 
    local i;
    for ((i=$COMP_CWORD-1; i > 0; i-- ))
    do
        if [[ "${COMP_WORDS[i]}" == -* ]]; then
            echo "${COMP_WORDS[i]}";
            break;
        fi;
    done
}
function __grub_get_options_from_help() 
{ 
    local prog;
    if [ $# -ge 1 ]; then
        prog="$1";
    else
        prog="${COMP_WORDS[0]}";
    fi;
    local i IFS=" "'	''
';
    for i in $(LC_ALL=C $prog --help);
    do
        case $i in 
            --*)
                echo "${i%=*}"
            ;;
        esac;
    done
}
function __grub_get_options_from_usage() 
{ 
    local prog;
    if [ $# -ge 1 ]; then
        prog="$1";
    else
        prog="${COMP_WORDS[0]}";
    fi;
    local i IFS=" "'	''
';
    for i in $(LC_ALL=C $prog --usage);
    do
        case $i in 
            \[--*\])
                i=${i#[};
                echo ${i%%?(=*)]}
            ;;
        esac;
    done
}
function __grub_list_menuentries() 
{ 
    local cur="${COMP_WORDS[COMP_CWORD]}";
    local config_file=$(__grub_dir)/grub.cfg;
    if [ -f "$config_file" ]; then
        local IFS='
';
        COMPREPLY=($(compgen             -W "$( awk -F "[\"']" '/menuentry/ { print $2 }' $config_file )"             -- "$cur" ));
    fi
}
function __grub_list_modules() 
{ 
    local grub_dir=$(__grub_dir);
    local IFS='
';
    COMPREPLY=($( compgen -f -X '!*/*.mod' -- "${grub_dir}/$cur" | {
         while read -r tmp; do
             [ -n $tmp ] && {
                 tmp=${tmp##*/}
                 printf '%s\n' ${tmp%.mod}
             }
         done
         }
        ))
}
function __grubcomp() 
{ 
    local cur="${COMP_WORDS[COMP_CWORD]}";
    if [ $# -gt 2 ]; then
        cur="$3";
    fi;
    case "$cur" in 
        --*=)
            COMPREPLY=()
        ;;
        *)
            local IFS=' ''	''
';
            COMPREPLY=($(compgen -P "${2-}" -W "${1-}" -S "${4-}" -- "$cur"))
        ;;
    esac
}
function __hrule() 
{ 
    [[ -n $COLUMNS ]] || [[ -x `which resize` ]] && eval `resize`;
    local RETAINED_EXITCODE=$?;
    local PREFIX="$3";
    local SUFFIX="$4";
    local CHAR="$1";
    local COUNT="$2";
    [[ -n $CHAR ]] || CHAR="-";
    [[ -n $PREFIX ]] || PREFIX=$CHAR;
    [[ -n $SUFFIX ]] || SUFFIX=$CHAR;
    [[ -n $COLUMNS ]] || COLUMNS=50;
    [[ -n $COUNT && $COUNT -ge $(( ${#CHAR}+${#PREFIX}+${#SUFFIX} )) ]] || COUNT=$((  ( $COLUMNS - ${#PREFIX} - ${#SUFFIX} ) / ${#CHAR} ));
    printf "%s" "$PREFIX";
    eval printf -- "$CHAR%0.0s" {1..$COUNT};
    printf "%s\n" "$SUFFIX";
    return $RETAINED_EXITCODE
}
function __initbashcompletion() 
{ 
    shopt -s nullglob;
    slice_func __isflag;
    slice_func __validflagname
}
function __isflag() 
{ 
    uses __validflagname;
    __validflagname "$1" || return 2;
    [[ -v BASH_FLAG_REGISTRY ]] || declare -agx BASHRC_FLAG_REGISTRY;
    BASHRC_FLAG_REGISTRY+=("$1");
    local __onval __offval;
    [[ $1 =~ (^DISABLE|^IGNORE_|_OFF$|^NO_|^NEVER|_DISABLED$|_EXCLUDED$|_UN(^I[^AYEIOU])[A-Z]+ED$) ]] && __onval=1 || _onval=0;
    let __offval=!__onval;
    if [[ -v $1 ]]; then
        if [[ ${!1} -ne 0 ]]; then
            return $__onval;
        else
            return $__offval;
        fi;
    else
        if [[ -r ~/.config/bashrc/flags/$1 ]]; then
            eval $1=1;
            return $__onval;
        else
            eval $1=0;
            return $__offval;
        fi;
    fi
}
function __loaded_modules() 
{ 
    while IFS='	' read idx name _; do
        printf "%s %s\n" "$idx" "$name";
    done < <(pactl list modules short 2> /dev/null)
}
function __loadextsources() 
{ 
    source ${BASH_CONFIG_DIRS[root]}/sources
}
function __ltrim_colon_completions() 
{ 
    if [[ "$1" == *:* && "$COMP_WORDBREAKS" == *:* ]]; then
        local colon_word=${1%"${1##*:}"};
        local i=${#COMPREPLY[*]};
        while [[ $((--i)) -ge 0 ]]; do
            COMPREPLY[$i]=${COMPREPLY[$i]#"$colon_word"};
        done;
    fi
}
function __parse_options() 
{ 
    local option option2 i IFS=' 	
,/|';
    option=;
    for i in $1;
    do
        case $i in 
            ---*)
                break
            ;;
            --?*)
                option=$i;
                break
            ;;
            -?*)
                [[ -n $option ]] || option=$i
            ;;
            *)
                break
            ;;
        esac;
    done;
    [[ -n $option ]] || return 0;
    IFS=' 	
';
    if [[ $option =~ (\[((no|dont)-?)\]). ]]; then
        option2=${option/"${BASH_REMATCH[1]}"/};
        option2=${option2%%[<{().[]*};
        printf '%s\n' "${option2/=*/=}";
        option=${option/"${BASH_REMATCH[1]}"/"${BASH_REMATCH[2]}"};
    fi;
    option=${option%%[<{().[]*};
    printf '%s\n' "${option/=*/=}"
}
function __perdiralias() 
{ 
    local TARGET="${*: 0:1}";
    shift;
    local SUBDIRS=(*/);
    { 
        case $TARGET in 
            *)
                alias whereami='echo "processed dir: $PWD"'
            ;&
            *)
                alias whereami='echo "unprocessed dir: $PWD"'
            ;;
        esac
    }
}
function __pop_traps() 
{ 
    :
}
declare -ft __pop_traps
function __ports() 
{ 
    pactl list cards 2> /dev/null | awk -e '/^\tPorts:/ {
            flag=1; next
         }

         /^\t[A-Za-z]/ {
             flag=0
         }

         flag {
             if (/^\t\t[A-Za-z]/)
                 ports = ports substr($0, 3, index($0, ":")-3) " "
         }

         END {
             print ports
         }'
}
function __profiles() 
{ 
    pactl list cards 2> /dev/null | awk -e '/^\tProfiles:/ {
            flag=1; next
        }

        /^\t[A-Za-z]/ {
            flag=0
        }

        flag {
            if (/^\t\t[A-Za-z]/)
                profiles = profiles substr($0, 3, index($0, ": ")-3) " "
        }

        END {
            print profiles
        }'
}
function __push_traps() 
{ 
    :
}
declare -ft __push_traps
function __reassemble_comp_words_by_ref() 
{ 
    local exclude i j line ref;
    if [[ -n $1 ]]; then
        exclude="${1//[^$COMP_WORDBREAKS]}";
    fi;
    eval $3=$COMP_CWORD;
    if [[ -n $exclude ]]; then
        line=$COMP_LINE;
        for ((i=0, j=0; i < ${#COMP_WORDS[@]}; i++, j++))
        do
            while [[ $i -gt 0 && ${COMP_WORDS[$i]} == +([$exclude]) ]]; do
                [[ $line != [' 	']* ]] && (( j >= 2 )) && ((j--));
                ref="$2[$j]";
                eval $2[$j]=\${!ref}\${COMP_WORDS[i]};
                [[ $i == $COMP_CWORD ]] && eval $3=$j;
                line=${line#*"${COMP_WORDS[$i]}"};
                [[ $line == [' 	']* ]] && ((j++));
                (( $i < ${#COMP_WORDS[@]} - 1)) && ((i++)) || break 2;
            done;
            ref="$2[$j]";
            eval $2[$j]=\${!ref}\${COMP_WORDS[i]};
            line=${line#*"${COMP_WORDS[i]}"};
            [[ $i == $COMP_CWORD ]] && eval $3=$j;
        done;
        [[ $i == $COMP_CWORD ]] && eval $3=$j;
    else
        eval $2=\( \"\${COMP_WORDS[@]}\" \);
    fi
}
function __resample_methods() 
{ 
    while read name; do
        printf "%s\n" "$name";
    done < <(pulseaudio --dump-resample-methods 2> /dev/null)
}
function __set_timeformat() 
{ 
    TIMEFORMAT="* $* (%0R, %0U, %0S [%P%% CPU] @ $(date +"%H:%M:%S"))"
}
function __setflag() 
{ 
    OPTIND=0;
    while getopts "f:v:" opt; do
        case $opt in 
            f)
                DETA "file: $OPTARG will be set";
                touch ${BASH_CONFIG_DIRS[flags]}/$OPTARG
            ;;
            v)
                DETA "variable: $OPTARG will set in a variable for temporary purposes."
            ;;
            *)
                CRIT "Error? opt=$opt OPTARG=$OPTARG OPTIND=$OPTIND";
                return 1
            ;;
        esac;
    done;
    return 0
}
function __setupbashcompletions() 
{ 
    __initbashcompletion;
    if __isflag COMPLETE_ALL_BINARIES; then
        echo "* applying completion to ALL binaries (this will take a minute or two!)";
        shopt -s nullglob;
        for i in /usr/bin/* /bin/* /usr/sbin/* /sbin/* /usr/local/bin/* /usr/local/sbin/*;
        do
            complete -F _longopt $(basename $i);
        done;
        shopt -u nullglob;
        echo "* completions have been loaded";
    fi;
    if shopt -oq posix; then
        echo "Warning: posix-compatibility mode has been enabled, please check your startup scripts.";
    else
        if [[ ! -r /etc/bash.bashrc ]] || ! grep --color=auto -P bash_completion /etc/bash.bashrc -Pq; then
            if [[ -f "/usr/share/bash-completion/bash_completion" ]]; then
                source "/usr/share/bash-completion/bash_completion";
            else
                if [[ -f "/etc/bash_completion" ]]; then
                    source "/etc/bash_completion";
                fi;
            fi;
        fi;
    fi
}
function __sink_inputs() 
{ 
    while IFS='	' read idx _ _ _ _; do
        printf "%s\n" "$idx";
    done < <(pactl list sink-inputs short 2> /dev/null)
}
function __sinks() 
{ 
    while IFS='	' read _ name _ _ _; do
        printf "%s\n" "$name";
    done < <(pactl list sinks short 2> /dev/null)
}
function __sinks_idx() 
{ 
    while IFS='	' read idx _ _ _ _; do
        printf "%s\n" "$idx";
    done < <(pactl list sinks short 2> /dev/null)
}
function __source_outputs() 
{ 
    while IFS='	' read idx _ _ _ _; do
        printf "%s\n" "$idx";
    done < <(pactl list source-outputs short 2> /dev/null)
}
function __sources() 
{ 
    while IFS='	' read _ name _ _ _; do
        printf "%s\n" "$name";
    done < <(pactl list sources short 2> /dev/null)
}
function __untrap() 
{ 
    [[ -v LAST_TRAP ]] || declare -gA LAST_TRAP=(ZERO="/dev/null");
    LAST_TRAP[${*: -1}]=`trap -p "${*: -1}"`;
    trap "${*: -1}";
    set +ET
}
declare -ft __untrap
function __validflagname() 
{ 
    local FLAGNAME="$1";
    [[ $FLAGNAME =~ ^[A-Z_]+$ ]] && return 0 || return 1
}
function __wasflag() 
{ 
    local FLAGVALUE=${*: -1};
    if __isflag "$FLAGVALUE"; then
        return 0;
    else
        if __setflag "$@"; then
            return 1;
        else
            return 2;
        fi;
    fi
}
function __xlatv() 
{ 
    local search_fuzzy=`echo $1 | sed 's/./\0.*_/g;s/_$//g'`;
    local search_pfx=`echo "^${1}.*"'$'`;
    local search_suf=`echo "^.*${1}"'$'`;
    local search_sub=`echo "^.*${1}"'.*$'`;
    local search_sfuzzy=`echo $1 | sed 's/./\0.*/g;s/_$//g'`;
    unset search_items search_initiatives result XLAT_VALUE XLAT_RESULT;
    typeset -ga search_items=($search_fuzzy $search_pfx $search_suf $search_sub $search_sfuzzy);
    typeset -ga search_initiatives=("" "--ignore-case");
    typeset -ga result;
    typeset -ga variables=(`compgen -A variable`);
    for initiative in ${search_initiatives[@]};
    do
        for item in "${search_items[@]}";
        do
            [[ "$initiative" == "" ]] && unset initiative;
            for varname in "${variables[@]}";
            do
                if [[ $varname =~ $item ]]; then
                    result=$varname;
                fi;
                [[ -v $result ]] && break;
            done;
            [[ -v $result ]] && break;
        done;
        [[ -v $result ]] && break;
    done;
    if [[ ! -z $result ]] && [[ -v $result ]]; then
        declare -gx XLAT_RESULT=$result;
        declare -gx XLAT_VALUE=${!result};
        case $2 in 
            v*)
                echo -ne "$XLAT_VALUE"
            ;;
            n*)
                echo -ne "$XLAT_RESULT"
            ;;
            *)
                echo -ne "( \"$XLAT_RESULT\" \"$XLAT_VALUE\" )"
            ;;
        esac;
    else
        if [[ ! -z "$3" ]]; then
            [[ "$2" =~ ^n.* ]] && echo -ne "DEFAULT" || echo -ne "$3";
        else
            CRIT "$FUNCNAME could not use [$1] to resolve any variable [n]ame or [v]alue ($2) and NO DEFAULT GIVEN (arg 3 empty!)";
        fi;
    fi
}
function _allowed_groups() 
{ 
    if _complete_as_root; then
        local IFS='
';
        COMPREPLY=($( compgen -g -- "$1" ));
    else
        local IFS='
 ';
        COMPREPLY=($( compgen -W             "$( id -Gn 2>/dev/null || groups 2>/dev/null )" -- "$1" ));
    fi
}
function _allowed_users() 
{ 
    if _complete_as_root; then
        local IFS='
';
        COMPREPLY=($( compgen -u -- "${1:-$cur}" ));
    else
        local IFS='
 ';
        COMPREPLY=($( compgen -W             "$( id -un 2>/dev/null || whoami 2>/dev/null )" -- "${1:-$cur}" ));
    fi
}
function _apport-bug() 
{ 
    local cur dashoptions prev param;
    COMPREPLY=();
    cur=`_get_cword`;
    prev=${COMP_WORDS[COMP_CWORD-1]};
    dashoptions='-h --help --save -v --version --tag -w --window';
    case "$prev" in 
        ubuntu-bug | apport-bug)
            case "$cur" in 
                -*)
                    COMPREPLY=($( compgen -W "$dashoptions" -- $cur ))
                ;;
                *)
                    _apport_parameterless
                ;;
            esac
        ;;
        --save)
            COMPREPLY=($( compgen -o default -G "$cur*" ))
        ;;
        -w | --window)
            dashoptions="--save --tag";
            COMPREPLY=($( compgen -W "$dashoptions" -- $cur ))
        ;;
        -h | --help | -v | --version | --tag)
            return 0
        ;;
        *)
            dashoptions="--tag";
            if ! [[ "${COMP_WORDS[*]}" =~ .*--save.* ]]; then
                dashoptions="--save $dashoptions";
            fi;
            if ! [[ "${COMP_WORDS[*]}" =~ .*--window.* || "${COMP_WORDS[*]}" =~ .*\ -w\ .* ]]; then
                dashoptions="-w --window $dashoptions";
            fi;
            case "$cur" in 
                -*)
                    COMPREPLY=($( compgen -W "$dashoptions" -- $cur ))
                ;;
                *)
                    _apport_parameterless
                ;;
            esac
        ;;
    esac
}
function _apport-cli() 
{ 
    local cur dashoptions prev param;
    COMPREPLY=();
    cur=`_get_cword`;
    prev=${COMP_WORDS[COMP_CWORD-1]};
    dashoptions='-h --help -f --file-bug -u --update-bug -s --symptom \
                 -c --crash-file --save -v --version --tag -w --window';
    case "$prev" in 
        apport-cli)
            case "$cur" in 
                -*)
                    COMPREPLY=($( compgen -W "$dashoptions" -- $cur ))
                ;;
                *)
                    _apport_parameterless
                ;;
            esac
        ;;
        -f | --file-bug)
            param="-P --pid -p --package -s --symptom";
            COMPREPLY=($( compgen -W "$param $(_apport_symptoms)" -- $cur))
        ;;
        -s | --symptom)
            COMPREPLY=($( compgen -W "$(_apport_symptoms)" -- $cur))
        ;;
        --save)
            COMPREPLY=($( compgen -o default -G "$cur*" ))
        ;;
        -c | --crash-file)
            COMPREPLY=($( compgen -G "${cur}*.apport"
                       compgen -G "${cur}*.crash" ))
        ;;
        -w | --window)
            dashoptions="--save --tag";
            COMPREPLY=($( compgen -W "$dashoptions" -- $cur ))
        ;;
        -h | --help | -v | --version | --tag)
            return 0
        ;;
        *)
            dashoptions='--tag';
            if ! [[ "${COMP_WORDS[*]}" =~ .*--save.* ]]; then
                dashoptions="--save $dashoptions";
            fi;
            if ! [[ "${COMP_WORDS[*]}" =~ .*--window.* || "${COMP_WORDS[*]}" =~ .*\ -w\ .* ]]; then
                dashoptions="-w --window $dashoptions";
            fi;
            if ! [[ "${COMP_WORDS[*]}" =~ .*--symptom.* || "${COMP_WORDS[*]}" =~ .*\ -s\ .* ]]; then
                dashoptions="-s --symptom $dashoptions";
            fi;
            if ! [[ "${COMP_WORDS[*]}" =~ .*--update.* || "${COMP_WORDS[*]}" =~ .*\ -u\ .* ]]; then
                dashoptions="-u --update $dashoptions";
            fi;
            if ! [[ "${COMP_WORDS[*]}" =~ .*--file-bug.* || "${COMP_WORDS[*]}" =~ .*\ -f\ .* ]]; then
                dashoptions="-f --file-bug $dashoptions";
            fi;
            if ! [[ "${COMP_WORDS[*]}" =~ .*--crash-file.* || "${COMP_WORDS[*]}" =~ .*\ -c\ .* ]]; then
                dashoptions="-c --crash-file $dashoptions";
            fi;
            case "$cur" in 
                -*)
                    COMPREPLY=($( compgen -W "$dashoptions" -- $cur ))
                ;;
                *)
                    _apport_parameterless
                ;;
            esac
        ;;
    esac
}
function _apport-collect() 
{ 
    local cur prev;
    COMPREPLY=();
    cur=`_get_cword`;
    prev=${COMP_WORDS[COMP_CWORD-1]};
    case "$prev" in 
        apport-collect)
            COMPREPLY=($( compgen -W "-p --package --tag" -- $cur))
        ;;
        -p | --package)
            COMPREPLY=($( apt-cache pkgnames $cur 2> /dev/null ))
        ;;
        --tag)
            return 0
        ;;
        *)
            if [[ "${COMP_WORDS[*]}" =~ .*\ -p.* || "${COMP_WORDS[*]}" =~ .*--package.* ]]; then
                COMPREPLY=($( compgen -W "--tag" -- $cur));
            else
                COMPREPLY=($( compgen -W "-p --package --tag" -- $cur));
            fi
        ;;
    esac
}
function _apport-unpack() 
{ 
    local cur prev;
    COMPREPLY=();
    cur=`_get_cword`;
    prev=${COMP_WORDS[COMP_CWORD-1]};
    case "$prev" in 
        apport-unpack)
            COMPREPLY=($( compgen -G "${cur}*.apport"
                       compgen -G "${cur}*.crash" ))
        ;;
    esac
}
function _apport_parameterless() 
{ 
    local param;
    param="$dashoptions            $( apt-cache pkgnames $cur 2> /dev/null )            $( command ps axo pid | sed 1d )            $( _apport_symptoms )            $( compgen -G "${cur}*" )";
    COMPREPLY=($( compgen -W "$param" -- $cur))
}
function _apport_symptoms() 
{ 
    local syms;
    if [ -r /usr/share/apport/symptoms ]; then
        for FILE in $(ls /usr/share/apport/symptoms);
        do
            if [[ ! "$FILE" =~ ^_.* && -n $(egrep "^def run\s*\(.*\):" /usr/share/apport/symptoms/$FILE) ]]; then
                syms="$syms ${FILE%.py}";
            fi;
        done;
    fi;
    echo $syms
}
function _available_interfaces() 
{ 
    local cmd PATH=$PATH:/sbin;
    if [[ ${1:-} == -w ]]; then
        cmd="iwconfig";
    else
        if [[ ${1:-} == -a ]]; then
            cmd="{ ifconfig || ip link show up; }";
        else
            cmd="{ ifconfig -a || ip link show; }";
        fi;
    fi;
    COMPREPLY=($( eval $cmd 2>/dev/null | awk         '/^[^ \t]/ { if ($1 ~ /^[0-9]+:/) { print $2 } else { print $1 } }' ));
    COMPREPLY=($( compgen -W '${COMPREPLY[@]/%[[:punct:]]/}' -- "$cur" ))
}
function _axi_cache() 
{ 
    local cur prev cmd;
    COMPREPLY=();
    COMP_WORDBREAKS=${COMP_WORDBREAKS//:};
    type _get_comp_words_by_ref &> /dev/null && { 
        _get_comp_words_by_ref -n: cur prev
    } || { 
        cur=$(_get_cword ":");
        prev=${COMP_WORDS[$COMP_CWORD-1]}
    };
    cmd=${COMP_WORDS[1]};
    case "$prev" in 
        *axi-cache*)
            COMPREPLY=($(compgen -W "help more search show again showpkg showsrc depends rdepends policy madison" -- "$cur"));
            return 0
        ;;
        --sort)
            COMPREPLY=($(compgen -W "$(egrep ^[a-z] /var/lib/apt-xapian-index/values | awk -F"\t" '{print $1}')" -- "$cur"));
            return 0
        ;;
    esac;
    case "$cmd" in 
        search | again)
            if [[ "$cur" == -* ]]; then
                COMPREPLY=($(compgen -W "--sort --tags" -- "$cur"));
                return 0;
            fi
        ;;
        show | showpkg | showsrc | depends | rdepends | policy | madison)
            if [[ "$cur" == -* ]]; then
                COMPREPLY=($(compgen -W "--last" -- "$cur"));
                return 0;
            fi
        ;;
        *)
            return 0
        ;;
    esac;
    if [ -n "$cur" ]; then
        COMPREPLY=($(compgen -W "$(${COMP_WORDS[@]} --tabcomplete=partial)" -- "$cur"));
    else
        COMPREPLY=($(compgen -W "$(${COMP_WORDS[@]} --tabcomplete=plain)" -- "$cur"));
    fi;
    return 0
}
function _cd() 
{ 
    local cur prev words cword;
    _init_completion || return;
    local IFS='
' i j k;
    compopt -o filenames;
    if [[ -z "${CDPATH:-}" || "$cur" == ?(.)?(.)/* ]]; then
        _filedir -d;
        return 0;
    fi;
    local -r mark_dirs=$(_rl_enabled mark-directories && echo y);
    local -r mark_symdirs=$(_rl_enabled mark-symlinked-directories && echo y);
    for i in ${CDPATH//:/'
'};
    do
        k="${#COMPREPLY[@]}";
        for j in $( compgen -d $i/$cur );
        do
            if [[ ( -n $mark_symdirs && -h $j || -n $mark_dirs && ! -h $j ) && ! -d ${j#$i/} ]]; then
                j+="/";
            fi;
            COMPREPLY[k++]=${j#$i/};
        done;
    done;
    _filedir -d;
    if [[ ${#COMPREPLY[@]} -eq 1 ]]; then
        i=${COMPREPLY[0]};
        if [[ "$i" == "$cur" && $i != "*/" ]]; then
            COMPREPLY[0]="${i}/";
        fi;
    fi;
    return 0
}
function _cd_devices() 
{ 
    COMPREPLY+=($( compgen -f -d -X "!*/?([amrs])cd*" -- "${cur:-/dev/}" ))
}
function _cmake() 
{ 
    local cur prev words cword split=false;
    _init_completion -n := || return;
    local prefix=;
    if [[ $cur == -D* ]]; then
        prev=-D;
        prefix=-D;
        cur="${cur#-D}";
    else
        if [[ $cur == -U* ]]; then
            prev=-U;
            prefix=-U;
            cur="${cur#-U}";
        fi;
    fi;
    case "$prev" in 
        -D)
            if [[ $cur == *=* ]]; then
                local var type value;
                var="${cur%%[:=]*}";
                value="${cur#*=}";
                if [[ $cur == CMAKE_BUILD_TYPE* ]]; then
                    COMPREPLY=($( compgen -W 'Debug Release RelWithDebInfo
                        MinSizeRel' -- "$value" ));
                    return;
                fi;
                if [[ $cur == *:* ]]; then
                    type="${cur#*:}";
                    type="${type%%=*}";
                else
                    type=$( cmake -LA -N 2>/dev/null | grep "$var:"                         2>/dev/null );
                    type="${type#*:}";
                    type="${type%%=*}";
                fi;
                case "$type" in 
                    FILEPATH)
                        cur="$value";
                        _filedir;
                        return
                    ;;
                    PATH)
                        cur="$value";
                        _filedir -d;
                        return
                    ;;
                    BOOL)
                        COMPREPLY=($( compgen -W 'ON OFF TRUE FALSE' --                             "$value" ));
                        return
                    ;;
                    STRING | INTERNAL)
                        return
                    ;;
                esac;
            else
                if [[ $cur == *:* ]]; then
                    local type="${cur#*:}";
                    COMPREPLY=($( compgen -W 'FILEPATH PATH STRING BOOL INTERNAL'                    -S = -- "$type" ));
                    compopt -o nospace;
                else
                    COMPREPLY=($( compgen -W '$( cmake -LA -N | tail -n +2 |
                    cut -f1 -d: )' -P "$prefix" -- "$cur" ));
                    compopt -o nospace;
                fi;
            fi;
            return
        ;;
        -U)
            COMPREPLY=($( compgen -W '$( cmake -LA -N | tail -n +2 |
                cut -f1 -d: )' -P "$prefix" -- "$cur" ));
            return
        ;;
    esac;
    _split_longopt && split=true;
    case "$prev" in 
        -C | -P | --graphviz | --system-information)
            _filedir;
            return
        ;;
        --build)
            _filedir -d;
            return
        ;;
        -E)
            COMPREPLY=($( compgen -W "$( cmake -E help |& sed -n                 '/^  /{s|^  \([^ ]\{1,\}\) .*$|\1|;p}' 2>/dev/null )"                 -- "$cur" ));
            return
        ;;
        -G)
            local IFS='
';
            local quoted;
            printf -v quoted %q "$cur";
            COMPREPLY=($( compgen -W '$( cmake --help 2>/dev/null | sed -n \
                -e "1,/^Generators/d" \
                -e "/^  *[^ =]/{s|^ *\([^=]*[^ =]\).*$|\1|;s| |\\\\ |g;p}" \
                2>/dev/null )' -- "$quoted" ));
            return
        ;;
        --help-command)
            COMPREPLY=($( compgen -W '$( cmake --help-command-list 2>/dev/null|
                grep -v "^cmake version " )' -- "$cur" ));
            return
        ;;
        --help-module)
            COMPREPLY=($( compgen -W '$( cmake --help-module-list 2>/dev/null|
                grep -v "^cmake version " )' -- "$cur" ));
            return
        ;;
        --help-policy)
            COMPREPLY=($( compgen -W '$( cmake --help-policies 2>/dev/null |
                grep "^  CMP" 2>/dev/null )' -- "$cur" ));
            return
        ;;
        --help-property)
            COMPREPLY=($( compgen -W '$( cmake --help-property-list \
                2>/dev/null | grep -v "^cmake version " )' -- "$cur" ));
            return
        ;;
        --help-variable)
            COMPREPLY=($( compgen -W '$( cmake --help-variable-list \
                2>/dev/null | grep -v "^cmake version " )' -- "$cur" ));
            return
        ;;
    esac;
    $split && return;
    if [[ "$cur" == -* ]]; then
        COMPREPLY=($(compgen -W '$( _parse_help "$1" --help )' -- ${cur}));
        [[ $COMPREPLY == *= ]] && compopt -o nospace;
        [[ -n $COMPREPLY ]] && return;
    fi;
    _filedir
}
function _command() 
{ 
    local offset i;
    offset=1;
    for ((i=1; i <= COMP_CWORD; i++ ))
    do
        if [[ "${COMP_WORDS[i]}" != -* ]]; then
            offset=$i;
            break;
        fi;
    done;
    _command_offset $offset
}
function _command_offset() 
{ 
    local word_offset=$1 i j;
    for ((i=0; i < $word_offset; i++ ))
    do
        for ((j=0; j <= ${#COMP_LINE}; j++ ))
        do
            [[ "$COMP_LINE" == "${COMP_WORDS[i]}"* ]] && break;
            COMP_LINE=${COMP_LINE:1};
            ((COMP_POINT--));
        done;
        COMP_LINE=${COMP_LINE#"${COMP_WORDS[i]}"};
        ((COMP_POINT-=${#COMP_WORDS[i]}));
    done;
    for ((i=0; i <= COMP_CWORD - $word_offset; i++ ))
    do
        COMP_WORDS[i]=${COMP_WORDS[i+$word_offset]};
    done;
    for ((i; i <= COMP_CWORD; i++ ))
    do
        unset COMP_WORDS[i];
    done;
    ((COMP_CWORD -= $word_offset));
    COMPREPLY=();
    local cur;
    _get_comp_words_by_ref cur;
    if [[ $COMP_CWORD -eq 0 ]]; then
        local IFS='
';
        compopt -o filenames;
        COMPREPLY=($( compgen -d -c -- "$cur" ));
    else
        local cmd=${COMP_WORDS[0]} compcmd=${COMP_WORDS[0]};
        local cspec=$( complete -p $cmd 2>/dev/null );
        if [[ ! -n $cspec && $cmd == */* ]]; then
            cspec=$( complete -p ${cmd##*/} 2>/dev/null );
            [[ -n $cspec ]] && compcmd=${cmd##*/};
        fi;
        if [[ ! -n $cspec ]]; then
            compcmd=${cmd##*/};
            _completion_loader $compcmd;
            cspec=$( complete -p $compcmd 2>/dev/null );
        fi;
        if [[ -n $cspec ]]; then
            if [[ ${cspec#* -F } != $cspec ]]; then
                local func=${cspec#*-F };
                func=${func%% *};
                if [[ ${#COMP_WORDS[@]} -ge 2 ]]; then
                    $func $cmd "${COMP_WORDS[${#COMP_WORDS[@]}-1]}" "${COMP_WORDS[${#COMP_WORDS[@]}-2]}";
                else
                    $func $cmd "${COMP_WORDS[${#COMP_WORDS[@]}-1]}";
                fi;
                local opt;
                while [[ $cspec == *" -o "* ]]; do
                    cspec=${cspec#*-o };
                    opt=${cspec%% *};
                    compopt -o $opt;
                    cspec=${cspec#$opt};
                done;
            else
                cspec=${cspec#complete};
                cspec=${cspec%%$compcmd};
                COMPREPLY=($( eval compgen "$cspec" -- '$cur' ));
            fi;
        else
            if [[ ${#COMPREPLY[@]} -eq 0 ]]; then
                _minimal;
            fi;
        fi;
    fi
}
function _complete_as_root() 
{ 
    [[ $EUID -eq 0 || -n ${root_command:-} ]]
}
function _completion_loader() 
{ 
    local compfile=./completions;
    [[ $BASH_SOURCE == */* ]] && compfile="${BASH_SOURCE%/*}/completions";
    compfile+="/${1##*/}";
    [[ -f "$compfile" ]] && . "$compfile" &> /dev/null && return 124;
    complete -F _minimal "$1" && return 124
}
function _configured_interfaces() 
{ 
    if [[ -f /etc/debian_version ]]; then
        COMPREPLY=($( compgen -W "$( sed -ne 's|^iface \([^ ]\{1,\}\).*$|\1|p'            /etc/network/interfaces )" -- "$cur" ));
    else
        if [[ -f /etc/SuSE-release ]]; then
            COMPREPLY=($( compgen -W "$( printf '%s\n'             /etc/sysconfig/network/ifcfg-* |             sed -ne 's|.*ifcfg-\(.*\)|\1|p' )" -- "$cur" ));
        else
            if [[ -f /etc/pld-release ]]; then
                COMPREPLY=($( compgen -W "$( command ls -B             /etc/sysconfig/interfaces |             sed -ne 's|.*ifcfg-\(.*\)|\1|p' )" -- "$cur" ));
            else
                COMPREPLY=($( compgen -W "$( printf '%s\n'             /etc/sysconfig/network-scripts/ifcfg-* |             sed -ne 's|.*ifcfg-\(.*\)|\1|p' )" -- "$cur" ));
            fi;
        fi;
    fi
}
function _count_args() 
{ 
    local i cword words;
    __reassemble_comp_words_by_ref "$1" words cword;
    args=1;
    for i in "${words[@]:1:cword-1}";
    do
        [[ "$i" != -* ]] && args=$(($args+1));
    done
}
function _cpack() 
{ 
    local cur prev words cword;
    _init_completion -n = || return;
    case "$prev" in 
        -G)
            COMPREPLY=($( compgen -W '$( cpack --help 2>/dev/null |
                sed -e "1,/^Generators/d" -e "s|^ *\([^ ]*\) .*$|\1|" \
                2>/dev/null )' -- "$cur" ));
            return
        ;;
        -C)
            COMPREPLY=($( compgen -W 'Debug Release RelWithDebInfo
                MinSizeRel' -- "$cur" ));
            return
        ;;
        -D)
            [[ $cur == *=* ]] && return;
            COMPREPLY=($( compgen -W '$( cpack --help-variable-list \
                2>/dev/null | grep -v "^cpack version " )' -S = -- "$cur" ));
            compopt -o nospace;
            return
        ;;
        -P | -R | --vendor)
            return
        ;;
        -B)
            _filedir -d;
            return
        ;;
        --config)
            _filedir;
            return
        ;;
        --help-command)
            COMPREPLY=($( compgen -W '$( cpack --help-command-list 2>/dev/null|
                grep -v "^cpack version " )' -- "$cur" ));
            return
        ;;
        --help-variable)
            COMPREPLY=($( compgen -W '$( cpack --help-variable-list \
                2>/dev/null | grep -v "^cpack version " )' -- "$cur" ));
            return
        ;;
    esac;
    if [[ "$cur" == -* ]]; then
        COMPREPLY=($(compgen -W '$( _parse_help "$1" --help )' -- ${cur}));
        [[ $COMPREPLY == *= ]] && compopt -o nospace;
        [[ -n $COMPREPLY ]] && return;
    fi;
    _filedir
}
function _cryptdisks() 
{ 
    local tf;
    tf=${TABFILE-"/etc/crypttab"};
    COMPREPLY=($(egrep -v "^[[:space:]]*(#|$)" "${tf}" | egrep -o "^${COMP_WORDS[COMP_CWORD]}[^[:space:]]*"));
    return 0
}
function _ctest() 
{ 
    local cur prev words cword;
    _init_completion -n = || return;
    case "$prev" in 
        -C | --build-config)
            COMPREPLY=($( compgen -W 'Debug Release RelWithDebInfo
                MinSizeRel' -- "$cur" ));
            return
        ;;
        -j | --parallel)
            COMPREPLY=($( compgen -W "{1..$(( $(_ncpus)*2 ))}" -- "$cur" ));
            return
        ;;
        -O | --output-log | -A | --add-notes | --extra-submit)
            _filedir;
            return
        ;;
        -L | --label-regex | -LE | --label-exclude | --track | -I | --tests-information | --max-width | --timeout | --stop-time)
            return
        ;;
        -R | --tests-regex | -E | --exclude-regex)
            COMPREPLY=($( compgen -W '$( ctest -N 2>/dev/null |
                grep "^  Test" 2>/dev/null | cut -d: -f 2 )' -- "$cur" ));
            return
        ;;
        -D | --dashboard)
            if [[ $cur == @(Experimental|Nightly|Continuous)* ]]; then
                local model action;
                action=${cur#@(Experimental|Nightly|Continuous)};
                model=${cur%"$action"};
                COMPREPLY=($( compgen -W 'Start Update Configure Build Test
                    Coverage Submit MemCheck' -P "$model" -- "$action" ));
            else
                COMPREPLY=($( compgen -W 'Experimental Nightly Continuous'                 -- "$cur" ));
                compopt -o nospace;
            fi;
            return
        ;;
        -M | --test-model)
            COMPREPLY=($( compgen -W 'Experimental Nightly Continuous' --                 "$cur" ));
            return
        ;;
        -T | --test-action)
            COMPREPLY=($( compgen -W 'Start Update Configure Build Test
                Coverage Submit MemCheck' -- "$cur" ));
            return
        ;;
        -S | --script | -SP | --script-new-process)
            _filedir '@(cmake|ctest)';
            return
        ;;
        --interactive-debug-mode)
            COMPREPLY=($( compgen -W '0 1' -- "$cur" ));
            return
        ;;
        --help-command)
            COMPREPLY=($( compgen -W '$( ctest --help-command-list 2>/dev/null|
                grep -v "^ctest version " )' -- "$cur" ));
            return
        ;;
    esac;
    if [[ "$cur" == -* ]]; then
        COMPREPLY=($(compgen -W '$( _parse_help "$1" --help )' -- ${cur}));
        [[ $COMPREPLY == *= ]] && compopt -o nospace;
        [[ -n $COMPREPLY ]] && return;
    fi;
    _filedir
}
function _cur_col() 
{ 
    slice_func _cur_pos;
    local ret=`_cur_pos | sed 's/^[0-9]*//g'`;
    echo $ret;
    return $ret
}
function _cur_pos() 
{ 
    local OLD_TERM_STATE OLDIFS CROW CCOL;
    OLD_TERM_STATE=`stty -g`;
    OLDIFS="$IFS";
    IFS=";";
    CROW=0;
    CCOL=0;
    printf "%0d %0d" $CROW $CCOL
}
function _cur_row() 
{ 
    slice_func _cur_pos;
    local ret=`_cur_pos | sed 's/[0-9]*$//g'`;
    echo $ret;
    return $ret
}
function _debconf_show() 
{ 
    local cur;
    COMPREPLY=();
    cur=${COMP_WORDS[COMP_CWORD]};
    COMPREPLY=($( compgen -W '--listowners --listdbs --db=' -- $cur ) $( apt-cache pkgnames -- $cur ))
}
function _desktop_file_validate() 
{ 
    COMPRELY=();
    cur=${COMP_WORDS[COMP_CWORD]};
    _filedir '@(desktop)'
}
function _dialog() 
{ 
    [[ ! -v MAPPINGS ]] && declare -Agx MAPPINGS;
    MAPPINGS[gdialog]=dialog;
    local CMDNAME=$1;
    local FOUNDFLAG=0;
    local CURIDX=0;
    for item in "${!MAPPINGS[@]}";
    do
        if [[ $item == $CMDNAME ]]; then
            CMDNAME="${MAPPINGS[$item]}";
        fi;
    done;
    for item in "${COMP_WORDS[@]}";
    do
        CURIDX+=1;
        [[ $CURIDX == $COMP_CWORD ]] && break;
        if [[ "$item" =~ ^--[a-z]+ ]]; then
            FOUNDFLAG=1;
            local FOUNDITEM="$item";
        else
            :;
        fi;
    done;
    if [[ $FOUNDFLAG == 1 ]]; then
        if $CMDNAME --help | grep --color=auto -P '^\s*'$FOUNDITEM &> /dev/null; then
            echo;
            $CMDNAME --help | grep --color=auto -P --color=never -P '^\s*'$FOUNDITEM 2>&1;
            echo -ne "$COMP_LINE";
        else
            _longopt "$@";
            return $?;
        fi;
    else
        _minimal "$@";
        return $?;
    fi;
    return 0
}
function _dkms() 
{ 
    local cur prev command module i;
    COMPREPLY=();
    cur=${COMP_WORDS[COMP_CWORD]};
    if [[ $COMP_CWORD -eq 1 ]]; then
        COMPREPLY=($( compgen -W "add autoinstall remove build install uninstall 			match mkdriverdisk mktarball ldtarball mkrpm mkdeb mkdsc mkkmp 			status" -- $cur ));
    else
        prev=${COMP_WORDS[COMP_CWORD-1]};
        command=${COMP_WORDS[1]};
        case $prev in 
            -m)
                if [ "$command" = 'add' ]; then
                    _filename_parts '.*-.*' 1;
                else
                    _subdirectories /var/lib/dkms;
                fi;
                return 0
            ;;
            -v)
                for ((i=1; i < COMP_CWORD; i++ ))
                do
                    if [[ "${COMP_WORDS[i]}" == -m ]]; then
                        module=${COMP_WORDS[i+1]};
                        break;
                    fi;
                done;
                if [ -n "$module" ]; then
                    if [ "$command" = 'add' ]; then
                        _filename_parts "$module-.*" 2;
                    else
                        _subdirectories /var/lib/dkms/$module;
                    fi;
                    return 0;
                fi
            ;;
            -k)
                _kernels;
                return 0
            ;;
            -@\(c | -spec | -archive | -config\))
                _filedir;
                return 0
            ;;
            --kernelsourcedir)
                _filedir -d;
                return 0
            ;;
        esac;
        if [[ "$cur" == -* ]]; then
            case $command in 
                add)
                    options='-c --rpm_safe_upgrade'
                ;;
                remove)
                    options='--rpm_safe_upgrade'
                ;;
                build)
                    options='--config'
                ;;
                mkdriverdisk)
                    options='-d --distro -r --release --size'
                ;;
                ldtarball)
                    options='--archive --force'
                ;;
                mktarball)
                    options='--source-only --binaries-only'
                ;;
                mkrpm)
                    options='--source-only'
                ;;
                mkkmp)
                    options='--spec'
                ;;
                match)
                    options='--templatekernel'
                ;;
            esac;
            options="$options -m -v -k -a --arch -q --quiet -V 				--version --all --no-prepare-kernel 				--no-clean-kernel --kernelsourcedir 				--directive";
            COMPREPLY=($( compgen -W "$options" -- $cur ));
        fi;
    fi
}
function _dvd_devices() 
{ 
    COMPREPLY+=($( compgen -f -d -X "!*/?(r)dvd*" -- "${cur:-/dev/}" ))
}
function _expand() 
{ 
    if [[ "$cur" == \~*/* ]]; then
        eval cur=$cur 2> /dev/null;
    else
        if [[ "$cur" == \~* ]]; then
            cur=${cur#\~};
            COMPREPLY=($( compgen -P '~' -u "$cur" ));
            [[ ${#COMPREPLY[@]} -eq 1 ]] && eval COMPREPLY[0]=${COMPREPLY[0]};
            return ${#COMPREPLY[@]};
        fi;
    fi
}
function _filedir() 
{ 
    local i IFS='
' xspec;
    _tilde "$cur" || return 0;
    local -a toks;
    local quoted x tmp;
    _quote_readline_by_ref "$cur" quoted;
    x=$( compgen -d -- "$quoted" ) && while read -r tmp; do
        toks+=("$tmp");
    done <<< "$x";
    if [[ "$1" != -d ]]; then
        xspec=${1:+"!*.@($1|${1^^})"};
        x=$( compgen -f -X "$xspec" -- $quoted ) && while read -r tmp; do
            toks+=("$tmp");
        done <<< "$x";
    fi;
    [[ -n ${COMP_FILEDIR_FALLBACK:-} && -n "$1" && "$1" != -d && ${#toks[@]} -lt 1 ]] && x=$( compgen -f -- $quoted ) && while read -r tmp; do
        toks+=("$tmp");
    done <<< "$x";
    if [[ ${#toks[@]} -ne 0 ]]; then
        compopt -o filenames 2> /dev/null;
        COMPREPLY+=("${toks[@]}");
    fi
}
function _filedir_xspec() 
{ 
    local cur prev words cword;
    _init_completion || return;
    _tilde "$cur" || return 0;
    local IFS='
' xspec=${_xspecs[${1##*/}]} tmp;
    local -a toks;
    toks=($(
        compgen -d -- "$(quote_readline "$cur")" | {
        while read -r tmp; do
            printf '%s\n' $tmp
        done
        }
        ));
    eval xspec="${xspec}";
    local matchop=!;
    if [[ $xspec == !* ]]; then
        xspec=${xspec#!};
        matchop=@;
    fi;
    xspec="$matchop($xspec|${xspec^^})";
    toks+=($(
        eval compgen -f -X "!$xspec" -- "\$(quote_readline "\$cur")" | {
        while read -r tmp; do
            [[ -n $tmp ]] && printf '%s\n' $tmp
        done
        }
        ));
    if [[ ${#toks[@]} -ne 0 ]]; then
        compopt -o filenames;
        COMPREPLY=("${toks[@]}");
    fi
}
function _filename_parts() 
{ 
    COMPREPLY=($( command ls -F /usr/src/ 2>/dev/null | grep -E '^'$1'/$' 		| sed -r -e 's/^([^-]+)-(.+)\/$/\'$2'/' | grep "^$cur" ))
}
function _fstypes() 
{ 
    local fss;
    if [[ -e /proc/filesystems ]]; then
        fss="$( cut -d'	' -f2 /proc/filesystems )
             $( awk '! /\*/ { print $NF }' /etc/filesystems 2>/dev/null )";
    else
        fss="$( awk '/^[ \t]*[^#]/ { print $3 }' /etc/fstab 2>/dev/null )
             $( awk '/^[ \t]*[^#]/ { print $3 }' /etc/mnttab 2>/dev/null )
             $( awk '/^[ \t]*[^#]/ { print $4 }' /etc/vfstab 2>/dev/null )
             $( awk '{ print $1 }' /etc/dfs/fstypes 2>/dev/null )
             $( [[ -d /etc/fs ]] && command ls /etc/fs )";
    fi;
    [[ -n $fss ]] && COMPREPLY+=($( compgen -W "$fss" -- "$cur" ))
}
function _g_collect() 
{ 
    local -i retv=0;
    [[ -v UNLOADABLES ]] || return;
    for unload_var in $UNLOADABLES;
    do
        if ! unset $unload_var; then
            echo "Warning: $FUNCNAME: cannot unset $unload_var";
            let retv++;
        fi;
    done;
    return $retv
}
function _gem191() 
{ 
    local cur prev completions;
    COMPREPLY=();
    cur=${COMP_WORDS[COMP_CWORD]};
    prev=${COMP_WORDS[COMP_CWORD-1]};
    COMMANDS='build cert check cleanup contents dependency\
      environment fetch generate_index help install list\
      lock mirror outdated pristine query rdoc search server\
      sources specification uninstall unpack update which';
    GEM_OPTIONS='\
      -h --help\
      -v --version';
    COMMON_OPTIONS='\
      -h --help\
      -V --verbose --no-verbose\
      -q --quiet\
      --config-file\
      --backtrace\
      --debug';
    CERT_OPTIONS='\
      -a -add\
      -l --list\
      -r --remove\
      -b --build\
      -C --certificate\
      -K --private-key\
      -s --sign';
    CHECK_OPTIONS='\
      --verify\
      -a --alien\
      -t --test\
      -v --version';
    CLEANUP_OPTIONS='\
      -d --dry-run';
    CONTENTS_OPTIONS='\
      -v --version\
      -s --spec-dir\
      -l --lib-only --no-lib-only';
    DEPENDENCY_OPTIONS='\
      -v --version\
      --platform\
      -R --reverse-dependencies --no-reverse-dependencies\
      -p --pipe';
    ENVIRONMENT_OPTIONS='';
    FETCH_OPTIONS='\
      -v --version\
      --platform\
      -B --bulk-threshold\
      -p --http-proxy --no-http-proxy\
      --source';
    GENERATE_INDEX_OPTIONS='\
      -d --directory';
    HELP_OPTIONS=$COMMANDS;
    INSTALL_OPTIONS='\
      --platform\
      -v --version\
      -i --install-dir\
      -d --rdoc --no-rdoc\
      --ri --no-ri\
      -E --env-shebang\
      -f --force --no-force\
      -t --test --no-test\
      -w --wrappers --no-wrappers\
      -P --trust-policy\
      --ignore-dependencies\
      -y --include-dependencies\
      --format-executable --no-format-executable\
      -l --local\
      -r --remote\
      -b --both\
      -B --bulk-threshold\
      --source\
      -p --http-proxy --no-http-proxy\
      -u --update-sources --no-update-sources';
    LIST_OPTIONS='\
      -d --details --no-details\
      --versions --no-versions\
      -l --local\
      -r --remote\
      -b --both\
      -B --bulk-threshold\
      --source\
      -p --http-proxy --no-http-proxy\
      -u --update-sources --no-update-sources';
    LOCK_OPTIONS='\
      -s --strict --no-strict';
    MIRROR_OPTIONS='';
    OUTDATED_OPTIONS='\
      --platform';
    PRISTINE_OPTIONS='\
      --all\
      -v --version';
    QUERY_OPTIONS='\
      -n --name-matches\
      -d --details --no-details\
      --versions --no-versions\
      -l --local\
      -r --remote\
      -b --both\
      -B --bulk-threshold\
      --source\
      -p --http-proxy --no-http-proxy\
      -u --update-sources --no-update-sources';
    RDOC_OPTIONS='\
      --all\
      --rdoc --no-rdoc\
      --ri --no-ri\
      -v --version';
    SEARCH_OPTIONS='\
      -d --details --no-details\
      --versions --no-versions\
      -l --local\
      -r --remote\
      -b --both\
      -B --bulk-threshold\
      --source\
      -p --http-proxy --no-http-proxy\
      -u --update-sources --no-update-sources';
    SERVER_OPTIONS='\
      -p --port\
      -d --dir\
      --daemon --no-daemon';
    SOURCES_OPTIONS='\
      -a --add\
      -l --list\
      -r --remove\
      -u --update\
      -c --clear-all';
    SPECIFICATION_OPTIONS='\
      -v --version\
      --platform\
      --all\
      -l --local\
      -r --remote\
      -b --both\
      -B --bulk-threshold\
      --source\
      -p --http-proxy --no-http-proxy\
      -u --update-sources --no-update-sources';
    UNINSTALL_OPTIONS='\
      -a --all --no-all\
      -i --ignore-dependencies --no-ignore-dependencies\
      -x --executables --no-executables\
      -v --version\
      --platform';
    UNPACK_OPTIONS='\
      --target\
      -v --version';
    UPDATE_OPTIONS='\
      --system\
      --platform\
      -i --install-dir\
      -d --rdoc --no-rdoc\
      --ri --no-ri\
      -E --env-shebang\
      -f --force --no-force\
      -t --test --no-test\
      -w --wrappers --no-wrappers\
      -P --trust-policy\
      --ignore-dependencies\
      -y --include-dependencies\
      --format-executable --no-format-executable\
      -l --local\
      -r --remote\
      -b --both\
      -B --bulk-threshold\
      --source\
      -p --http-proxy --no-http-proxy\
      -u --update-sources --no-update-sources';
    WHICH_OPTIONS='\
      -a --all --no-all\
      -g --gems-first --no-gems-first';
    case "${prev}" in 
        build)
            completions="$COMMON_OPTIONS $BUILD_OPTIONS"
        ;;
        cert)
            completions="$COMMON_OPTIONS $CERT_OPTIONS"
        ;;
        check)
            completions="$COMMON_OPTIONS $CHECK_OPTIONS"
        ;;
        cleanup)
            completions="$COMMON_OPTIONS $CLEANUP_OPTIONS"
        ;;
        contents)
            completions="$COMMON_OPTIONS $CONTENTS_OPTIONS"
        ;;
        dependency)
            completions="$COMMON_OPTIONS $DEPENDENCY_OPTIONS"
        ;;
        environment)
            completions="$COMMON_OPTIONS $ENVIRONMENT_OPTIONS"
        ;;
        fetch)
            completions="$COMMON_OPTIONS $FETCH_OPTIONS"
        ;;
        generate_index)
            completions="$COMMON_OPTIONS $GENERATE_INDEX_OPTIONS"
        ;;
        help)
            completions="$COMMON_OPTIONS $HELP_OPTIONS"
        ;;
        install)
            completions="$COMMON_OPTIONS $INSTALL_OPTIONS"
        ;;
        list)
            completions="$COMMON_OPTIONS $LIST_OPTIONS"
        ;;
        lock)
            completions="$COMMON_OPTIONS $LOCK_OPTIONS"
        ;;
        mirror)
            completions="$COMMON_OPTIONS $MIRROR_OPTIONS"
        ;;
        outdated)
            completions="$COMMON_OPTIONS $OUTDATED_OPTIONS"
        ;;
        pristine)
            completions="$COMMON_OPTIONS $PRISTINE_OPTIONS"
        ;;
        query)
            completions="$COMMON_OPTIONS $QUERY_OPTIONS"
        ;;
        rdoc)
            completions="$COMMON_OPTIONS $RDOC_OPTIONS"
        ;;
        search)
            completions="$COMMON_OPTIONS $SEARCH_OPTIONS"
        ;;
        server)
            completions="$COMMON_OPTIONS $SERVER_OPTIONS"
        ;;
        sources)
            completions="$COMMON_OPTIONS $SOURCES_OPTIONS"
        ;;
        specification)
            completions="$COMMON_OPTIONS $SPECIFICATION_OPTIONS"
        ;;
        uninstall)
            completions="$COMMON_OPTIONS $UNINSTALL_OPTIONS"
        ;;
        unpack)
            completions="$COMMON_OPTIONS $UNPACK_OPTIONS"
        ;;
        update)
            completions="$COMMON_OPTIONS $UPDATE_OPTIONS"
        ;;
        which)
            completions="$COMMON_OPTIONS $WHICH_OPTIONS"
        ;;
        *)
            completions="$COMMANDS $GEM_OPTIONS"
        ;;
    esac;
    COMPREPLY=($( compgen -W "$completions" -- $cur ));
    return 0
}
function _get_comp_words_by_ref() 
{ 
    local exclude flag i OPTIND=1;
    local cur cword words=();
    local upargs=() upvars=() vcur vcword vprev vwords;
    while getopts "c:i:n:p:w:" flag "$@"; do
        case $flag in 
            c)
                vcur=$OPTARG
            ;;
            i)
                vcword=$OPTARG
            ;;
            n)
                exclude=$OPTARG
            ;;
            p)
                vprev=$OPTARG
            ;;
            w)
                vwords=$OPTARG
            ;;
        esac;
    done;
    while [[ $# -ge $OPTIND ]]; do
        case ${!OPTIND} in 
            cur)
                vcur=cur
            ;;
            prev)
                vprev=prev
            ;;
            cword)
                vcword=cword
            ;;
            words)
                vwords=words
            ;;
            *)
                echo "bash: $FUNCNAME(): \`${!OPTIND}': unknown argument" 1>&2;
                return 1
            ;;
        esac;
        let "OPTIND += 1";
    done;
    __get_cword_at_cursor_by_ref "$exclude" words cword cur;
    [[ -n $vcur ]] && { 
        upvars+=("$vcur");
        upargs+=(-v $vcur "$cur")
    };
    [[ -n $vcword ]] && { 
        upvars+=("$vcword");
        upargs+=(-v $vcword "$cword")
    };
    [[ -n $vprev && $cword -ge 1 ]] && { 
        upvars+=("$vprev");
        upargs+=(-v $vprev "${words[cword - 1]}")
    };
    [[ -n $vwords ]] && { 
        upvars+=("$vwords");
        upargs+=(-a${#words[@]} $vwords "${words[@]}")
    };
    (( ${#upvars[@]} )) && local "${upvars[@]}" && _upvars "${upargs[@]}"
}
function _get_cword() 
{ 
    local LC_CTYPE=C;
    local cword words;
    __reassemble_comp_words_by_ref "$1" words cword;
    if [[ -n ${2//[^0-9]/} ]]; then
        printf "%s" "${words[cword-$2]}";
    else
        if [[ "${#words[cword]}" -eq 0 || "$COMP_POINT" == "${#COMP_LINE}" ]]; then
            printf "%s" "${words[cword]}";
        else
            local i;
            local cur="$COMP_LINE";
            local index="$COMP_POINT";
            for ((i = 0; i <= cword; ++i ))
            do
                while [[ "${#cur}" -ge ${#words[i]} && "${cur:0:${#words[i]}}" != "${words[i]}" ]]; do
                    cur="${cur:1}";
                    ((index--));
                done;
                if [[ "$i" -lt "$cword" ]]; then
                    local old_size="${#cur}";
                    cur="${cur#${words[i]}}";
                    local new_size="${#cur}";
                    index=$(( index - old_size + new_size ));
                fi;
            done;
            if [[ "${words[cword]:0:${#cur}}" != "$cur" ]]; then
                printf "%s" "${words[cword]}";
            else
                printf "%s" "${cur:0:$index}";
            fi;
        fi;
    fi
}
function _get_first_arg() 
{ 
    local i;
    arg=;
    for ((i=1; i < COMP_CWORD; i++ ))
    do
        if [[ "${COMP_WORDS[i]}" != -* ]]; then
            arg=${COMP_WORDS[i]};
            break;
        fi;
    done
}
function _get_pword() 
{ 
    if [[ $COMP_CWORD -ge 1 ]]; then
        _get_cword "${@:-}" 1;
    fi
}
function _gids() 
{ 
    if type getent &> /dev/null; then
        COMPREPLY=($( compgen -W '$( getent group | cut -d: -f3 )'             -- "$cur" ));
    else
        if type perl &> /dev/null; then
            COMPREPLY=($( compgen -W '$( perl -e '"'"'while (($gid) = (getgrent)[2]) { print $gid . "\n" }'"'"' )' -- "$cur" ));
        else
            COMPREPLY=($( compgen -W '$( cut -d: -f3 /etc/group )' -- "$cur" ));
        fi;
    fi
}
function _git() 
{ 
    local i c=1 command __git_dir;
    while [ $c -lt $COMP_CWORD ]; do
        i="${COMP_WORDS[c]}";
        case "$i" in 
            --git-dir=*)
                __git_dir="${i#--git-dir=}"
            ;;
            --bare)
                __git_dir="."
            ;;
            --version | -p | --paginate)

            ;;
            --help)
                command="help";
                break
            ;;
            *)
                command="$i";
                break
            ;;
        esac;
        c=$((++c));
    done;
    if [ -z "$command" ]; then
        case "${COMP_WORDS[COMP_CWORD]}" in 
            --*)
                __gitcomp "
				--paginate
				--no-pager
				--git-dir=
				--bare
				--version
				--exec-path
				--html-path
				--work-tree=
				--help
				"
            ;;
            *)
                __git_compute_porcelain_commands;
                __gitcomp "$__git_porcelain_commands $(__git_aliases)"
            ;;
        esac;
        return;
    fi;
    local completion_func="_git_${command//-/_}";
    declare -F $completion_func > /dev/null && $completion_func && return;
    local expansion=$(__git_aliased_command "$command");
    if [ -n "$expansion" ]; then
        completion_func="_git_${expansion//-/_}";
        declare -F $completion_func > /dev/null && $completion_func;
    fi
}
function _git_add() 
{ 
    __git_has_doubledash && return;
    local cur="${COMP_WORDS[COMP_CWORD]}";
    case "$cur" in 
        --*)
            __gitcomp "
				--interactive --refresh --patch --update --dry-run
				--ignore-errors --intent-to-add
				";
            return
        ;;
    esac;
    COMPREPLY=()
}
function _git_am() 
{ 
    local cur="${COMP_WORDS[COMP_CWORD]}" dir="$(__gitdir)";
    if [ -d "$dir"/rebase-apply ]; then
        __gitcomp "--skip --continue --resolved --abort";
        return;
    fi;
    case "$cur" in 
        --whitespace=*)
            __gitcomp "$__git_whitespacelist" "" "${cur##--whitespace=}";
            return
        ;;
        --*)
            __gitcomp "
				--3way --committer-date-is-author-date --ignore-date
				--ignore-whitespace --ignore-space-change
				--interactive --keep --no-utf8 --signoff --utf8
				--whitespace= --scissors
				";
            return
        ;;
    esac;
    COMPREPLY=()
}
function _git_apply() 
{ 
    local cur="${COMP_WORDS[COMP_CWORD]}";
    case "$cur" in 
        --whitespace=*)
            __gitcomp "$__git_whitespacelist" "" "${cur##--whitespace=}";
            return
        ;;
        --*)
            __gitcomp "
				--stat --numstat --summary --check --index
				--cached --index-info --reverse --reject --unidiff-zero
				--apply --no-add --exclude=
				--ignore-whitespace --ignore-space-change
				--whitespace= --inaccurate-eof --verbose
				";
            return
        ;;
    esac;
    COMPREPLY=()
}
function _git_apply_color() 
{ 
    local output="$1" color="$2" default="$3";
    if _git_color_enabled; then
        color=`_git_color "$color" "$default"`;
        echo -ne "${color}${output}${ANSI_RESET}";
    else
        echo -ne "$output";
    fi
}
function _git_archive() 
{ 
    local cur="${COMP_WORDS[COMP_CWORD]}";
    case "$cur" in 
        --format=*)
            __gitcomp "$(git archive --list)" "" "${cur##--format=}";
            return
        ;;
        --remote=*)
            __gitcomp "$(__git_remotes)" "" "${cur##--remote=}";
            return
        ;;
        --*)
            __gitcomp "
				--format= --list --verbose
				--prefix= --remote= --exec=
				";
            return
        ;;
    esac;
    __git_complete_file
}
function _git_bisect() 
{ 
    __git_has_doubledash && return;
    local subcommands="start bad good skip reset visualize replay log run";
    local subcommand="$(__git_find_on_cmdline "$subcommands")";
    if [ -z "$subcommand" ]; then
        __gitcomp "$subcommands";
        return;
    fi;
    case "$subcommand" in 
        bad | good | reset | skip)
            __gitcomp "$(__git_refs)"
        ;;
        *)
            COMPREPLY=()
        ;;
    esac
}
function _git_branch() 
{ 
    local i c=1 only_local_ref="n" has_r="n";
    while [ $c -lt $COMP_CWORD ]; do
        i="${COMP_WORDS[c]}";
        case "$i" in 
            -d | -m)
                only_local_ref="y"
            ;;
            -r)
                has_r="y"
            ;;
        esac;
        c=$((++c));
    done;
    case "${COMP_WORDS[COMP_CWORD]}" in 
        --*)
            __gitcomp "
				--color --no-color --verbose --abbrev= --no-abbrev
				--track --no-track --contains --merged --no-merged
				--set-upstream
				"
        ;;
        *)
            if [ $only_local_ref = "y" -a $has_r = "n" ]; then
                __gitcomp "$(__git_heads)";
            else
                __gitcomp "$(__git_refs)";
            fi
        ;;
    esac
}
function _git_bundle() 
{ 
    local cmd="${COMP_WORDS[1]}";
    case "${COMP_WORDS[COMP_CWORD-1]}" in 
        bundle)
            __gitcomp "create list-heads verify unbundle"
        ;;
        create)
            __git_complete_revlist
        ;;
        list-heads | verify | unbundle | *)

        ;;
    esac
}
function _git_checkout() 
{ 
    __git_has_doubledash && return;
    local cur="${COMP_WORDS[COMP_CWORD]}";
    case "$cur" in 
        --conflict=*)
            __gitcomp "diff3 merge" "" "${cur##--conflict=}"
        ;;
        --*)
            __gitcomp "
				--quiet --ours --theirs --track --no-track --merge
				--conflict= --orphan --patch
				"
        ;;
        *)
            __gitcomp "$(__git_refs)"
        ;;
    esac
}
function _git_cherry() 
{ 
    __gitcomp "$(__git_refs)"
}
function _git_cherry_pick() 
{ 
    local cur="${COMP_WORDS[COMP_CWORD]}";
    case "$cur" in 
        --*)
            __gitcomp "--edit --no-commit"
        ;;
        *)
            __gitcomp "$(__git_refs)"
        ;;
    esac
}
function _git_clean() 
{ 
    __git_has_doubledash && return;
    local cur="${COMP_WORDS[COMP_CWORD]}";
    case "$cur" in 
        --*)
            __gitcomp "--dry-run --quiet";
            return
        ;;
    esac;
    COMPREPLY=()
}
function _git_clone() 
{ 
    local cur="${COMP_WORDS[COMP_CWORD]}";
    case "$cur" in 
        --*)
            __gitcomp "
				--local
				--no-hardlinks
				--shared
				--reference
				--quiet
				--no-checkout
				--bare
				--mirror
				--origin
				--upload-pack
				--template=
				--depth
				";
            return
        ;;
    esac;
    COMPREPLY=()
}
function _git_color() 
{ 
    local color;
    color=`git config --get-color "$1" "$2" 2>/dev/null`;
    [ -n "$color" ] && echo -ne "\001$color\002"
}
function _git_color_enabled() 
{ 
    [ `git config --get-colorbool color.sh true` = "true" ]
}
function _git_commit() 
{ 
    __git_has_doubledash && return;
    local cur="${COMP_WORDS[COMP_CWORD]}";
    case "$cur" in 
        --cleanup=*)
            __gitcomp "default strip verbatim whitespace
				" "" "${cur##--cleanup=}";
            return
        ;;
        --reuse-message=*)
            __gitcomp "$(__git_refs)" "" "${cur##--reuse-message=}";
            return
        ;;
        --reedit-message=*)
            __gitcomp "$(__git_refs)" "" "${cur##--reedit-message=}";
            return
        ;;
        --untracked-files=*)
            __gitcomp "all no normal" "" "${cur##--untracked-files=}";
            return
        ;;
        --*)
            __gitcomp "
				--all --author= --signoff --verify --no-verify
				--edit --amend --include --only --interactive
				--dry-run --reuse-message= --reedit-message=
				--reset-author --file= --message= --template=
				--cleanup= --untracked-files --untracked-files=
				--verbose --quiet
				";
            return
        ;;
    esac;
    COMPREPLY=()
}
function _git_config() 
{ 
    local cur="${COMP_WORDS[COMP_CWORD]}";
    local prv="${COMP_WORDS[COMP_CWORD-1]}";
    case "$prv" in 
        branch.*.remote)
            __gitcomp "$(__git_remotes)";
            return
        ;;
        branch.*.merge)
            __gitcomp "$(__git_refs)";
            return
        ;;
        remote.*.fetch)
            local remote="${prv#remote.}";
            remote="${remote%.fetch}";
            __gitcomp "$(__git_refs_remotes "$remote")";
            return
        ;;
        remote.*.push)
            local remote="${prv#remote.}";
            remote="${remote%.push}";
            __gitcomp "$(git --git-dir="$(__gitdir)" for-each-ref --format='%(refname):%(refname)' refs/heads)";
            return
        ;;
        pull.twohead | pull.octopus)
            __git_compute_merge_strategies;
            __gitcomp "$__git_merge_strategies";
            return
        ;;
        color.branch | color.diff | color.interactive | color.showbranch | color.status | color.ui)
            __gitcomp "always never auto";
            return
        ;;
        color.pager)
            __gitcomp "false true";
            return
        ;;
        color.*.*)
            __gitcomp "
				normal black red green yellow blue magenta cyan white
				bold dim ul blink reverse
				";
            return
        ;;
        help.format)
            __gitcomp "man info web html";
            return
        ;;
        log.date)
            __gitcomp "$__git_log_date_formats";
            return
        ;;
        sendemail.aliasesfiletype)
            __gitcomp "mutt mailrc pine elm gnus";
            return
        ;;
        sendemail.confirm)
            __gitcomp "$__git_send_email_confirm_options";
            return
        ;;
        sendemail.suppresscc)
            __gitcomp "$__git_send_email_suppresscc_options";
            return
        ;;
        --get | --get-all | --unset | --unset-all)
            __gitcomp "$(__git_config_get_set_variables)";
            return
        ;;
        *.*)
            COMPREPLY=();
            return
        ;;
    esac;
    case "$cur" in 
        --*)
            __gitcomp "
				--global --system --file=
				--list --replace-all
				--get --get-all --get-regexp
				--add --unset --unset-all
				--remove-section --rename-section
				";
            return
        ;;
        branch.*.*)
            local pfx="${cur%.*}.";
            cur="${cur##*.}";
            __gitcomp "remote merge mergeoptions rebase" "$pfx" "$cur";
            return
        ;;
        branch.*)
            local pfx="${cur%.*}.";
            cur="${cur#*.}";
            __gitcomp "$(__git_heads)" "$pfx" "$cur" ".";
            return
        ;;
        guitool.*.*)
            local pfx="${cur%.*}.";
            cur="${cur##*.}";
            __gitcomp "
				argprompt cmd confirm needsfile noconsole norescan
				prompt revprompt revunmerged title
				" "$pfx" "$cur";
            return
        ;;
        difftool.*.*)
            local pfx="${cur%.*}.";
            cur="${cur##*.}";
            __gitcomp "cmd path" "$pfx" "$cur";
            return
        ;;
        man.*.*)
            local pfx="${cur%.*}.";
            cur="${cur##*.}";
            __gitcomp "cmd path" "$pfx" "$cur";
            return
        ;;
        mergetool.*.*)
            local pfx="${cur%.*}.";
            cur="${cur##*.}";
            __gitcomp "cmd path trustExitCode" "$pfx" "$cur";
            return
        ;;
        pager.*)
            local pfx="${cur%.*}.";
            cur="${cur#*.}";
            __git_compute_all_commands;
            __gitcomp "$__git_all_commands" "$pfx" "$cur";
            return
        ;;
        remote.*.*)
            local pfx="${cur%.*}.";
            cur="${cur##*.}";
            __gitcomp "
				url proxy fetch push mirror skipDefaultUpdate
				receivepack uploadpack tagopt pushurl
				" "$pfx" "$cur";
            return
        ;;
        remote.*)
            local pfx="${cur%.*}.";
            cur="${cur#*.}";
            __gitcomp "$(__git_remotes)" "$pfx" "$cur" ".";
            return
        ;;
        url.*.*)
            local pfx="${cur%.*}.";
            cur="${cur##*.}";
            __gitcomp "insteadOf pushInsteadOf" "$pfx" "$cur";
            return
        ;;
    esac;
    __gitcomp "
			add.ignore-errors
			alias.
			apply.ignorewhitespace
			apply.whitespace
			branch.autosetupmerge
			branch.autosetuprebase
			clean.requireForce
			color.branch
			color.branch.current
			color.branch.local
			color.branch.plain
			color.branch.remote
			color.diff
			color.diff.commit
			color.diff.frag
			color.diff.meta
			color.diff.new
			color.diff.old
			color.diff.plain
			color.diff.whitespace
			color.grep
			color.grep.external
			color.grep.match
			color.interactive
			color.interactive.header
			color.interactive.help
			color.interactive.prompt
			color.pager
			color.showbranch
			color.status
			color.status.added
			color.status.changed
			color.status.header
			color.status.nobranch
			color.status.untracked
			color.status.updated
			color.ui
			commit.template
			core.autocrlf
			core.bare
			core.compression
			core.createObject
			core.deltaBaseCacheLimit
			core.editor
			core.excludesfile
			core.fileMode
			core.fsyncobjectfiles
			core.gitProxy
			core.ignoreCygwinFSTricks
			core.ignoreStat
			core.logAllRefUpdates
			core.loosecompression
			core.packedGitLimit
			core.packedGitWindowSize
			core.pager
			core.preferSymlinkRefs
			core.preloadindex
			core.quotepath
			core.repositoryFormatVersion
			core.safecrlf
			core.sharedRepository
			core.symlinks
			core.trustctime
			core.warnAmbiguousRefs
			core.whitespace
			core.worktree
			diff.autorefreshindex
			diff.external
			diff.mnemonicprefix
			diff.renameLimit
			diff.renameLimit.
			diff.renames
			diff.suppressBlankEmpty
			diff.tool
			diff.wordRegex
			difftool.
			difftool.prompt
			fetch.unpackLimit
			format.attach
			format.cc
			format.headers
			format.numbered
			format.pretty
			format.signature
			format.signoff
			format.subjectprefix
			format.suffix
			format.thread
			gc.aggressiveWindow
			gc.auto
			gc.autopacklimit
			gc.packrefs
			gc.pruneexpire
			gc.reflogexpire
			gc.reflogexpireunreachable
			gc.rerereresolved
			gc.rerereunresolved
			gitcvs.allbinary
			gitcvs.commitmsgannotation
			gitcvs.dbTableNamePrefix
			gitcvs.dbdriver
			gitcvs.dbname
			gitcvs.dbpass
			gitcvs.dbuser
			gitcvs.enabled
			gitcvs.logfile
			gitcvs.usecrlfattr
			guitool.
			gui.blamehistoryctx
			gui.commitmsgwidth
			gui.copyblamethreshold
			gui.diffcontext
			gui.encoding
			gui.fastcopyblame
			gui.matchtrackingbranch
			gui.newbranchtemplate
			gui.pruneduringfetch
			gui.spellingdictionary
			gui.trustmtime
			help.autocorrect
			help.browser
			help.format
			http.lowSpeedLimit
			http.lowSpeedTime
			http.maxRequests
			http.noEPSV
			http.proxy
			http.sslCAInfo
			http.sslCAPath
			http.sslCert
			http.sslKey
			http.sslVerify
			i18n.commitEncoding
			i18n.logOutputEncoding
			imap.folder
			imap.host
			imap.pass
			imap.port
			imap.preformattedHTML
			imap.sslverify
			imap.tunnel
			imap.user
			instaweb.browser
			instaweb.httpd
			instaweb.local
			instaweb.modulepath
			instaweb.port
			interactive.singlekey
			log.date
			log.showroot
			mailmap.file
			man.
			man.viewer
			merge.conflictstyle
			merge.log
			merge.renameLimit
			merge.stat
			merge.tool
			merge.verbosity
			mergetool.
			mergetool.keepBackup
			mergetool.prompt
			pack.compression
			pack.deltaCacheLimit
			pack.deltaCacheSize
			pack.depth
			pack.indexVersion
			pack.packSizeLimit
			pack.threads
			pack.window
			pack.windowMemory
			pager.
			pull.octopus
			pull.twohead
			push.default
			rebase.stat
			receive.denyCurrentBranch
			receive.denyDeletes
			receive.denyNonFastForwards
			receive.fsckObjects
			receive.unpackLimit
			repack.usedeltabaseoffset
			rerere.autoupdate
			rerere.enabled
			sendemail.aliasesfile
			sendemail.aliasesfiletype
			sendemail.bcc
			sendemail.cc
			sendemail.cccmd
			sendemail.chainreplyto
			sendemail.confirm
			sendemail.envelopesender
			sendemail.multiedit
			sendemail.signedoffbycc
			sendemail.smtpencryption
			sendemail.smtppass
			sendemail.smtpserver
			sendemail.smtpserverport
			sendemail.smtpuser
			sendemail.suppresscc
			sendemail.suppressfrom
			sendemail.thread
			sendemail.to
			sendemail.validate
			showbranch.default
			status.relativePaths
			status.showUntrackedFiles
			tar.umask
			transfer.unpackLimit
			url.
			user.email
			user.name
			user.signingkey
			web.browser
			branch. remote.
		"
}
function _git_describe() 
{ 
    local cur="${COMP_WORDS[COMP_CWORD]}";
    case "$cur" in 
        --*)
            __gitcomp "
				--all --tags --contains --abbrev= --candidates=
				--exact-match --debug --long --match --always
				";
            return
        ;;
    esac;
    __gitcomp "$(__git_refs)"
}
function _git_diff() 
{ 
    __git_has_doubledash && return;
    local cur="${COMP_WORDS[COMP_CWORD]}";
    case "$cur" in 
        --*)
            __gitcomp "--cached --staged --pickaxe-all --pickaxe-regex
				--base --ours --theirs
				$__git_diff_common_options
				";
            return
        ;;
    esac;
    __git_complete_file
}
function _git_difftool() 
{ 
    __git_has_doubledash && return;
    local cur="${COMP_WORDS[COMP_CWORD]}";
    case "$cur" in 
        --tool=*)
            __gitcomp "$__git_mergetools_common kompare" "" "${cur##--tool=}";
            return
        ;;
        --*)
            __gitcomp "--cached --staged --pickaxe-all --pickaxe-regex
				--base --ours --theirs
				--no-renames --diff-filter= --find-copies-harder
				--relative --ignore-submodules
				--tool=";
            return
        ;;
    esac;
    __git_complete_file
}
function _git_dirty() 
{ 
    if git status 2> /dev/null | fgrep --color=auto -q '(working directory clean)'; then
        return 0;
    fi;
    local dirty_marker="`git config gitsh.dirty || echo ' *'`";
    _git_apply_color "$dirty_marker" "color.sh.dirty" "red"
}
function _git_fetch() 
{ 
    local cur="${COMP_WORDS[COMP_CWORD]}";
    case "$cur" in 
        --*)
            __gitcomp "$__git_fetch_options";
            return
        ;;
    esac;
    __git_complete_remote_or_refspec
}
function _git_format_patch() 
{ 
    local cur="${COMP_WORDS[COMP_CWORD]}";
    case "$cur" in 
        --thread=*)
            __gitcomp "
				deep shallow
				" "" "${cur##--thread=}";
            return
        ;;
        --*)
            __gitcomp "
				--stdout --attach --no-attach --thread --thread=
				--output-directory
				--numbered --start-number
				--numbered-files
				--keep-subject
				--signoff --signature --no-signature
				--in-reply-to= --cc=
				--full-index --binary
				--not --all
				--cover-letter
				--no-prefix --src-prefix= --dst-prefix=
				--inline --suffix= --ignore-if-in-upstream
				--subject-prefix=
				";
            return
        ;;
    esac;
    __git_complete_revlist
}
function _git_fsck() 
{ 
    local cur="${COMP_WORDS[COMP_CWORD]}";
    case "$cur" in 
        --*)
            __gitcomp "
				--tags --root --unreachable --cache --no-reflogs --full
				--strict --verbose --lost-found
				";
            return
        ;;
    esac;
    COMPREPLY=()
}
function _git_gc() 
{ 
    local cur="${COMP_WORDS[COMP_CWORD]}";
    case "$cur" in 
        --*)
            __gitcomp "--prune --aggressive";
            return
        ;;
    esac;
    COMPREPLY=()
}
function _git_gitk() 
{ 
    _gitk
}
function _git_grep() 
{ 
    __git_has_doubledash && return;
    local cur="${COMP_WORDS[COMP_CWORD]}";
    case "$cur" in 
        --*)
            __gitcomp "
				--cached
				--text --ignore-case --word-regexp --invert-match
				--full-name
				--extended-regexp --basic-regexp --fixed-strings
				--files-with-matches --name-only
				--files-without-match
				--max-depth
				--count
				--and --or --not --all-match
				";
            return
        ;;
    esac;
    __gitcomp "$(__git_refs)"
}
function _git_headname() 
{ 
    local br=`git symbolic-ref -q HEAD 2>/dev/null`;
    [ -n "$br" ] && br=${br#refs/heads/} || br=`git rev-parse --short HEAD 2>/dev/null`;
    _git_apply_color "$br" "color.sh.branch" "yellow reverse"
}
function _git_help() 
{ 
    local cur="${COMP_WORDS[COMP_CWORD]}";
    case "$cur" in 
        --*)
            __gitcomp "--all --info --man --web";
            return
        ;;
    esac;
    __git_compute_all_commands;
    __gitcomp "$__git_all_commands
			attributes cli core-tutorial cvs-migration
			diffcore gitk glossary hooks ignore modules
			repository-layout tutorial tutorial-2
			workflows
			"
}
function _git_import_aliases() 
{ 
    eval "$(
			git config --get-regexp 'alias\..*' |
			sed 's/^alias\.//'                  |
			while read key command
			do
				if expr -- "$command" : '!' >/dev/null
				then echo "alias $key='git $key'"
				else echo "gitalias $key=\"git $command\""
				fi
			done
		)"
}
function _git_init() 
{ 
    local cur="${COMP_WORDS[COMP_CWORD]}";
    case "$cur" in 
        --shared=*)
            __gitcomp "
				false true umask group all world everybody
				" "" "${cur##--shared=}";
            return
        ;;
        --*)
            __gitcomp "--quiet --bare --template= --shared --shared=";
            return
        ;;
    esac;
    COMPREPLY=()
}
function _git_log() 
{ 
    __git_has_doubledash && return;
    local cur="${COMP_WORDS[COMP_CWORD]}";
    local g="$(git rev-parse --git-dir 2>/dev/null)";
    local merge="";
    if [ -f "$g/MERGE_HEAD" ]; then
        merge="--merge";
    fi;
    case "$cur" in 
        --pretty=*)
            __gitcomp "$__git_log_pretty_formats
				" "" "${cur##--pretty=}";
            return
        ;;
        --format=*)
            __gitcomp "$__git_log_pretty_formats
				" "" "${cur##--format=}";
            return
        ;;
        --date=*)
            __gitcomp "$__git_log_date_formats" "" "${cur##--date=}";
            return
        ;;
        --decorate=*)
            __gitcomp "long short" "" "${cur##--decorate=}";
            return
        ;;
        --*)
            __gitcomp "
				$__git_log_common_options
				$__git_log_shortlog_options
				$__git_log_gitk_options
				--root --topo-order --date-order --reverse
				--follow --full-diff
				--abbrev-commit --abbrev=
				--relative-date --date=
				--pretty= --format= --oneline
				--cherry-pick
				--graph
				--decorate --decorate=
				--walk-reflogs
				--parents --children
				$merge
				$__git_diff_common_options
				--pickaxe-all --pickaxe-regex
				";
            return
        ;;
    esac;
    __git_complete_revlist
}
function _git_ls_files() 
{ 
    __git_has_doubledash && return;
    local cur="${COMP_WORDS[COMP_CWORD]}";
    case "$cur" in 
        --*)
            __gitcomp "--cached --deleted --modified --others --ignored
				--stage --directory --no-empty-directory --unmerged
				--killed --exclude= --exclude-from=
				--exclude-per-directory= --exclude-standard
				--error-unmatch --with-tree= --full-name
				--abbrev --ignored --exclude-per-directory
				";
            return
        ;;
    esac;
    COMPREPLY=()
}
function _git_ls_remote() 
{ 
    __gitcomp "$(__git_remotes)"
}
function _git_ls_tree() 
{ 
    __git_complete_file
}
function _git_merge() 
{ 
    __git_complete_strategy && return;
    local cur="${COMP_WORDS[COMP_CWORD]}";
    case "$cur" in 
        --*)
            __gitcomp "$__git_merge_options";
            return
        ;;
    esac;
    __gitcomp "$(__git_refs)"
}
function _git_merge_base() 
{ 
    __gitcomp "$(__git_refs)"
}
function _git_mergetool() 
{ 
    local cur="${COMP_WORDS[COMP_CWORD]}";
    case "$cur" in 
        --tool=*)
            __gitcomp "$__git_mergetools_common tortoisemerge" "" "${cur##--tool=}";
            return
        ;;
        --*)
            __gitcomp "--tool=";
            return
        ;;
    esac;
    COMPREPLY=()
}
function _git_mv() 
{ 
    local cur="${COMP_WORDS[COMP_CWORD]}";
    case "$cur" in 
        --*)
            __gitcomp "--dry-run";
            return
        ;;
    esac;
    COMPREPLY=()
}
function _git_name_rev() 
{ 
    __gitcomp "--tags --all --stdin"
}
function _git_notes() 
{ 
    local subcommands="edit show";
    if [ -z "$(__git_find_on_cmdline "$subcommands")" ]; then
        __gitcomp "$subcommands";
        return;
    fi;
    case "${COMP_WORDS[COMP_CWORD-1]}" in 
        -m | -F)
            COMPREPLY=()
        ;;
        *)
            __gitcomp "$(__git_refs)"
        ;;
    esac
}
function _git_pull() 
{ 
    __git_complete_strategy && return;
    local cur="${COMP_WORDS[COMP_CWORD]}";
    case "$cur" in 
        --*)
            __gitcomp "
				--rebase --no-rebase
				$__git_merge_options
				$__git_fetch_options
			";
            return
        ;;
    esac;
    __git_complete_remote_or_refspec
}
function _git_push() 
{ 
    local cur="${COMP_WORDS[COMP_CWORD]}";
    case "${COMP_WORDS[COMP_CWORD-1]}" in 
        --repo)
            __gitcomp "$(__git_remotes)";
            return
        ;;
    esac;
    case "$cur" in 
        --repo=*)
            __gitcomp "$(__git_remotes)" "" "${cur##--repo=}";
            return
        ;;
        --*)
            __gitcomp "
				--all --mirror --tags --dry-run --force --verbose
				--receive-pack= --repo=
			";
            return
        ;;
    esac;
    __git_complete_remote_or_refspec
}
function _git_rebase() 
{ 
    local cur="${COMP_WORDS[COMP_CWORD]}" dir="$(__gitdir)";
    if [ -d "$dir"/rebase-apply ] || [ -d "$dir"/rebase-merge ]; then
        __gitcomp "--continue --skip --abort";
        return;
    fi;
    __git_complete_strategy && return;
    case "$cur" in 
        --whitespace=*)
            __gitcomp "$__git_whitespacelist" "" "${cur##--whitespace=}";
            return
        ;;
        --*)
            __gitcomp "
				--onto --merge --strategy --interactive
				--preserve-merges --stat --no-stat
				--committer-date-is-author-date --ignore-date
				--ignore-whitespace --whitespace=
				--autosquash
				";
            return
        ;;
    esac;
    __gitcomp "$(__git_refs)"
}
function _git_remote() 
{ 
    local subcommands="add rename rm show prune update set-head";
    local subcommand="$(__git_find_on_cmdline "$subcommands")";
    if [ -z "$subcommand" ]; then
        __gitcomp "$subcommands";
        return;
    fi;
    case "$subcommand" in 
        rename | rm | show | prune)
            __gitcomp "$(__git_remotes)"
        ;;
        update)
            local i c='' IFS='
';
            for i in $(git --git-dir="$(__gitdir)" config --get-regexp "remotes\..*" 2>/dev/null);
            do
                i="${i#remotes.}";
                c="$c ${i/ */}";
            done;
            __gitcomp "$c"
        ;;
        *)
            COMPREPLY=()
        ;;
    esac
}
function _git_replace() 
{ 
    __gitcomp "$(__git_refs)"
}
function _git_reset() 
{ 
    __git_has_doubledash && return;
    local cur="${COMP_WORDS[COMP_CWORD]}";
    case "$cur" in 
        --*)
            __gitcomp "--merge --mixed --hard --soft --patch";
            return
        ;;
    esac;
    __gitcomp "$(__git_refs)"
}
function _git_revert() 
{ 
    local cur="${COMP_WORDS[COMP_CWORD]}";
    case "$cur" in 
        --*)
            __gitcomp "--edit --mainline --no-edit --no-commit --signoff";
            return
        ;;
    esac;
    __gitcomp "$(__git_refs)"
}
function _git_rm() 
{ 
    __git_has_doubledash && return;
    local cur="${COMP_WORDS[COMP_CWORD]}";
    case "$cur" in 
        --*)
            __gitcomp "--cached --dry-run --ignore-unmatch --quiet";
            return
        ;;
    esac;
    COMPREPLY=()
}
function _git_send_email() 
{ 
    local cur="${COMP_WORDS[COMP_CWORD]}";
    case "$cur" in 
        --confirm=*)
            __gitcomp "
				$__git_send_email_confirm_options
				" "" "${cur##--confirm=}";
            return
        ;;
        --suppress-cc=*)
            __gitcomp "
				$__git_send_email_suppresscc_options
				" "" "${cur##--suppress-cc=}";
            return
        ;;
        --smtp-encryption=*)
            __gitcomp "ssl tls" "" "${cur##--smtp-encryption=}";
            return
        ;;
        --*)
            __gitcomp "--annotate --bcc --cc --cc-cmd --chain-reply-to
				--compose --confirm= --dry-run --envelope-sender
				--from --identity
				--in-reply-to --no-chain-reply-to --no-signed-off-by-cc
				--no-suppress-from --no-thread --quiet
				--signed-off-by-cc --smtp-pass --smtp-server
				--smtp-server-port --smtp-encryption= --smtp-user
				--subject --suppress-cc= --suppress-from --thread --to
				--validate --no-validate";
            return
        ;;
    esac;
    COMPREPLY=()
}
function _git_shortlog() 
{ 
    __git_has_doubledash && return;
    local cur="${COMP_WORDS[COMP_CWORD]}";
    case "$cur" in 
        --*)
            __gitcomp "
				$__git_log_common_options
				$__git_log_shortlog_options
				--numbered --summary
				";
            return
        ;;
    esac;
    __git_complete_revlist
}
function _git_show() 
{ 
    __git_has_doubledash && return;
    local cur="${COMP_WORDS[COMP_CWORD]}";
    case "$cur" in 
        --pretty=*)
            __gitcomp "$__git_log_pretty_formats
				" "" "${cur##--pretty=}";
            return
        ;;
        --format=*)
            __gitcomp "$__git_log_pretty_formats
				" "" "${cur##--format=}";
            return
        ;;
        --*)
            __gitcomp "--pretty= --format= --abbrev-commit --oneline
				$__git_diff_common_options
				";
            return
        ;;
    esac;
    __git_complete_file
}
function _git_show_branch() 
{ 
    local cur="${COMP_WORDS[COMP_CWORD]}";
    case "$cur" in 
        --*)
            __gitcomp "
				--all --remotes --topo-order --current --more=
				--list --independent --merge-base --no-name
				--color --no-color
				--sha1-name --sparse --topics --reflog
				";
            return
        ;;
    esac;
    __git_complete_revlist
}
function _git_stage() 
{ 
    _git_add
}
function _git_stash() 
{ 
    local cur="${COMP_WORDS[COMP_CWORD]}";
    local save_opts='--keep-index --no-keep-index --quiet --patch';
    local subcommands='save list show apply clear drop pop create branch';
    local subcommand="$(__git_find_on_cmdline "$subcommands")";
    if [ -z "$subcommand" ]; then
        case "$cur" in 
            --*)
                __gitcomp "$save_opts"
            ;;
            *)
                if [ -z "$(__git_find_on_cmdline "$save_opts")" ]; then
                    __gitcomp "$subcommands";
                else
                    COMPREPLY=();
                fi
            ;;
        esac;
    else
        case "$subcommand,$cur" in 
            save,--*)
                __gitcomp "$save_opts"
            ;;
            apply,--* | pop,--*)
                __gitcomp "--index --quiet"
            ;;
            show,--* | drop,--* | branch,--*)
                COMPREPLY=()
            ;;
            show,* | apply,* | drop,* | pop,* | branch,*)
                __gitcomp "$(git --git-dir="$(__gitdir)" stash list 						| sed -n -e 's/:.*//p')"
            ;;
            *)
                COMPREPLY=()
            ;;
        esac;
    fi
}
function _git_submodule() 
{ 
    __git_has_doubledash && return;
    local subcommands="add status init update summary foreach sync";
    if [ -z "$(__git_find_on_cmdline "$subcommands")" ]; then
        local cur="${COMP_WORDS[COMP_CWORD]}";
        case "$cur" in 
            --*)
                __gitcomp "--quiet --cached"
            ;;
            *)
                __gitcomp "$subcommands"
            ;;
        esac;
        return;
    fi
}
function _git_svn() 
{ 
    local subcommands="
			init fetch clone rebase dcommit log find-rev
			set-tree commit-diff info create-ignore propget
			proplist show-ignore show-externals branch tag blame
			migrate mkdirs reset gc
			";
    local subcommand="$(__git_find_on_cmdline "$subcommands")";
    if [ -z "$subcommand" ]; then
        __gitcomp "$subcommands";
    else
        local remote_opts="--username= --config-dir= --no-auth-cache";
        local fc_opts="
				--follow-parent --authors-file= --repack=
				--no-metadata --use-svm-props --use-svnsync-props
				--log-window-size= --no-checkout --quiet
				--repack-flags --use-log-author --localtime
				--ignore-paths= $remote_opts
				";
        local init_opts="
				--template= --shared= --trunk= --tags=
				--branches= --stdlayout --minimize-url
				--no-metadata --use-svm-props --use-svnsync-props
				--rewrite-root= --prefix= --use-log-author
				--add-author-from $remote_opts
				";
        local cmt_opts="
				--edit --rmdir --find-copies-harder --copy-similarity=
				";
        local cur="${COMP_WORDS[COMP_CWORD]}";
        case "$subcommand,$cur" in 
            fetch,--*)
                __gitcomp "--revision= --fetch-all $fc_opts"
            ;;
            clone,--*)
                __gitcomp "--revision= $fc_opts $init_opts"
            ;;
            init,--*)
                __gitcomp "$init_opts"
            ;;
            dcommit,--*)
                __gitcomp "
					--merge --strategy= --verbose --dry-run
					--fetch-all --no-rebase --commit-url
					--revision $cmt_opts $fc_opts
					"
            ;;
            set-tree,--*)
                __gitcomp "--stdin $cmt_opts $fc_opts"
            ;;
            create-ignore,--* | propget,--* | proplist,--* | show-ignore,--* | show-externals,--* | mkdirs,--*)
                __gitcomp "--revision="
            ;;
            log,--*)
                __gitcomp "
					--limit= --revision= --verbose --incremental
					--oneline --show-commit --non-recursive
					--authors-file= --color
					"
            ;;
            rebase,--*)
                __gitcomp "
					--merge --verbose --strategy= --local
					--fetch-all --dry-run $fc_opts
					"
            ;;
            commit-diff,--*)
                __gitcomp "--message= --file= --revision= $cmt_opts"
            ;;
            info,--*)
                __gitcomp "--url"
            ;;
            branch,--*)
                __gitcomp "--dry-run --message --tag"
            ;;
            tag,--*)
                __gitcomp "--dry-run --message"
            ;;
            blame,--*)
                __gitcomp "--git-format"
            ;;
            migrate,--*)
                __gitcomp "
					--config-dir= --ignore-paths= --minimize
					--no-auth-cache --username=
					"
            ;;
            reset,--*)
                __gitcomp "--revision= --parent"
            ;;
            *)
                COMPREPLY=()
            ;;
        esac;
    fi
}
function _git_tag() 
{ 
    local i c=1 f=0;
    while [ $c -lt $COMP_CWORD ]; do
        i="${COMP_WORDS[c]}";
        case "$i" in 
            -d | -v)
                __gitcomp "$(__git_tags)";
                return
            ;;
            -f)
                f=1
            ;;
        esac;
        c=$((++c));
    done;
    case "${COMP_WORDS[COMP_CWORD-1]}" in 
        -m | -F)
            COMPREPLY=()
        ;;
        -* | tag)
            if [ $f = 1 ]; then
                __gitcomp "$(__git_tags)";
            else
                COMPREPLY=();
            fi
        ;;
        *)
            __gitcomp "$(__git_refs)"
        ;;
    esac
}
function _git_whatchanged() 
{ 
    _git_log
}
function _git_workdir() 
{ 
    subdir=`git rev-parse --show-prefix 2>/dev/null`;
    subdir="${subdir%/}";
    workdir="${PWD%/$subdir}";
    _git_apply_color "${workdir/*\/}${subdir:+/$subdir}" "color.sh.workdir" "blue bold"
}
function _gitk() 
{ 
    __git_has_doubledash && return;
    local cur="${COMP_WORDS[COMP_CWORD]}";
    local g="$(__gitdir)";
    local merge="";
    if [ -f "$g/MERGE_HEAD" ]; then
        merge="--merge";
    fi;
    case "$cur" in 
        --*)
            __gitcomp "
				$__git_log_common_options
				$__git_log_gitk_options
				$merge
				";
            return
        ;;
    esac;
    __git_complete_revlist
}
function _grub_editenv() 
{ 
    local cur prev;
    COMPREPLY=();
    cur=`_get_cword`;
    prev=${COMP_WORDS[COMP_CWORD-1]};
    case "$prev" in 
        create | list | set | unset)
            COMPREPLY=("");
            return
        ;;
    esac;
    __grubcomp "$(__grub_get_options_from_help)
                create list set unset"
}
function _grub_install() 
{ 
    local cur prev last split=false;
    COMPREPLY=();
    cur=`_get_cword`;
    prev=${COMP_WORDS[COMP_CWORD-1]};
    last=$(__grub_get_last_option);
    _split_longopt && split=true;
    case "$prev" in 
        --boot-directory)
            _filedir -d;
            return
        ;;
        --disk-module)
            __grubcomp "biosdisk ata";
            return
        ;;
    esac;
    $split && return 0;
    if [[ "$cur" == -* ]]; then
        __grubcomp "$(__grub_get_options_from_help)";
    else
        case "$last" in 
            --modules)
                __grub_list_modules;
                return
            ;;
        esac;
        _filedir;
    fi
}
function _grub_mkconfig() 
{ 
    local cur prev;
    COMPREPLY=();
    cur=`_get_cword`;
    if [[ "$cur" == -* ]]; then
        __grubcomp "$(__grub_get_options_from_help)";
    else
        _filedir;
    fi
}
function _grub_mkfont() 
{ 
    local cur;
    COMPREPLY=();
    cur=`_get_cword`;
    if [[ "$cur" == -* ]]; then
        __grubcomp "$(__grub_get_options_from_help)";
    else
        _filedir;
    fi
}
function _grub_mkimage() 
{ 
    local cur prev split=false;
    COMPREPLY=();
    cur=`_get_cword`;
    prev=${COMP_WORDS[COMP_CWORD-1]};
    _split_longopt && split=true;
    case "$prev" in 
        -d | --directory | -p | --prefix)
            _filedir -d;
            return
        ;;
        -O | --format)
            local prog=${COMP_WORDS[0]};
            __grubcomp "$(LC_ALL=C $prog --help |                         awk -F ":" '/available formats/ { print $2 }' |                         sed 's/, / /g')";
            return
        ;;
    esac;
    $split && return 0;
    if [[ "$cur" == -* ]]; then
        __grubcomp "$(__grub_get_options_from_help)";
    else
        _filedir;
    fi
}
function _grub_mkpasswd_pbkdf2() 
{ 
    local cur;
    COMPREPLY=();
    cur=`_get_cword`;
    if [[ "$cur" == -* ]]; then
        __grubcomp "$(__grub_get_options_from_help)";
    else
        _filedir;
    fi
}
function _grub_mkrescue() 
{ 
    local cur prev last;
    COMPREPLY=();
    cur=`_get_cword`;
    prev=${COMP_WORDS[COMP_CWORD-1]};
    last=$(__grub_get_last_option);
    if [[ "$cur" == -* ]]; then
        __grubcomp "$(__grub_get_options_from_help)";
    else
        case "$last" in 
            --modules)
                __grub_list_modules;
                return
            ;;
        esac;
        _filedir;
    fi
}
function _grub_probe() 
{ 
    local cur prev split=false;
    COMPREPLY=();
    cur=`_get_cword`;
    prev=${COMP_WORDS[COMP_CWORD-1]};
    _split_longopt && split=true;
    case "$prev" in 
        -t | --target)
            local prog=${COMP_WORDS[0]};
            __grubcomp "$(LC_ALL=C $prog --help |                         awk -F "[()]" '/--target=/ { print $2 }' |                         sed 's/|/ /g')";
            return
        ;;
    esac;
    $split && return 0;
    if [[ "$cur" == -* ]]; then
        __grubcomp "$(__grub_get_options_from_help)";
    else
        _filedir;
    fi
}
function _grub_script_check() 
{ 
    local cur;
    COMPREPLY=();
    cur=`_get_cword`;
    if [[ "$cur" == -* ]]; then
        __grubcomp "$(__grub_get_options_from_help)";
    else
        _filedir;
    fi
}
function _grub_set_entry() 
{ 
    local cur prev split=false;
    COMPREPLY=();
    cur=`_get_cword`;
    prev=${COMP_WORDS[COMP_CWORD-1]};
    _split_longopt && split=true;
    case "$prev" in 
        --boot-directory)
            _filedir -d;
            return
        ;;
    esac;
    $split && return 0;
    if [[ "$cur" == -* ]]; then
        __grubcomp "$(__grub_get_options_from_help)";
    else
        __grub_list_menuentries;
    fi
}
function _grub_setup() 
{ 
    local cur prev split=false;
    COMPREPLY=();
    cur=`_get_cword`;
    prev=${COMP_WORDS[COMP_CWORD-1]};
    _split_longopt && split=true;
    case "$prev" in 
        -d | --directory)
            _filedir -d;
            return
        ;;
    esac;
    $split && return 0;
    if [[ "$cur" == -* ]]; then
        __grubcomp "$(__grub_get_options_from_help)";
    else
        _filedir;
    fi
}
function _have() 
{ 
    PATH=$PATH:/usr/sbin:/sbin:/usr/local/sbin type $1 &> /dev/null
}
function _help_display() 
{ 
    local name value;
    git --help | grep --color=auto -P -v "See 'git help";
    echo "Command aliases:";
    git config --get-regexp 'alias\..*' | sed 's/^alias\.//' | sort | while read name value; do
        printf "   %-10s %-65s\n" "$name" "$value";
    done;
    printf "\nSee 'help COMMAND' for more information on a specific command.\n"
}
function _init_completion() 
{ 
    local exclude= flag outx errx inx OPTIND=1;
    while getopts "n:e:o:i:s" flag "$@"; do
        case $flag in 
            n)
                exclude+=$OPTARG
            ;;
            e)
                errx=$OPTARG
            ;;
            o)
                outx=$OPTARG
            ;;
            i)
                inx=$OPTARG
            ;;
            s)
                split=false;
                exclude+==
            ;;
        esac;
    done;
    COMPREPLY=();
    local redir="@(?([0-9])<|?([0-9&])>?(>)|>&)";
    _get_comp_words_by_ref -n "$exclude<>&" cur prev words cword;
    _variables && return 1;
    if [[ $cur == $redir* || $prev == $redir ]]; then
        local xspec;
        case $cur in 
            2'>'*)
                xspec=$errx
            ;;
            *'>'*)
                xspec=$outx
            ;;
            *'<'*)
                xspec=$inx
            ;;
            *)
                case $prev in 
                    2'>'*)
                        xspec=$errx
                    ;;
                    *'>'*)
                        xspec=$outx
                    ;;
                    *'<'*)
                        xspec=$inx
                    ;;
                esac
            ;;
        esac;
        cur="${cur##$redir}";
        _filedir $xspec;
        return 1;
    fi;
    local i skip;
    for ((i=1; i < ${#words[@]}; 1))
    do
        if [[ ${words[i]} == $redir* ]]; then
            [[ ${words[i]} == $redir ]] && skip=2 || skip=1;
            words=("${words[@]:0:i}" "${words[@]:i+skip}");
            [[ $i -le $cword ]] && cword=$(( cword - skip ));
        else
            i=$(( ++i ));
        fi;
    done;
    [[ $cword -le 0 ]] && return 1;
    prev=${words[cword-1]};
    [[ -n ${split-} ]] && _split_longopt && split=true;
    return 0
}
function _initshow() 
{ 
    _completion_loader apt-get;
    _completion_loader apt-cache;
    _completion_loader man;
    complete -A variable -A binding -A function -A alias -A user -A variable -A file -A directory -F _man -A builtin -A arrayvar show;
    unset -f $FUNCNAME
}
function _installed_modules() 
{ 
    COMPREPLY=($( compgen -W "$( PATH="$PATH:/sbin" lsmod |         awk '{if (NR != 1) print $1}' )" -- "$1" ))
}
function _ip_addresses() 
{ 
    local PATH=$PATH:/sbin;
    COMPREPLY+=($( compgen -W         "$( { LC_ALL=C ifconfig -a || ip addr show; } 2>/dev/null |
            sed -ne 's/.*addr:\([^[:space:]]*\).*/\1/p'                 -ne 's|.*inet[[:space:]]\{1,\}\([^[:space:]/]*\).*|\1|p' )"         -- "$cur" ))
}
function _kernel_versions() 
{ 
    COMPREPLY=($( compgen -W '$( command ls /lib/modules )' -- "$cur" ))
}
function _kernels() 
{ 
    COMPREPLY=($( cd /lib/modules && compgen -d -- "$cur" ))
}
function _known_hosts() 
{ 
    local cur prev words cword;
    _init_completion -n : || return;
    local options;
    [[ "$1" == -a || "$2" == -a ]] && options=-a;
    [[ "$1" == -c || "$2" == -c ]] && options+=" -c";
    _known_hosts_real $options -- "$cur"
}
function _known_hosts_real() 
{ 
    local configfile flag prefix;
    local cur curd awkcur user suffix aliases i host;
    local -a kh khd config;
    local OPTIND=1;
    while getopts "acF:p:" flag "$@"; do
        case $flag in 
            a)
                aliases='yes'
            ;;
            c)
                suffix=':'
            ;;
            F)
                configfile=$OPTARG
            ;;
            p)
                prefix=$OPTARG
            ;;
        esac;
    done;
    [[ $# -lt $OPTIND ]] && echo "error: $FUNCNAME: missing mandatory argument CWORD";
    cur=${!OPTIND};
    let "OPTIND += 1";
    [[ $# -ge $OPTIND ]] && echo "error: $FUNCNAME("$@"): unprocessed arguments:" $(while [[ $# -ge $OPTIND ]]; do printf '%s\n' ${!OPTIND}; shift; done);
    [[ $cur == *@* ]] && user=${cur%@*}@ && cur=${cur#*@};
    kh=();
    if [[ -n $configfile ]]; then
        [[ -r $configfile ]] && config+=("$configfile");
    else
        for i in /etc/ssh/ssh_config ~/.ssh/config ~/.ssh2/config;
        do
            [[ -r $i ]] && config+=("$i");
        done;
    fi;
    if [[ ${#config[@]} -gt 0 ]]; then
        local OIFS=$IFS IFS='
' j;
        local -a tmpkh;
        tmpkh=($( awk 'sub("^[ \t]*([Gg][Ll][Oo][Bb][Aa][Ll]|[Uu][Ss][Ee][Rr])[Kk][Nn][Oo][Ww][Nn][Hh][Oo][Ss][Tt][Ss][Ff][Ii][Ll][Ee][ \t]+", "") { print $0 }' "${config[@]}" | sort -u ));
        IFS=$OIFS;
        for i in "${tmpkh[@]}";
        do
            while [[ $i =~ ^([^\"]*)\"([^\"]*)\"(.*)$ ]]; do
                i=${BASH_REMATCH[1]}${BASH_REMATCH[3]};
                j=${BASH_REMATCH[2]};
                __expand_tilde_by_ref j;
                [[ -r $j ]] && kh+=("$j");
            done;
            for j in $i;
            do
                __expand_tilde_by_ref j;
                [[ -r $j ]] && kh+=("$j");
            done;
        done;
    fi;
    if [[ -z $configfile ]]; then
        for i in /etc/ssh/ssh_known_hosts /etc/ssh/ssh_known_hosts2 /etc/known_hosts /etc/known_hosts2 ~/.ssh/known_hosts ~/.ssh/known_hosts2;
        do
            [[ -r $i ]] && kh+=("$i");
        done;
        for i in /etc/ssh2/knownhosts ~/.ssh2/hostkeys;
        do
            [[ -d $i ]] && khd+=("$i"/*pub);
        done;
    fi;
    if [[ ${#kh[@]} -gt 0 || ${#khd[@]} -gt 0 ]]; then
        awkcur=${cur//\//\\\/};
        awkcur=${awkcur//\./\\\.};
        curd=$awkcur;
        if [[ "$awkcur" == [0-9]*[.:]* ]]; then
            awkcur="^$awkcur[.:]*";
        else
            if [[ "$awkcur" == [0-9]* ]]; then
                awkcur="^$awkcur.*[.:]";
            else
                if [[ -z $awkcur ]]; then
                    awkcur="[a-z.:]";
                else
                    awkcur="^$awkcur";
                fi;
            fi;
        fi;
        if [[ ${#kh[@]} -gt 0 ]]; then
            COMPREPLY+=($( awk 'BEGIN {FS=","}
            /^\s*[^|\#]/ {
            sub("^@[^ ]+ +", ""); \
            sub(" .*$", ""); \
            for (i=1; i<=NF; ++i) { \
            sub("^\\[", "", $i); sub("\\](:[0-9]+)?$", "", $i); \
            if ($i !~ /[*?]/ && $i ~ /'"$awkcur"'/) {print $i} \
            }}' "${kh[@]}" 2>/dev/null ));
        fi;
        if [[ ${#khd[@]} -gt 0 ]]; then
            for i in "${khd[@]}";
            do
                if [[ "$i" == *key_22_$curd*.pub && -r "$i" ]]; then
                    host=${i/#*key_22_/};
                    host=${host/%.pub/};
                    COMPREPLY+=($host);
                fi;
            done;
        fi;
        for ((i=0; i < ${#COMPREPLY[@]}; i++ ))
        do
            COMPREPLY[i]=$prefix$user${COMPREPLY[i]}$suffix;
        done;
    fi;
    if [[ ${#config[@]} -gt 0 && -n "$aliases" ]]; then
        local hosts=$( sed -ne 's/^[ \t]*[Hh][Oo][Ss][Tt]\([Nn][Aa][Mm][Ee]\)\{0,1\}['"$'\t '"']\{1,\}\([^#*?]*\)\(#.*\)\{0,1\}$/\2/p' "${config[@]}" );
        COMPREPLY+=($( compgen -P "$prefix$user"             -S "$suffix" -W "$hosts" -- "$cur" ));
    fi;
    COMPREPLY+=($( compgen -W         "$( ruptime 2>/dev/null | awk '!/^ruptime:/ { print $1 }' )"         -- "$cur" ));
    if [[ -n ${COMP_KNOWN_HOSTS_WITH_HOSTFILE-1} ]]; then
        COMPREPLY+=($( compgen -A hostname -P "$prefix$user" -S "$suffix" -- "$cur" ));
    fi;
    __ltrim_colon_completions "$prefix$user$cur";
    return 0
}
function _loadfunctioneditorfunctions() 
{ 
    test -x ~/.config/bashrc/shells/function-editor/function-editor-functions.iash && source $_ || { 
        echo "Required script: $_ is missing!";
        echo "You do not have the function editor functions installed, you will need to install them";
        echo -ne "${SERVICE_WEBSITE+Find them at: }$SERVICE_WEBSITE${SERVICE_WEBSITE+\n}"
    }
}
function _loexp_() 
{ 
    local c=${COMP_WORDS[COMP_CWORD]};
    local a="${COMP_LINE}";
    local e s g=0 cd dc t="";
    local IFS;
    shopt -q extglob && g=1;
    test $g -eq 0 && shopt -s extglob;
    cd='*-?(c)d*';
    dc='*-d?(c)*';
    case "${1##*/}" in 
        unopkg)
            e='!*.+(oxt|OXT)'
        ;;
        localc)
            e='!*.+(sxc|SXC|stc|STC|dif|DIF|dbf|DBF|xls|XLS|xlw|XLW|xlt|XLT|rtf|RTF|sdc|SDC|vor|VOR|slk|SLK|txt|TXT|htm|HTM|html|HTML|wk1|WK1|wks|WKS|123|123|xml|XML|ods|ODS|ots|OTS|fods|FODS|csv|CSV|xlsb|XLSB|xlsm|XLSM|xlsx|XLSX|xltm|XLTM|xltx|XLTX)'
        ;;
        loweb)
            e='!*.+(htm|HTM|html|HTML|stw|STW|txt|TXT|vor|VOR|oth|OTH)'
        ;;
        loimpress)
            e='!*.+(sxi|SXI|sti|STI|ppt|PPT|pps|PPS|pot|POT|sxd|SXD|sda|SDA|sdd|SDD|sdp|SDP|vor|VOR|cgm|CGM|odp|ODP|otp|OTP|fodp|FODP|ppsm|PPSM|ppsx|PPSX|pptm|PPTM|pptx|PPTX|potm|POTM|potx|POTX)'
        ;;
        lofromtemplate)
            e='!*.+(stw|STW|dot|DOT|vor|VOR|stc|STC|xlt|XLT|sti|STI|pot|POT|std|STD|stw|STW|dotm|DOTM|dotx|DOTX|potm|POTM|potx|POTX|xltm|XLTM|xltx|XLTX)'
        ;;
        lobase)
            e='!*.+(odb|ODB)'
        ;;
        lowriter)
            e='!*.+(doc|DOC|dot|DOT|rtf|RTF|sxw|SXW|stw|STW|sdw|SDW|vor|VOR|txt|TXT|htm?|HTM?|xml|XML|wp|WP|wpd|WPD|wps|WPS|odt|ODT|ott|OTT|fodt|FODT|docm|DOCM|docx|DOCX|dotm|DOTM|dotx|DOTX|sxg|SXG|odm|ODM|sgl|SGL)'
        ;;
        lomath)
            e='!*.+(sxm|SXM|smf|SMF|mml|MML|odf|ODF)'
        ;;
        libreoffice)
            e='!*.+(sxd|SXD|std|STD|dxf|DXF|emf|EMF|eps|EPS|met|MET|pct|PCT|sgf|SGF|sgv|SGV|sda|SDA|sdd|SDD|vor|VOR|svm|SVM|wmf|WMF|bmp|BMP|gif|GIF|jpg|JPG|jpeg|JPEG|jfif|JFIF|fif|FIF|jpe|JPE|pcd|PCD|pcx|PCX|pgm|PGM|png|PNG|ppm|PPM|psd|PSD|ras|RAS|tga|TGA|tif|TIF|tiff|TIFF|xbm|XBM|xpm|XPM|odg|ODG|otg|OTG|fodg|FODG|odc|ODC|odi|ODI|sds|SDS|wpg|WPG|svg|SVG|doc|DOC|dot|DOT|rtf|RTF|sxw|SXW|stw|STW|sdw|SDW|vor|VOR|txt|TXT|htm?|HTM?|xml|XML|wp|WP|wpd|WPD|wps|WPS|odt|ODT|ott|OTT|fodt|FODT|docm|DOCM|docx|DOCX|dotm|DOTM|dotx|DOTX|sxm|SXM|smf|SMF|mml|MML|odf|ODF|sxi|SXI|sti|STI|ppt|PPT|pps|PPS|pot|POT|sxd|SXD|sda|SDA|sdd|SDD|sdp|SDP|vor|VOR|cgm|CGM|odp|ODP|otp|OTP|fodp|FODP|ppsm|PPSM|ppsx|PPSX|pptm|PPTM|pptx|PPTX|potm|POTM|potx|POTX|odb|ODB|sxc|SXC|stc|STC|dif|DIF|dbf|DBF|xls|XLS|xlw|XLW|xlt|XLT|rtf|RTF|sdc|SDC|vor|VOR|slk|SLK|txt|TXT|htm|HTM|html|HTML|wk1|WK1|wks|WKS|123|123|xml|XML|ods|ODS|ots|OTS|fods|FODS|csv|CSV|xlsb|XLSB|xlsm|XLSM|xlsx|XLSX|xltm|XLTM|xltx|XLTX|sxg|SXG|odm|ODM|sgl|SGL|stw|STW|dot|DOT|vor|VOR|stc|STC|xlt|XLT|sti|STI|pot|POT|std|STD|stw|STW|dotm|DOTM|dotx|DOTX|potm|POTM|potx|POTX|xltm|XLTM|xltx|XLTX|htm|HTM|html|HTML|stw|STW|txt|TXT|vor|VOR|oth|OTH)'
        ;;
        loffice)
            e='!*.+(sxd|SXD|std|STD|dxf|DXF|emf|EMF|eps|EPS|met|MET|pct|PCT|sgf|SGF|sgv|SGV|sda|SDA|sdd|SDD|vor|VOR|svm|SVM|wmf|WMF|bmp|BMP|gif|GIF|jpg|JPG|jpeg|JPEG|jfif|JFIF|fif|FIF|jpe|JPE|pcd|PCD|pcx|PCX|pgm|PGM|png|PNG|ppm|PPM|psd|PSD|ras|RAS|tga|TGA|tif|TIF|tiff|TIFF|xbm|XBM|xpm|XPM|odg|ODG|otg|OTG|fodg|FODG|odc|ODC|odi|ODI|sds|SDS|wpg|WPG|svg|SVG|doc|DOC|dot|DOT|rtf|RTF|sxw|SXW|stw|STW|sdw|SDW|vor|VOR|txt|TXT|htm?|HTM?|xml|XML|wp|WP|wpd|WPD|wps|WPS|odt|ODT|ott|OTT|fodt|FODT|docm|DOCM|docx|DOCX|dotm|DOTM|dotx|DOTX|sxm|SXM|smf|SMF|mml|MML|odf|ODF|sxi|SXI|sti|STI|ppt|PPT|pps|PPS|pot|POT|sxd|SXD|sda|SDA|sdd|SDD|sdp|SDP|vor|VOR|cgm|CGM|odp|ODP|otp|OTP|fodp|FODP|ppsm|PPSM|ppsx|PPSX|pptm|PPTM|pptx|PPTX|potm|POTM|potx|POTX|odb|ODB|sxc|SXC|stc|STC|dif|DIF|dbf|DBF|xls|XLS|xlw|XLW|xlt|XLT|rtf|RTF|sdc|SDC|vor|VOR|slk|SLK|txt|TXT|htm|HTM|html|HTML|wk1|WK1|wks|WKS|123|123|xml|XML|ods|ODS|ots|OTS|fods|FODS|csv|CSV|xlsb|XLSB|xlsm|XLSM|xlsx|XLSX|xltm|XLTM|xltx|XLTX|sxg|SXG|odm|ODM|sgl|SGL|stw|STW|dot|DOT|vor|VOR|stc|STC|xlt|XLT|sti|STI|pot|POT|std|STD|stw|STW|dotm|DOTM|dotx|DOTX|potm|POTM|potx|POTX|xltm|XLTM|xltx|XLTX|htm|HTM|html|HTML|stw|STW|txt|TXT|vor|VOR|oth|OTH)'
        ;;
        lodraw)
            e='!*.+(sxd|SXD|std|STD|dxf|DXF|emf|EMF|eps|EPS|met|MET|pct|PCT|sgf|SGF|sgv|SGV|sda|SDA|sdd|SDD|vor|VOR|svm|SVM|wmf|WMF|bmp|BMP|gif|GIF|jpg|JPG|jpeg|JPEG|jfif|JFIF|fif|FIF|jpe|JPE|pcd|PCD|pcx|PCX|pgm|PGM|png|PNG|ppm|PPM|psd|PSD|ras|RAS|tga|TGA|tif|TIF|tiff|TIFF|xbm|XBM|xpm|XPM|odg|ODG|otg|OTG|fodg|FODG|odc|ODC|odi|ODI|sds|SDS|wpg|WPG|svg|SVG)'
        ;;
        *)
            e='!*'
        ;;
    esac;
    case "$(complete -p ${1##*/} 2> /dev/null)" in 
        *-d*)

        ;;
        *)
            s="-S/"
        ;;
    esac;
    IFS='
';
    case "$c" in 
        \$\(*\))
            eval COMPREPLY=\(${c}\)
        ;;
        \$\(*)
            COMPREPLY=($(compgen -c -P '$(' -S ')'  -- ${c#??}))
        ;;
        \`*\`)
            eval COMPREPLY=\(${c}\)
        ;;
        \`*)
            COMPREPLY=($(compgen -c -P '\`' -S '\`' -- ${c#?}))
        ;;
        \$\{*\})
            eval COMPREPLY=\(${c}\)
        ;;
        \$\{*)
            COMPREPLY=($(compgen -v -P '${' -S '}'  -- ${c#??}))
        ;;
        \$*)
            COMPREPLY=($(compgen -v -P '$'          -- ${c#?}))
        ;;
        \~*/*)
            COMPREPLY=($(compgen -f -X "$e"         -- ${c}))
        ;;
        \~*)
            COMPREPLY=($(compgen -u ${s}	 	-- ${c}))
        ;;
        *@*)
            COMPREPLY=($(compgen -A hostname -P '@' -S ':' -- ${c#*@}))
        ;;
        *[*?[]*)
            COMPREPLY=($(compgen -G "${c}"))
        ;;
        *[?*+\!@]\(*\)*)
            if test $g -eq 0; then
                COMPREPLY=($(compgen -f -X "$e" -- $c));
                test $g -eq 0 && shopt -u extglob;
                return;
            fi;
            COMPREPLY=($(compgen -G "${c}"))
        ;;
        *)
            if test "$c" = ".."; then
                COMPREPLY=($(compgen -d -X "$e" -S / ${_nosp} -- $c));
            else
                for s in $(compgen -f -X "$e" -- $c);
                do
                    if test -d $s; then
                        COMPREPLY=(${COMPREPLY[@]} $(compgen -f -X "$e" -S / -- $s));
                    else
                        if test -z "$t"; then
                            COMPREPLY=(${COMPREPLY[@]} $s);
                        else
                            case "$(file -b $s 2> /dev/null)" in 
                                $t)
                                    COMPREPLY=(${COMPREPLY[@]} $s)
                                ;;
                            esac;
                        fi;
                    fi;
                done;
            fi
        ;;
    esac;
    test $g -eq 0 && shopt -u extglob
}
function _longopt() 
{ 
    local cur prev words cword split;
    _init_completion -s || return;
    case "${prev,,}" in 
        --help | --usage | --version)
            return 0
        ;;
        --*dir*)
            _filedir -d;
            return 0
        ;;
        --*file* | --*path*)
            _filedir;
            return 0
        ;;
        --+([-a-z0-9_]))
            local argtype=$( $1 --help 2>&1 | sed -ne                 "s|.*$prev\[\{0,1\}=[<[]\{0,1\}\([-A-Za-z0-9_]\{1,\}\).*|\1|p" );
            case ${argtype,,} in 
                *dir*)
                    _filedir -d;
                    return 0
                ;;
                *file* | *path*)
                    _filedir;
                    return 0
                ;;
            esac
        ;;
    esac;
    $split && return 0;
    if [[ "$cur" == -* ]]; then
        COMPREPLY=($( compgen -W "$( $1 --help 2>&1 |             sed -ne 's/.*\(--[-A-Za-z0-9]\{1,\}=\{0,1\}\).*/\1/p' | sort -u )"             -- "$cur" ));
        [[ $COMPREPLY == *= ]] && compopt -o nospace;
    else
        if [[ "$1" == @(mk|rm)dir ]]; then
            _filedir -d;
        else
            _filedir;
        fi;
    fi
}
function _mac_addresses() 
{ 
    local re='\([A-Fa-f0-9]\{2\}:\)\{5\}[A-Fa-f0-9]\{2\}';
    local PATH="$PATH:/sbin:/usr/sbin";
    COMPREPLY+=($(         { LC_ALL=C ifconfig -a || ip link show; } 2>/dev/null | sed -ne         "s/.*[[:space:]]HWaddr[[:space:]]\{1,\}\($re\)[[:space:]].*/\1/p" -ne         "s/.*[[:space:]]HWaddr[[:space:]]\{1,\}\($re\)[[:space:]]*$/\1/p" -ne         "s|.*[[:space:]]\(link/\)\{0,1\}ether[[:space:]]\{1,\}\($re\)[[:space:]].*|\2|p" -ne         "s|.*[[:space:]]\(link/\)\{0,1\}ether[[:space:]]\{1,\}\($re\)[[:space:]]*$|\2|p"
        ));
    COMPREPLY+=($( { arp -an || ip neigh show; } 2>/dev/null | sed -ne         "s/.*[[:space:]]\($re\)[[:space:]].*/\1/p" -ne         "s/.*[[:space:]]\($re\)[[:space:]]*$/\1/p" ));
    COMPREPLY+=($( sed -ne         "s/^[[:space:]]*\($re\)[[:space:]].*/\1/p" /etc/ethers 2>/dev/null ));
    COMPREPLY=($( compgen -W '${COMPREPLY[@]}' -- "$cur" ));
    __ltrim_colon_completions "$cur"
}
function _minimal() 
{ 
    local cur prev words cword split;
    _init_completion -s || return;
    $split && return;
    _filedir
}
function _modules() 
{ 
    local modpath;
    modpath=/lib/modules/$1;
    COMPREPLY=($( compgen -W "$( command ls -RL $modpath 2>/dev/null |         sed -ne 's/^\(.*\)\.k\{0,1\}o\(\.[gx]z\)\{0,1\}$/\1/p' )" -- "$cur" ))
}
function _ncpus() 
{ 
    local var=NPROCESSORS_ONLN;
    [[ $OSTYPE == *linux* ]] && var=_$var;
    local n=$( getconf $var 2>/dev/null );
    printf %s ${n:-1}
}
function _pacat() 
{ 
    local cur prev comps;
    local flags='-h --help --version -r --record -p --playback -v --verbose -s
                --server= -d --device= -n --client-name= --stream-name= --volume=
                --rate= --format= --channels= --channel-map= --fix-format --fix-rate
                --fix-channels --no-remix --no-remap --latency= --process-time=
                --latency-msec= --process-time-msec= --property= --raw --passthrough
                --file-format= --list-file-formats';
    _init_completion -n = || return;
    case $cur in 
        --server=*)
            cur=${cur#*=};
            _known_hosts_real "$cur"
        ;;
        --device=*)
            cur=${cur#*=};
            comps=$(__sinks);
            comps+=$(__sources);
            COMPREPLY=($(compgen -W '${comps[*]}' -- "$cur"))
        ;;
        --rate=*)
            cur=${cur#*=};
            COMPREPLY=($(compgen -W '32000 44100 48000 9600 192000' -- "$cur"))
        ;;
        --file-format=*)
            cur=${cur#*=};
            comps=$(_pacat_file_formats);
            COMPREPLY=($(compgen -W '${comps[*]}' -- "$cur"))
        ;;
        --*=*)

        ;;
        -*)
            COMPREPLY=($(compgen -W '${flags[*]}' -- "$cur"));
            [[ $COMPREPLY == *= ]] && compopt -o nospace
        ;;
        *)
            _filedir
        ;;
    esac;
    case $prev in 
        -s)
            _known_hosts_real "$cur"
        ;;
        -d)
            comps=$(__sinks);
            comps+=$(__sources);
            COMPREPLY=($(compgen -W '${comps[*]}' -- "$cur"))
        ;;
    esac
}
function _pacat_file_formats() 
{ 
    while IFS='	' read name _; do
        printf "%s\n" "$name";
    done < <(pacat --list-file-formats 2> /dev/null)
}
function _pacmd() 
{ 
    local cur prev words cword preprev command;
    local comps;
    local flags='-h --help --version';
    local commands=(exit help list-modules list-sinks list-sources list-clients list-samples list-sink-inputs list-source-outputs stat info load-module unload-module describe-module set-sink-volume set-source-volume set-sink-input-volume set-source-output-volume set-sink-mute set-source-mut set-sink-input-mute set-source-output-mute update-sink-proplist update-source-proplist update-sink-input-proplist update-source-output-proplist set-default-sink set-default-source kill-client kill-sink-input kill-source-output play-sample remove-sample load-sample load-sample-lazy load-sample-dir-lazy play-file dump move-sink-input move-source-output suspend-sink suspend-source suspend set-card-profile set-sink-port set-source-port set-port-latency-offset set-log-target set-log-level set-log-meta set-log-time set-log-backtrace);
    _init_completion -n = || return;
    preprev=${words[$cword-2]};
    for word in "${COMP_WORDS[@]}";
    do
        if in_array "$word" "${commands[@]}"; then
            command=$word;
            break;
        fi;
    done;
    case $preprev in 
        play-sample | play-file)
            comps=$(__sinks);
            COMPREPLY=($(compgen -W '${comps[*]}' -- "$cur"))
        ;;
        load-sample*)
            _filedir
        ;;
        move-sink-input)
            comps=$(__sinks);
            COMPREPLY=($(compgen -W '${comps[*]}' -- "$cur"))
        ;;
        move-source-output)
            comps=$(__sources);
            COMPREPLY=($(compgen -W '${comps[*]}' -- "$cur"))
        ;;
        set-card-profile)
            comps=$(__profiles);
            COMPREPLY=($(compgen -W '${comps[*]}' -- "$cur"))
        ;;
        set-*port*)
            comps=$(__ports);
            COMPREPLY=($(compgen -W '${comps[*]}' -- "$cur"))
        ;;
        set-*-mute)
            COMPREPLY=($(compgen -W 'true false' -- "$cur"))
        ;;
        set-sink-formats)

        ;;
    esac;
    case $prev in 
        list-*)

        ;;
        describe-module | load-module)
            comps=$(__all_modules);
            COMPREPLY=($(compgen -W '${comps[*]}' -- "$cur"))
        ;;
        unload-module)
            comps=$(__loaded_modules);
            COMPREPLY=($(compgen -W '${comps[*]}' -- "$cur"))
        ;;
        load-sample-dir-lazy)
            _filedir -d
        ;;
        play-file)
            _filedir
        ;;
        *sink-input*)
            comps=$(__sink_inputs);
            COMPREPLY=($(compgen -W '${comps[*]}' -- "$cur"))
        ;;
        *source-output*)
            comps=$(__source_outputs);
            COMPREPLY=($(compgen -W '${comps[*]}' -- "$cur"))
        ;;
        *sink*)
            comps=$(__sinks);
            COMPREPLY=($(compgen -W '${comps[*]}' -- "$cur"))
        ;;
        *source*)
            comps=$(__sources);
            COMPREPLY=($(compgen -W '${comps[*]}' -- "$cur"))
        ;;
        set-card*)
            comps=$(__cards);
            COMPREPLY=($(compgen -W '${comps[*]}' -- "$cur"))
        ;;
        set-port-*)
            comps=$(__cards);
            COMPREPLY=($(compgen -W '${comps[*]}' -- "$cur"))
        ;;
        set-log-target)
            COMPREPLY=($(compgen -W 'auto syslog stderr file: newfile:' -- "$cur"))
        ;;
        set-log-level)
            COMPREPLY=($(compgen -W '{0..4}' -- "$cur"))
        ;;
        set-log-meta | set-log-time | suspend)
            COMPREPLY=($(compgen -W 'true false' -- "$cur"))
        ;;
    esac;
    case $cur in 
        -*)
            COMPREPLY=($(compgen -W '${flags[*]}' -- "$cur"))
        ;;
        suspend)
            COMPREPLY=($(compgen -W 'suspend suspend-sink suspend-source' -- "$cur"))
        ;;
        load-sample)
            COMPREPLY=($(compgen -W 'load-sample load-sample-lazy load-sample-dir-lazy' -- "$cur"))
        ;;
        *)
            [[ -z $command ]] && COMPREPLY=($(compgen -W '${commands[*]}' -- "$cur"))
        ;;
    esac
}
function _pactl() 
{ 
    local cur prev words cword preprev command;
    local comps;
    local flags='-h --help --version -s --server= --client-name=';
    local list_types='short sinks sources sink-inputs source outputs cards
                    modules samples clients';
    local commands=(stat info list exit upload-sample play-sample remove-sample load-module unload-module move-sink-input move-source-output suspend-sink suspend-source set-card-profile set-sink-port set-source-port set-sink-volume set-source-volume set-sink-input-volume set-source-output-volume set-sink-mute set-source-mute set-sink-input-mute set-source-output-mute set-sink-formats set-port-latency-offset subscribe help);
    _init_completion -n = || return;
    preprev=${words[$cword-2]};
    for word in "${COMP_WORDS[@]}";
    do
        if in_array "$word" "${commands[@]}"; then
            command=$word;
            break;
        fi;
    done;
    case $preprev in 
        list)
            COMPREPLY=($(compgen -W 'short' -- "$cur"))
        ;;
        play-sample)
            comps=$(__sinks);
            COMPREPLY=($(compgen -W '${comps[*]}' -- "$cur"))
        ;;
        move-sink-input)
            comps=$(__sinks);
            COMPREPLY=($(compgen -W '${comps[*]}' -- "$cur"))
        ;;
        move-source-output)
            comps=$(__sources);
            COMPREPLY=($(compgen -W '${comps[*]}' -- "$cur"))
        ;;
        set-card-profile)
            comps=$(__profiles);
            COMPREPLY=($(compgen -W '${comps[*]}' -- "$cur"))
        ;;
        set-*-port)
            comps=$(__ports);
            COMPREPLY=($(compgen -W '${comps[*]}' -- "$cur"))
        ;;
        set-*-mute)
            COMPREPLY=($(compgen -W 'true false toggle' -- "$cur"))
        ;;
        set-sink-formats)

        ;;
        set-port-*)
            comps=$(__ports);
            COMPREPLY=($(compgen -W '${comps[*]}' -- "$cur"))
        ;;
        --server)
            compopt +o nospace;
            _known_hosts_real "$cur"
        ;;
    esac;
    [[ -n $COMPREPLY ]] && return 0;
    case $prev in 
        list)
            COMPREPLY=($(compgen -W '${list_types[*]}' -- "$cur"))
        ;;
        stat)
            COMPREPLY=($(compgen -W 'short' -- "$cur"))
        ;;
        upload-sample)
            _filedir
        ;;
        play-sample)

        ;;
        remove-sample)

        ;;
        load-module)
            comps=$(__all_modules);
            COMPREPLY=($(compgen -W '${comps[*]}' -- "$cur"))
        ;;
        unload-module)
            comps=$(__loaded_modules);
            COMPREPLY=($(compgen -W '${comps[*]}' -- "$cur"))
        ;;
        set-card*)
            comps=$(__cards);
            COMPREPLY=($(compgen -W '${comps[*]}' -- "$cur"))
        ;;
        *sink-input*)
            comps=$(__sink_inputs);
            COMPREPLY=($(compgen -W '${comps[*]}' -- "$cur"))
        ;;
        *source-output*)
            comps=$(__source_outputs);
            COMPREPLY=($(compgen -W '${comps[*]}' -- "$cur"))
        ;;
        set-sink-formats)
            comps=$(__sinks_idx);
            COMPREPLY=($(compgen -W '${comps[*]}' -- "$cur"))
        ;;
        *sink*)
            comps=$(__sinks);
            COMPREPLY=($(compgen -W '${comps[*]}' -- "$cur"))
        ;;
        *source*)
            comps=$(__sources);
            COMPREPLY=($(compgen -W '${comps[*]}' -- "$cur"))
        ;;
        set-port*)
            comps=$(__cards);
            COMPREPLY=($(compgen -W '${comps[*]}' -- "$cur"))
        ;;
        -s)
            _known_hosts_real "$cur"
        ;;
    esac;
    [[ -n $COMPREPLY ]] && return 0;
    case $cur in 
        --server=*)
            cur=${cur#*=};
            _known_hosts_real "$cur"
        ;;
        -*)
            COMPREPLY=($(compgen -W '${flags[*]}' -- "$cur"));
            [[ $COMPREPLY == *= ]] && compopt -o nospace
        ;;
        *)
            [[ -z $command ]] && COMPREPLY=($(compgen -W '${commands[*]}' -- "$cur"))
        ;;
    esac
}
function _padsp() 
{ 
    local cur prev;
    local flags='-h -s -n -m -M -S -D -d';
    _get_comp_words_by_ref cur prev;
    case $cur in 
        -*)
            COMPREPLY=($(compgen -W '${flags[*]}' -- "$cur"))
        ;;
    esac;
    case $prev in 
        -s)
            _known_hosts_real "$cur"
        ;;
    esac
}
function _parse_help() 
{ 
    eval local cmd=$( quote "$1" );
    local line;
    { 
        case $cmd in 
            -)
                cat
            ;;
            *)
                LC_ALL=C "$( dequote "$cmd" )" ${2:---help} 2>&1
            ;;
        esac
    } | while read -r line; do
        [[ $line == *([ '	'])-* ]] || continue;
        while [[ $line =~ ((^|[^-])-[A-Za-z0-9?][[:space:]]+)\[?[A-Z0-9]+\]? ]]; do
            line=${line/"${BASH_REMATCH[0]}"/"${BASH_REMATCH[1]}"};
        done;
        __parse_options "${line// or /, }";
    done
}
function _parse_usage() 
{ 
    eval local cmd=$( quote "$1" );
    local line match option i char;
    { 
        case $cmd in 
            -)
                cat
            ;;
            *)
                LC_ALL=C "$( dequote "$cmd" )" ${2:---usage} 2>&1
            ;;
        esac
    } | while read -r line; do
        while [[ $line =~ \[[[:space:]]*(-[^]]+)[[:space:]]*\] ]]; do
            match=${BASH_REMATCH[0]};
            option=${BASH_REMATCH[1]};
            case $option in 
                -?(\[)+([a-zA-Z0-9?]))
                    for ((i=1; i < ${#option}; i++ ))
                    do
                        char=${option:i:1};
                        [[ $char != '[' ]] && printf '%s\n' -$char;
                    done
                ;;
                *)
                    __parse_options "$option"
                ;;
            esac;
            line=${line#*"$match"};
        done;
    done
}
function _pasuspender() 
{ 
    local cur prev;
    local flags='-h --help --version -s --server=';
    _init_completion -n = || return;
    case $cur in 
        --server=*)
            cur=${cur#*=};
            _known_hosts_real "$cur"
        ;;
        -*)
            COMPREPLY=($(compgen -W '${flags[*]}' -- "$cur"));
            [[ $COMPREPLY == *= ]] && compopt -o nospace
        ;;
    esac;
    case $prev in 
        -s)
            _known_hosts_real "$cur"
        ;;
    esac
}
function _pci_ids() 
{ 
    COMPREPLY+=($( compgen -W         "$( PATH="$PATH:/sbin" lspci -n | awk '{print $3}')" -- "$cur" ))
}
function _pgids() 
{ 
    COMPREPLY=($( compgen -W '$( command ps axo pgid= )' -- "$cur" ))
}
function _pids() 
{ 
    COMPREPLY=($( compgen -W '$( command ps axo pid= )' -- "$cur" ))
}
function _pnames() 
{ 
    COMPREPLY=($( compgen -X '<defunct>' -W '$( command ps axo command= | \
        sed -e "s/ .*//" -e "s:.*/::" -e "s/:$//" -e "s/^[[(-]//" \
            -e "s/[])]$//" | sort -u )' -- "$cur" ))
}
function _poff() 
{ 
    local prev cur conns;
    [ -r /etc/ppp/peers/ ] || return 0;
    COMPREPLY=();
    prev=${COMP_WORDS[COMP_CWORD-1]};
    cur=${COMP_WORDS[COMP_CWORD]};
    conns=$(\ls --color=none /etc/ppp/peers | egrep -v '(\.bak|~)$');
    if [[ "$cur" == -* ]]; then
        COMPREPLY=($(compgen -W '-r -d -c -a -h -v' -- $cur));
        return 0;
    fi;
    if [ $COMP_CWORD -eq 1 ] && [[ "$cur" != -* ]] || [[ "$prev" == -* ]]; then
        COMPREPLY=($(compgen -o filenames -W "$conns" $cur));
    fi;
    return 0
}
function _pon() 
{ 
    local cur conns;
    [ -r /etc/ppp/peers/ ] || return 0;
    COMPREPLY=();
    cur=${COMP_WORDS[COMP_CWORD]};
    conns=$(\ls --color=none /etc/ppp/peers | egrep -v '(\.bak|~)$');
    if [ $COMP_CWORD -eq 1 ]; then
        COMPREPLY=($(compgen -o filenames -W "$conns" $cur));
    fi;
    return 0
}
function _pulseaudio() 
{ 
    local cur prev words cword;
    local flags='-h --help --version --dump-conf --dump-resample-methods --cleanup-shm
                --start -k --kill --check --system= -D --daemonize= --fail= --high-priority=
                --realtime= --disallow-module-loading= --disallow-exit= --exit-idle-time=
                --scache-idle-time= --log-level= -v --log-target= --log-meta= --log-time=
                --log-backtrace= -p --dl-search-path= --resample-method= --use-pit-file=
                --no-cpu-limit= --disable-shm= -L --load= -F --file= -C -n';
    _init_completion -n = || return;
    case $cur in 
        --system=* | --daemonize=* | --fail=* | --high-priority=* | --realtime=* | --disallow-*=* | --log-meta=* | --log-time=* | --use-pid-file=* | --no-cpu-limit=* | --disable-shm=*)
            cur=${cur#*=};
            COMPREPLY=($(compgen -W 'true false' -- "$cur"))
        ;;
        --log-target=*)
            cur=${cur#*=};
            COMPREPLY=($(compgen -W 'auto syslog stderr file: newfile:' -- "$cur"))
        ;;
        --log-level=*)
            cur=${cur#*=};
            COMPREPLY=($(compgen -W '{0..4}' -- "$cur"))
        ;;
        --dl-search-path=*)
            cur=${cur#*=};
            _filedir -d
        ;;
        --file=*)
            cur=${cur#*=};
            _filedir
        ;;
        --resample-method=*)
            cur=${cur#*=};
            comps=$(__resample_methods);
            COMPREPLY=($(compgen -W '${comps[*]}' -- "$cur"))
        ;;
        --load=*)
            cur=${cur#*=};
            comps=$(__all_modules);
            COMPREPLY=($(compgen -W '${comps[*]}' -- "$cur"))
        ;;
        --*=*)

        ;;
        -*)
            COMPREPLY=($(compgen -W '${flags[*]}' -- "$cur"));
            [[ $COMPREPLY == *= ]] && compopt -o nospace
        ;;
    esac;
    case $prev in 
        -D)
            COMPREPLY=($(compgen -W 'true false' -- "$cur"))
        ;;
        -p)
            _filedir -d
        ;;
        -F)
            _filedir
        ;;
        -L)
            cur=${cur#*=};
            comps=$(__all_modules);
            COMPREPLY=($(compgen -W '${comps[*]}' -- "$cur"))
        ;;
    esac
}
function _quote_readline_by_ref() 
{ 
    if [ -z "$1" ]; then
        printf -v $2 %s "$1";
    else
        if [[ $1 == \'* ]]; then
            printf -v $2 %s "${1:1}";
        else
            if [[ $1 == ~* ]]; then
                printf -v $2 ~%q "${1:1}";
            else
                printf -v $2 %q "$1";
            fi;
        fi;
    fi;
    [[ ${!2} == *\\* ]] && printf -v $2 %s "${1//\\\\/\\}";
    [[ ${!2} == \$* ]] && eval $2=${!2}
}
function _realcommand() 
{ 
    type -P "$1" > /dev/null && { 
        if type -p realpath > /dev/null; then
            realpath "$(type -P "$1")";
        else
            if type -p greadlink > /dev/null; then
                greadlink -f "$(type -P "$1")";
            else
                if type -p readlink > /dev/null; then
                    readlink -f "$(type -P "$1")";
                else
                    type -P "$1";
                fi;
            fi;
        fi
    }
}
function _rl_enabled() 
{ 
    [[ "$( bind -v )" = *$1+([[:space:]])on* ]]
}
function _root_command() 
{ 
    local PATH=$PATH:/sbin:/usr/sbin:/usr/local/sbin;
    local root_command=$1;
    _command
}
function _selfreload() 
{ 
    set -- ${FUNCNAME[1]};
    if [[ "$*" == "$FUNCNAME" ]]; then
        echo "Warning: resourcing _selfreload, your results may not be as expected (old resourcing new)";
    else
        LINE_START=`cat ~/.bashrc | grep '^\s*function\s+'"$*"'\(\)\s*$' -Pl`;
    fi
}
function _service() 
{ 
    local cur prev words cword;
    _init_completion || return;
    [[ $cword -gt 2 ]] && return 0;
    if [[ $cword -eq 1 && $prev == ?(*/)service ]]; then
        _services;
        [[ -e /etc/mandrake-release ]] && _xinetd_services;
    else
        local sysvdirs;
        _sysvdirs;
        COMPREPLY=($( compgen -W '`sed -e "y/|/ /" \
            -ne "s/^.*\(U\|msg_u\)sage.*{\(.*\)}.*$/\2/p" \
            ${sysvdirs[0]}/${prev##*/} 2>/dev/null` start stop' -- "$cur" ));
    fi
}
function _services() 
{ 
    local sysvdirs;
    _sysvdirs;
    local restore_nullglob=$(shopt -p nullglob);
    shopt -s nullglob;
    COMPREPLY=($( printf '%s\n' ${sysvdirs[0]}/!($_backup_glob|functions) ));
    $restore_nullglob;
    COMPREPLY+=($( systemctl list-units --full --all 2>/dev/null |         awk '$1 ~ /\.service$/ { sub("\\.service$", "", $1); print $1 }' ));
    COMPREPLY=($( compgen -W '${COMPREPLY[@]#${sysvdirs[0]}/}' -- "$cur" ))
}
function _shells() 
{ 
    local shell rest;
    while read -r shell rest; do
        [[ $shell == /* && $shell == "$cur"* ]] && COMPREPLY+=($shell);
    done 2> /dev/null < /etc/shells
}
function _signals() 
{ 
    local -a sigs=($( compgen -P "$1" -A signal "SIG${cur#$1}" ));
    COMPREPLY+=("${sigs[@]/#${1}SIG/${1}}")
}
function _split_longopt() 
{ 
    if [[ "$cur" == --?*=* ]]; then
        prev="${cur%%?(\\)=*}";
        cur="${cur#*=}";
        return 0;
    fi;
    return 1
}
function _subdirectories() 
{ 
    COMPREPLY=($( cd $1 && compgen -d -- "$cur" ))
}
function _svn() 
{ 
    local cur cmds cmdOpts pOpts mOpts rOpts qOpts nOpts optsParam opt;
    COMPREPLY=();
    cur=${COMP_WORDS[COMP_CWORD]};
    cmds='add blame annotate praise cat changelist cl checkout co cleanup';
    cmds="$cmds commit ci copy cp delete remove rm diff export help import";
    cmds="$cmds info list ls lock log merge mergeinfo mkdir move mv rename";
    cmds="$cmds patch propdel pdel propedit pedit propget pget proplist";
    cmds="$cmds plist propset pset relocate resolve resolved revert status";
    cmds="$cmds  switch unlock update upgrade";
    local helpOpts='--help -h';
    local specOpts="--version $helpOpts";
    optsParam="-r|--revision|--username|--password|--targets";
    optsParam="$optsParam|-x|--extensions|-m|--message|-F|--file";
    optsParam="$optsParam|--encoding|--diff-cmd|--diff3-cmd|--editor-cmd";
    optsParam="$optsParam|--old|--new|--config-dir|--config-option";
    optsParam="$optsParam|--native-eol|-l|--limit|-c|--change";
    optsParam="$optsParam|--depth|--set-depth|--with-revprop";
    optsParam="$optsParam|--cl|--changelist|--accept|--show-revs";
    local svnProps revProps allProps psCmds propCmds;
    svnProps="svn:keywords svn:executable svn:needs-lock svn:externals
	          svn:ignore svn:eol-style svn:mime-type $SVN_BASH_FILE_PROPS";
    revProps="svn:author svn:log svn:date $SVN_BASH_REV_PROPS";
    allProps=($svnProps $revProps);
    psCmds='propset|pset|ps';
    propCmds="$psCmds|propget|pget|pg|propedit|pedit|pe|propdel|pdel|pd";
    local urlSchemas='file:/// http:// https:// svn:// svn+ssh://';
    local cmd= isPropCmd= isPsCmd= isHelpCmd= nExpectArgs= isCur= i=0;
    local prev= help= prop= val= isRevProp= last='none' nargs=0 stat=;
    local options= hasRevPropOpt= hasRevisionOpt= hasRelocateOpt=;
    local acceptOpt= URL= hasReintegrateOpt=;
    for opt in "${COMP_WORDS[@]}";
    do
        [[ -n $isCur ]] && stat=$last;
        isCur=;
        [[ $i -eq $COMP_CWORD ]] && isCur=1;
        let i++;
        [ $last = 'none' ] && { 
            last='first';
            continue
        };
        if [[ $prev == @($optsParam) ]]; then
            [[ $prev = '--accept' ]] && acceptOpt=$opt;
            prev='';
            last='skip';
            continue;
        fi;
        if [[ $prev == @(<|>|>>|[12]>|[12]>>) ]]; then
            prev='';
            last='skip';
            continue;
        fi;
        prev=$opt;
        if [[ ! -n $cmd && -n $opt && ( $opt != -* || $opt == @(${specOpts// /|}) ) ]]; then
            cmd=$opt;
            [[ $cmd == @($propCmds) ]] && isPropCmd=1;
            [[ $cmd == @($psCmds) ]] && isPsCmd=1;
            [[ $cmd == @(${helpOpts// /|}) ]] && cmd='help';
            [[ $cmd = 'help' ]] && isHelpCmd=1;
            if [[ -n $isHelpCmd && -n $cmd && $cmd != 'help' && ! -n $help ]]; then
                help=$cmd;
                cmd='help';
            fi;
            last='cmd';
            continue;
        fi;
        if [[ -n $isHelpCmd && ! -n $help && -n $opt && $opt != -* ]]; then
            help=$opt;
            last='help';
            continue;
        fi;
        if [[ -n $isPropCmd && ! -n $prop && -n $opt && $opt != -* ]]; then
            prop=$opt;
            [[ $prop == @(${revProps// /|}) ]] && isRevProp=1;
            last='prop';
            continue;
        fi;
        if [[ -n $isPsCmd && -n $prop && ! -n $val && $opt != -* ]]; then
            val=$opt;
            last='val';
            continue;
        fi;
        if [[ $last != 'onlyarg' ]]; then
            case $opt in 
                -r | --revision | --revision=*)
                    hasRevisionOpt=1
                ;;
                --revprop)
                    hasRevPropOpt=1;
                    allProps=($revProps);
                    nExpectArgs=1
                ;;
                -h | --help)
                    isHelpCmd=1
                ;;
                -F | --file)
                    val='-F'
                ;;
                --relocate)
                    hasRelocateOpt=1
                ;;
                --reintegrate)
                    hasReintegrateOpt=1
                ;;
            esac;
            if [[ $opt = '--' && ! -n $isCur ]]; then
                last='onlyarg';
                continue;
            fi;
            if [[ $opt == -* ]]; then
                [[ ! -n $isCur ]] && options="$options $opt ";
                last='opt';
                continue;
            fi;
        else
            let nargs++;
            continue;
        fi;
        if [[ $cmd = 'merge' && ! -n $URL ]]; then
            URL=$opt;
        fi;
        last='arg';
        let nargs++;
    done;
    [[ -n $stat ]] || stat=$last;
    if [[ ! -n $cmd || $stat = 'cmd' ]]; then
        COMPREPLY=($( compgen -W "$cmds $specOpts" -- $cur ));
        return 0;
    fi;
    if [[ $stat = 'help' || ( -n $isHelpCmd && ! -n $help ) ]]; then
        COMPREPLY=($( compgen -W "$cmds" -- $cur ));
        return 0;
    fi;
    if [[ $cmd == @(co|checkout|ls|list) && $stat = 'arg' && $SVN_BASH_COMPL_EXT == *urls* ]]; then
        if [[ $cur == file:* ]]; then
            local where=${cur/file:/};
            COMPREPLY=($(compgen -d -S '/' -X '*/.*' -- $where ));
            return;
        else
            if [[ $cur == *:* ]]; then
                local urls= file=;
                for file in ~/.subversion/auth/svn.simple/*;
                do
                    if [ -r $file ]; then
                        local url=$(_svn_read_hashfile svn:realmstring < $file);
                        url=${url/*</};
                        url=${url/>*/};
                        urls="$urls $url";
                    fi;
                done;
                local prefix=${cur%:*} suffix=${cur#*:} c= choices=;
                for c in $urls;
                do
                    [[ $c == $prefix:* ]] && choices="$choices ${c#*:}";
                done;
                COMPREPLY=($(compgen -W "$choices" -- $suffix ));
                return;
            else
                COMPREPLY=($(compgen -W "$urlSchemas" -- $cur));
                return;
            fi;
        fi;
    fi;
    if [[ $cmd = 'merge' || $cmd = 'mergeinfo' ]]; then
        local here=$(_svn_info URL);
        if [[ ! -n $URL && $stat = 'arg' ]]; then
            if [[ "$here" == */branches/* ]]; then
                COMPREPLY=($(compgen -W ${here/\/branches\/*/\/trunk} -- $cur ));
                return 0;
            else
                if [[ "$here" == */trunk* ]]; then
                    COMPREPLY=($(compgen -W ${here/\/trunk*/\/branches\/} -- $cur ));
                    return 0;
                else
                    COMPREPLY=($(compgen -W $(_svn_info Root) -- $cur ));
                    return 0;
                fi;
            fi;
        else
            if [[ $URL == */branches/* && $here == */trunk* && ! -n $hasReintegrateOpt && $cur = '' && $stat = 'arg' ]]; then
                COMPREPLY=($(compgen -W '--reintegrate' -- $cur ));
                return 0;
            fi;
        fi;
    fi;
    if [[ $stat = 'skip' ]]; then
        local previous=${COMP_WORDS[COMP_CWORD-1]};
        local values= dirs= beep= exes=;
        [[ $previous = '--config-dir' ]] && dirs=1;
        [[ $previous = --*-cmd ]] && exes=1;
        [[ $previous = '--native-eol' ]] && values='LF CR CRLF';
        [[ $previous = '--limit' ]] && values='0 1 2 3 4 5 6 7 8 9';
        [[ $previous = '--revision' || $previous = '-r' ]] && values='HEAD BASE PREV COMMITTED 0 {';
        [[ $previous = '--encoding' ]] && values="latin1 utf8 $SVN_BASH_ENCODINGS";
        [[ $previous = '--extensions' || $previous = '-x' ]] && values="--unified --ignore-space-change 		   --ignore-all-space --ignore-eol-style --show-c-functions";
        [[ $previous = '--depth' ]] && values='empty files immediates infinity';
        [[ $previous = '--set-depth' ]] && values='empty exclude files immediates infinity';
        [[ $previous = '--accept' ]] && { 
            if [[ $cmd = 'resolve' ]]; then
                values='base working mine-full theirs-full';
            else
                values="postpone base mine-full theirs-full edit launch 			mine-conflict theirs-conflict";
            fi
        };
        [[ $previous = '--show-revs' ]] && values='merged eligible';
        if [[ $previous = '--username' ]]; then
            values="$SVN_BASH_USERNAME";
            if [[ $SVN_BASH_COMPL_EXT == *username* ]]; then
                local file=;
                for file in ~/.subversion/auth/svn.simple/*;
                do
                    if [ -r $file ]; then
                        values="$values $(_svn_read_hashfile username < $file)";
                    fi;
                done;
            fi;
            [[ ! -n "$values" ]] && beep=1;
        fi;
        [[ $previous = '--password' ]] && beep=1;
        [[ -n $values ]] && COMPREPLY=($( compgen -W "$values" -- $cur ));
        [[ -n $dirs ]] && COMPREPLY=($( compgen -o dirnames -- $cur ));
        [[ -n $exes ]] && COMPREPLY=($( compgen -c -- $cur ));
        [[ -n $beep ]] && { 
            echo -en "\a";
            COMPREPLY=('')
        };
        return 0;
    fi;
    if [[ -n $isPropCmd && ( ! -n $prop || $stat = 'prop' ) && $cur != -* ]]; then
        local choices=;
        if [[ $cur == *:* ]]; then
            local prefix=${cur%:*} suffix=${cur#*:} c=;
            for c in ${allProps[@]};
            do
                [[ $c == $prefix:* ]] && choices="$choices ${c#*:}";
            done;
            cur=$suffix;
        else
            COMPREPLY=($( compgen -W "${allProps[*]}" -- $cur ));
            [ ${#COMPREPLY[@]} -eq 1 ] && return 0;
            local seen= n=0 last= c=;
            for c in ${allProps[@]%:*};
            do
                if [[ $c == $cur* && ( ! -n $seen || $c != @($seen) ) ]]; then
                    let n++;
                    last=$c;
                    choices="$choices $c:";
                    if [[ -n $seen ]]; then
                        seen="$seen|$c*";
                    else
                        seen="$c*";
                    fi;
                fi;
            done;
            [[ $n -eq 1 ]] && choices="$last:1 $last:2";
        fi;
        COMPREPLY=($( compgen -W "$choices" -- $cur ));
        return 0;
    fi;
    if [[ -n $isRevProp && ! -n $hasRevPropOpt ]]; then
        COMPREPLY=($( compgen -W '--revprop' -- $cur ));
        return 0;
    fi;
    if [[ -n $isRevProp && -n $hasRevPropOpt && ! -n $hasRevisionOpt ]]; then
        COMPREPLY=($( compgen -W '--revision' -- $cur ));
        return 0;
    fi;
    if [[ -n $isPsCmd && -n $prop && ( ! -n $val || $stat = 'val' ) ]]; then
        local values="\' --file";
        case $prop in 
            svn:keywords)
                values="Id Rev URL Date Author Header \' $SVN_BASH_KEYWORDS"
            ;;
            svn:executable | svn:needs-lock)
                values='\\*'
            ;;
            svn:eol-style)
                values='native LF CR CRLF'
            ;;
            svn:mime-type)
                values="text/ text/plain text/html text/xml text/rtf
                       image/ image/png image/gif image/jpeg image/tiff
                       audio/ audio/midi audio/mpeg
                       video/ video/mpeg video/mp4
                       application/ application/octet-stream
                       $SVN_BASH_MIME_TYPE"
            ;;
        esac;
        COMPREPLY=($( compgen -W "$values" -- $cur ));
        [[ -n ${COMPREPLY} ]] && return 0;
    fi;
    case $cmd in 
        merge)
            nExpectArgs=3
        ;;
        mergeinfo)
            nExpectArgs=1
        ;;
        copy | cp | move | mv | rename | ren | export | import)
            nExpectArgs=2
        ;;
        switch | sw)
            [[ ! -n $hasRelocateOpt ]] && nExpectArgs=2
        ;;
        help | h)
            nExpectArgs=0
        ;;
        --version)
            nExpectArgs=0
        ;;
    esac;
    if [[ -n $nExpectArgs && $nargs -gt $nExpectArgs ]]; then
        echo -en "\a";
        COMPREPLY=('');
        return 0;
    fi;
    if [[ $cur != -* || $stat = 'onlyarg' ]]; then
        if [[ $SVN_BASH_COMPL_EXT == *svnstatus* ]]; then
            local status='svn status --non-interactive';
            [[ $SVN_BASH_COMPL_EXT == *recurse* ]] || status="$status --non-recursive";
            [[ $SVN_BASH_COMPL_EXT == *externals* ]] || status="$status --ignore-externals";
            local cs= files=;
            [[ -n $cur ]] && cs=$cur*;
            case $cmd in 
                st*)
                    files=$cur*
                ;;
                ci | commit | revert | di*)
                    files=$($status $cs| _svn_grcut '@([MADR!]*| M*|_M*)')
                ;;
                add)
                    files=$($status $cs| _svn_grcut '\?*')
                ;;
                unlock)
                    files=$($status $cs| _svn_grcut '@(??L*|?????[KOTB]*)')
                ;;
                resolve*)
                    files=$($status $cs| _svn_grcut '@(?C*|C*)')
                ;;
                praise | blame | ann*)
                    files=$( _svn_lls all $cur* )
                ;;
                p*)
                    if [[ $cmd == @($propCmds) && $prop == @(svn:ignore|svn:externals) ]]; then
                        files=$( _svn_lls dir . $cur* );
                    else
                        files="$( _svn_lls all $cur* )
                                   $($status $cs | _svn_grcut 'A*' )";
                    fi
                ;;
                info)
                    files="$( _svn_lls all $cur* )
                               $($status $cs | _svn_grcut 'A*' )"
                ;;
                remove | rm | del* | move | mv | rename)
                    files=$( _svn_lls all $cur* )
                ;;
                mkdir)
                    files=$( _svn_lls dir $cur* )
                ;;
                log | lock | up* | cl* | switch)
                    files=$( _svn_lls all $cur* )
                ;;
                merge)
                    files=$( _svn_lls all $cur* )
                ;;
                ls | list)
                    files=$( _svn_lls all $cur* )
                ;;
                *)
                    local fallback=1
                ;;
            esac;
            if [[ $SVN_BASH_COMPL_EXT != *recurse* ]]; then
                files="$files $( _svn_lls dir $cur* )";
            fi;
            if [[ -n $files ]]; then
                COMPREPLY=($( compgen -W "$files" -- $cur ));
                [[ -n "${COMPREPLY[*]}" ]] || COMPREPLY=('');
            else
                if [[ ! -n $fallback ]]; then
                    echo -en "\a";
                    COMPREPLY=('');
                fi;
            fi;
        fi;
        return 0;
    fi;
    pOpts="--username --password --no-auth-cache --non-interactive 	       --trust-server-cert --force-interactive";
    mOpts="-m --message -F --file --encoding --force-log --with-revprop";
    rOpts="-r --revision";
    qOpts="-q --quiet";
    nOpts="-N --non-recursive --depth";
    gOpts="-g --use-merge-history";
    cOpts="--cl --changelist";
    cmdOpts=;
    case $cmd in 
        --version)
            cmdOpts="$qOpts"
        ;;
        add)
            cmdOpts="--auto-props --no-auto-props --force --targets 		         --no-ignore --parents $nOpts $qOpts $pOpts"
        ;;
        blame | annotate | ann | praise)
            cmdOpts="$rOpts $pOpts -v --verbose --incremental --xml 		         -x --extensions --force $gOpts"
        ;;
        cat)
            cmdOpts="$rOpts $pOpts"
        ;;
        changelist | cl)
            cmdOpts="--targets $pOpts $qOpts $cOpts                          -R --recursive --depth --remove"
        ;;
        checkout | co)
            cmdOpts="$rOpts $qOpts $nOpts $pOpts --ignore-externals                          --force"
        ;;
        cleanup)
            cmdOpts="--diff3-cmd $pOpts"
        ;;
        commit | ci)
            cmdOpts="$mOpts $qOpts $nOpts --targets --editor-cmd $pOpts 		         --no-unlock $cOpts --keep-changelists 		         --include-externals"
        ;;
        copy | cp)
            cmdOpts="$mOpts $rOpts $qOpts --editor-cmd $pOpts --parents 		         --ignore-externals"
        ;;
        delete | del | remove | rm)
            cmdOpts="--force $mOpts $qOpts --targets --editor-cmd $pOpts                          --keep-local"
        ;;
        diff | di)
            cmdOpts="$rOpts -x --extensions --diff-cmd --no-diff-deleted 		         $nOpts $pOpts --force --old --new --notice-ancestry 		         -c --change --summarize $cOpts --xml --git 		         --internal-diff --show-copies-as-adds 		         --ignore-properties --properties-only --no-diff-added 		         --patch-compatible"
        ;;
        export)
            cmdOpts="$rOpts $qOpts $pOpts $nOpts --force --native-eol                          --ignore-externals --ignore-keywords"
        ;;
        help | h | \?)
            cmdOpts=
        ;;
        import)
            cmdOpts="--auto-props --no-auto-props $mOpts $qOpts $nOpts 		         --no-ignore --editor-cmd $pOpts --force"
        ;;
        info)
            cmdOpts="$pOpts $rOpts --targets -R --recursive --depth                          --incremental --xml $cOpts"
        ;;
        list | ls)
            cmdOpts="$rOpts -v --verbose -R --recursive $pOpts                          --incremental --xml --depth --include-externals"
        ;;
        lock)
            cmdOpts="-m --message -F --file --encoding --force-log                          --targets --force $pOpts"
        ;;
        log)
            cmdOpts="$rOpts -v --verbose --targets $pOpts --stop-on-copy 		         --incremental --xml $qOpts -l --limit -c --change                          $gOpts --with-all-revprops --with-revprop --depth 		         --diff --diff-cmd -x --extensions --internal-diff 		         --with-no-revprops --search --search-and"
        ;;
        merge)
            cmdOpts="$rOpts $nOpts $qOpts --force --dry-run --diff3-cmd 		         $pOpts --ignore-ancestry -c --change -x --extensions                          --record-only --accept --reintegrate 		         --allow-mixed-revisions -v --verbose"
        ;;
        mergeinfo)
            cmdOpts="$rOpts $pOpts --depth --show-revs -R --recursive"
        ;;
        mkdir)
            cmdOpts="$mOpts $qOpts --editor-cmd $pOpts --parents"
        ;;
        move | mv | rename | ren)
            cmdOpts="$mOpts $rOpts $qOpts --force --editor-cmd $pOpts                          --parents --allow-mixed-revisions"
        ;;
        patch)
            cmdOpts="$qOpts $pOpts --dry-run --ignore-whitespace 			--reverse-diff --strip"
        ;;
        propdel | pdel | pd)
            cmdOpts="$qOpts -R --recursive $rOpts $pOpts $cOpts                          --depth";
            [[ -n $isRevProp || ! -n $prop ]] && cmdOpts="$cmdOpts --revprop"
        ;;
        propedit | pedit | pe)
            cmdOpts="--editor-cmd $pOpts $mOpts --force";
            [[ -n $isRevProp || ! -n $prop ]] && cmdOpts="$cmdOpts --revprop $rOpts"
        ;;
        propget | pget | pg)
            cmdOpts="-v --verbose -R --recursive $rOpts --strict 		         $pOpts $cOpts --depth --xml --show-inherited-props";
            [[ -n $isRevProp || ! -n $prop ]] && cmdOpts="$cmdOpts --revprop"
        ;;
        proplist | plist | pl)
            cmdOpts="-v --verbose -R --recursive $rOpts --revprop $qOpts 		         $pOpts $cOpts --depth --xml --show-inherited-props"
        ;;
        propset | pset | ps)
            cmdOpts="$qOpts --targets -R --recursive 		         --encoding $pOpts --force $cOpts --depth";
            [[ -n $isRevProp || ! -n $prop ]] && cmdOpts="$cmdOpts --revprop $rOpts";
            [[ -n $val ]] || cmdOpts="$cmdOpts -F --file"
        ;;
        relocate)
            cmdOpts="--ignore-externals $pOpts"
        ;;
        resolve)
            cmdOpts="--targets -R --recursive $qOpts $pOpts --accept                          --depth"
        ;;
        resolved)
            cmdOpts="--targets -R --recursive $qOpts $pOpts --depth"
        ;;
        revert)
            cmdOpts="--targets -R --recursive $qOpts $cOpts                          --depth $pOpts"
        ;;
        status | stat | st)
            cmdOpts="-u --show-updates -v --verbose $nOpts $qOpts $pOpts 		         --no-ignore --ignore-externals --incremental --xml                          $cOpts"
        ;;
        switch | sw)
            cmdOpts="--relocate $rOpts $nOpts $qOpts $pOpts --diff3-cmd                          --force --accept --ignore-externals --set-depth 		         --ignore-ancestry"
        ;;
        unlock)
            cmdOpts="--targets --force $pOpts"
        ;;
        update | up)
            cmdOpts="$rOpts $nOpts $qOpts $pOpts --diff3-cmd                          --ignore-externals --force --accept $cOpts                          --parents --editor-cmd --set-depth"
        ;;
        upgrade)
            cmdOpts="$qOpts $pOpts"
        ;;
        *)

        ;;
    esac;
    [[ "$cmd" != "--version" ]] && cmdOpts="$cmdOpts $helpOpts";
    cmdOpts="$cmdOpts --config-dir --config-option";
    if [[ $acceptOpt == @(edit|launch) ]]; then
        cmdOpts=${cmdOpts/ --non-interactive / };
    fi;
    for opt in $options;
    do
        local optBase;
        case $opt in 
            --*)
                optBase=${opt/=*/}
            ;;
            -*)
                optBase=${opt:0:2}
            ;;
        esac;
        cmdOpts=" $cmdOpts ";
        cmdOpts=${cmdOpts/ ${optBase} / };
        case $optBase in 
            -v)
                cmdOpts=${cmdOpts/ --verbose / }
            ;;
            --verbose)
                cmdOpts=${cmdOpts/ -v / }
            ;;
            -N)
                cmdOpts=${cmdOpts/ --non-recursive / }
            ;;
            --non-recursive)
                cmdOpts=${cmdOpts/ -N / }
            ;;
            -R)
                cmdOpts=${cmdOpts/ --recursive / }
            ;;
            --recursive)
                cmdOpts=${cmdOpts/ -R / }
            ;;
            -x)
                cmdOpts=${cmdOpts/ --extensions / }
            ;;
            --extensions)
                cmdOpts=${cmdOpts/ -x / }
            ;;
            -q)
                cmdOpts=${cmdOpts/ --quiet / }
            ;;
            --quiet)
                cmdOpts=${cmdOpts/ -q / }
            ;;
            -h)
                cmdOpts=${cmdOpts/ --help / }
            ;;
            --help)
                cmdOpts=${cmdOpts/ -h / }
            ;;
            -l)
                cmdOpts=${cmdOpts/ --limit / }
            ;;
            --limit)
                cmdOpts=${cmdOpts/ -l / }
            ;;
            -r)
                cmdOpts=${cmdOpts/ --revision / }
            ;;
            --revision)
                cmdOpts=${cmdOpts/ -r / }
            ;;
            -c)
                cmdOpts=${cmdOpts/ --change / }
            ;;
            --change)
                cmdOpts=${cmdOpts/ -c / }
            ;;
            --auto-props)
                cmdOpts=${cmdOpts/ --no-auto-props / }
            ;;
            --no-auto-props)
                cmdOpts=${cmdOpts/ --auto-props / }
            ;;
            -g)
                cmdOpts=${cmdOpts/ --use-merge-history / }
            ;;
            --use-merge-history)
                cmdOpts=${cmdOpts/ -g / }
            ;;
            -m | --message | -F | --file)
                cmdOpts=${cmdOpts/ --message / };
                cmdOpts=${cmdOpts/ -m / };
                cmdOpts=${cmdOpts/ --file / };
                cmdOpts=${cmdOpts/ -F / }
            ;;
        esac;
        if [ $isHelpCmd ]; then
            cmdOpts=${cmdOpts/ -h / };
            cmdOpts=${cmdOpts/ --help / };
        fi;
    done;
    COMPREPLY=($( compgen -W "$cmdOpts" -- $cur ));
    return 0
}
function _svn_grcut() 
{ 
    local re=$1 line= old_IFS;
    old_IFS="$IFS";
    IFS='
';
    while read -r line; do
        [[ ! -n $re || $line == $re ]] && echo "${line/????????/}";
    done;
    IFS="$old_IFS"
}
function _svn_info() 
{ 
    local what=$1 line=;
    LANG=C LC_MESSAGES=C svn info --non-interactive 2> /dev/null | while read line; do
        [[ $line == *"$what: "* ]] && echo ${line#*: };
    done
}
function _svn_lls() 
{ 
    local opt=$1 f=;
    shift;
    for f in "$@";
    do
        if [[ $opt == @(dir|all) && -d "$f" ]]; then
            echo "$f/";
        else
            if [[ $opt == @(file|all) ]]; then
                local dn= fn="$f";
                [[ "$f" == */* ]] && dn=${f%\/*}/ fn=${f##*\/};
                [ -f "${dn}.svn/text-base/${fn}.svn-base" ] && echo "$f";
            fi;
        fi;
    done
}
function _svn_read_hashfile() 
{ 
    local tkey=$1 key= val=;
    while true; do
        read tag len;
        [ $tag = 'END' ] && break;
        [ $tag != 'K' ] && { 
            return
        };
        read -r -n $len key;
        read;
        read tag len;
        [ $tag != 'V' ] && { 
            return
        };
        read -r -n $len val;
        read;
        if [[ $key = $tkey ]]; then
            echo "$val";
            return;
        fi;
    done
}
function _svnadmin() 
{ 
    local cur cmds cmdOpts optsParam opt helpCmds optBase i;
    COMPREPLY=();
    cur=${COMP_WORDS[COMP_CWORD]};
    cmds='crashtest create deltify dump freeze help hotcopy list-dblogs \
	      list-unused-dblogs load lock lslocks lstxns pack recover rmlocks \
	      rmtxns setlog setrevprop setuuid unlock upgrade verify --version';
    if [[ $COMP_CWORD -eq 1 ]]; then
        COMPREPLY=($( compgen -W "$cmds" -- $cur ));
        return 0;
    fi;
    optsParam="-r|--revision|--parent-dir|--fs-type|-M|--memory-cache-size";
    optsParam="$optsParam|-F|--file";
    helpCmds='help|--help|h|\?';
    if [[ ${COMP_WORDS[1]} != @($helpCmds) ]] && [[ "$cur" != -* ]] || [[ ${COMP_WORDS[COMP_CWORD-1]} == @($optsParam) ]]; then
        return 0;
    fi;
    cmdOpts=;
    case ${COMP_WORDS[1]} in 
        create)
            cmdOpts="--bdb-txn-nosync --bdb-log-keep --config-dir 		         --fs-type --pre-1.4-compatible --pre-1.5-compatible 		         --pre-1.6-compatible --compatible-version"
        ;;
        deltify)
            cmdOpts="-r --revision -q --quiet"
        ;;
        dump)
            cmdOpts="-r --revision --incremental -q --quiet --deltas 		         -M --memory-cache-size"
        ;;
        freeze)
            cmdOpts="-F --file"
        ;;
        help | h | \?)
            cmdOpts="$cmds"
        ;;
        hotcopy)
            cmdOpts="--clean-logs"
        ;;
        load)
            cmdOpts="--ignore-uuid --force-uuid --parent-dir -q --quiet 		         --use-pre-commit-hook --use-post-commit-hook 		         --bypass-prop-validation -M --memory-cache-size"
        ;;
        lock | unlock)
            cmdOpts="--bypass-hooks"
        ;;
        recover)
            cmdOpts="--wait"
        ;;
        rmtxns)
            cmdOpts="-q --quiet"
        ;;
        setlog)
            cmdOpts="-r --revision --bypass-hooks"
        ;;
        setrevprop)
            cmdOpts="-r --revision --use-pre-revprop-change-hook 		         --use-post-revprop-change-hook"
        ;;
        verify)
            cmdOpts="-r --revision -q --quiet"
        ;;
        *)

        ;;
    esac;
    cmdOpts="$cmdOpts --help -h";
    for ((i=2; i<=$COMP_CWORD-1; ++i ))
    do
        opt=${COMP_WORDS[$i]};
        case $opt in 
            --*)
                optBase=${opt/=*/}
            ;;
            -*)
                optBase=${opt:0:2}
            ;;
        esac;
        cmdOpts=" $cmdOpts ";
        cmdOpts=${cmdOpts/ ${optBase} / };
        case $optBase in 
            -q)
                cmdOpts=${cmdOpts/ --quiet / }
            ;;
            --quiet)
                cmdOpts=${cmdOpts/ -q / }
            ;;
            -h)
                cmdOpts=${cmdOpts/ --help / }
            ;;
            --help)
                cmdOpts=${cmdOpts/ -h / }
            ;;
            -r)
                cmdOpts=${cmdOpts/ --revision / }
            ;;
            --revision)
                cmdOpts=${cmdOpts/ -r / }
            ;;
            -F)
                cmdOpts=${cmdOpts/ --file / }
            ;;
            --file)
                cmdOpts=${cmdOpts/ -F / }
            ;;
            -M)
                cmdOpts=${cmdOpts/ --memory-cache-size / }
            ;;
            --memory-cache-size)
                cmdOpts=${cmdOpts/ --M / }
            ;;
        esac;
        if [[ $opt == @($optsParam) ]]; then
            ((++i));
        fi;
    done;
    COMPREPLY=($( compgen -W "$cmdOpts" -- $cur ));
    return 0
}
function _svndumpfilter() 
{ 
    local cur cmds cmdOpts optsParam opt helpCmds optBase i;
    COMPREPLY=();
    cur=${COMP_WORDS[COMP_CWORD]};
    cmds='exclude help include --version';
    if [[ $COMP_CWORD -eq 1 ]]; then
        COMPREPLY=($( compgen -W "$cmds" -- $cur ));
        return 0;
    fi;
    optsParam="--targets";
    helpCmds='help|--help|h|\?';
    if [[ ${COMP_WORDS[1]} != @($helpCmds) ]] && [[ "$cur" != -* ]] || [[ ${COMP_WORDS[COMP_CWORD-1]} == @($optsParam) ]]; then
        return 0;
    fi;
    cmdOpts=;
    case ${COMP_WORDS[1]} in 
        exclude | include)
            cmdOpts="--drop-empty-revs --renumber-revs
		         --skip-missing-merge-sources --targets
		         --preserve-revprops --quiet"
        ;;
        help | h | \?)
            cmdOpts="$cmds"
        ;;
        *)

        ;;
    esac;
    cmdOpts="$cmdOpts --help -h";
    for ((i=2; i<=$COMP_CWORD-1; ++i ))
    do
        opt=${COMP_WORDS[$i]};
        case $opt in 
            --*)
                optBase=${opt/=*/}
            ;;
            -*)
                optBase=${opt:0:2}
            ;;
        esac;
        cmdOpts=" $cmdOpts ";
        cmdOpts=${cmdOpts/ ${optBase} / };
        case $optBase in 
            -h)
                cmdOpts=${cmdOpts/ --help / }
            ;;
            --help)
                cmdOpts=${cmdOpts/ -h / }
            ;;
        esac;
        if [[ $opt == @($optsParam) ]]; then
            ((++i));
        fi;
    done;
    COMPREPLY=($( compgen -W "$cmdOpts" -- $cur ));
    return 0
}
function _svnlook() 
{ 
    local cur cmds cmdOpts optsParam opt helpCmds optBase i;
    COMPREPLY=();
    cur=${COMP_WORDS[COMP_CWORD]};
    cmds='author cat changed date diff dirs-changed help history info \
	      lock log propget proplist tree uuid youngest --version';
    if [[ $COMP_CWORD -eq 1 ]]; then
        COMPREPLY=($( compgen -W "$cmds" -- $cur ));
        return 0;
    fi;
    optsParam="-r|--revision|-t|--transaction|-l|--limit|-x|--extensions";
    helpCmds='help|--help|h|\?';
    if [[ ${COMP_WORDS[1]} != @($helpCmds) ]] && [[ "$cur" != -* ]] || [[ ${COMP_WORDS[COMP_CWORD-1]} == @($optsParam) ]]; then
        return 0;
    fi;
    cmdOpts=;
    case ${COMP_WORDS[1]} in 
        author)
            cmdOpts="-r --revision -t --transaction"
        ;;
        cat)
            cmdOpts="-r --revision -t --transaction"
        ;;
        changed)
            cmdOpts="-r --revision -t --transaction --copy-info"
        ;;
        date)
            cmdOpts="-r --revision -t --transaction"
        ;;
        diff)
            cmdOpts="-r --revision -t --transaction --diff-copy-from 		         --no-diff-added --no-diff-deleted -x --extensions"
        ;;
        dirs-changed)
            cmdOpts="-r --revision -t --transaction"
        ;;
        help | h | \?)
            cmdOpts="$cmds"
        ;;
        history)
            cmdOpts="-r --revision -l --limit --show-ids"
        ;;
        info)
            cmdOpts="-r --revision -t --transaction"
        ;;
        lock)
            cmdOpts=
        ;;
        log)
            cmdOpts="-r --revision -t --transaction"
        ;;
        propget | pget | pg)
            cmdOpts="-r --revision -t --transaction --revprop"
        ;;
        proplist | plist | pl)
            cmdOpts="-r --revision -t --transaction --revprop -v --verbose --xml"
        ;;
        tree)
            cmdOpts="-r --revision -t --transaction --full-paths -N --non-recursive --show-ids"
        ;;
        uuid)
            cmdOpts=
        ;;
        youngest)
            cmdOpts=
        ;;
        *)

        ;;
    esac;
    cmdOpts="$cmdOpts --help -h";
    for ((i=2; i<=$COMP_CWORD-1; ++i ))
    do
        opt=${COMP_WORDS[$i]};
        case $opt in 
            --*)
                optBase=${opt/=*/}
            ;;
            -*)
                optBase=${opt:0:2}
            ;;
        esac;
        cmdOpts=" $cmdOpts ";
        cmdOpts=${cmdOpts/ ${optBase} / };
        case $optBase in 
            -N)
                cmdOpts=${cmdOpts/ --non-recursive / }
            ;;
            --non-recursive)
                cmdOpts=${cmdOpts/ -N / }
            ;;
            -h)
                cmdOpts=${cmdOpts/ --help / }
            ;;
            --help)
                cmdOpts=${cmdOpts/ -h / }
            ;;
            -l)
                cmdOpts=${cmdOpts/ --limit / }
            ;;
            --limit)
                cmdOpts=${cmdOpts/ -l / }
            ;;
            -r)
                cmdOpts=${cmdOpts/ --revision / }
            ;;
            --revision)
                cmdOpts=${cmdOpts/ -r / }
            ;;
            -t)
                cmdOpts=${cmdOpts/ --transaction / }
            ;;
            --transaction)
                cmdOpts=${cmdOpts/ -t / }
            ;;
            -v)
                cmdOpts=${cmdOpts/ --verbose / }
            ;;
            --verbose)
                cmdOpts=${cmdOpts/ -v / }
            ;;
            -x)
                cmdOpts=${cmdOpts/ --extensions / }
            ;;
            --extensions)
                cmdOpts=${cmdOpts/ -x / }
            ;;
        esac;
        if [[ $opt == @($optsParam) ]]; then
            ((++i));
        fi;
    done;
    COMPREPLY=($( compgen -W "$cmdOpts" -- $cur ));
    return 0
}
function _svnsync() 
{ 
    local cur cmds cmdOpts optsParam opt helpCmds optBase i;
    COMPREPLY=();
    cur=${COMP_WORDS[COMP_CWORD]};
    cmds='copy-revprops help info initialize synchronize --version';
    if [[ $COMP_CWORD -eq 1 ]]; then
        COMPREPLY=($( compgen -W "$cmds" -- $cur ));
        return 0;
    fi;
    optsParam="--config-dir|--config-option|--source-username|--source-password";
    optsParam="$optsParam|--sync-username|--sync-password";
    helpCmds='help|--help|h|\?';
    if [[ ${COMP_WORDS[1]} != @($helpCmds) ]] && [[ "$cur" != -* ]] || [[ ${COMP_WORDS[COMP_CWORD-1]} == @($optsParam) ]]; then
        return 0;
    fi;
    cmdOpts=;
    case ${COMP_WORDS[1]} in 
        copy-revprops | initialize | init | synchronize | sync)
            cmdOpts="--non-interactive --no-auth-cache --trust-server-cert 		         --source-username --source-password --sync-username 		         --sync-password --config-dir --config-option -q --quiet"
        ;;
        help | h | \?)
            cmdOpts="$cmds"
        ;;
        info)
            cmdOpts="--non-interactive --no-auth-cache --trust-server-cert 		         --source-username --source-password --sync-username 		         --sync-password --config-dir --config-option"
        ;;
        *)

        ;;
    esac;
    cmdOpts="$cmdOpts --help -h";
    for ((i=2; i<=$COMP_CWORD-1; ++i ))
    do
        opt=${COMP_WORDS[$i]};
        case $opt in 
            --*)
                optBase=${opt/=*/}
            ;;
            -*)
                optBase=${opt:0:2}
            ;;
        esac;
        cmdOpts=" $cmdOpts ";
        cmdOpts=${cmdOpts/ ${optBase} / };
        case $optBase in 
            -h)
                cmdOpts=${cmdOpts/ --help / }
            ;;
            --help)
                cmdOpts=${cmdOpts/ -h / }
            ;;
            -q)
                cmdOpts=${cmdOpts/ --quiet / }
            ;;
            --quiet)
                cmdOpts=${cmdOpts/ -q / }
            ;;
        esac;
        if [[ $opt == @($optsParam) ]]; then
            ((++i));
        fi;
    done;
    COMPREPLY=($( compgen -W "$cmdOpts" -- $cur ));
    return 0
}
function _svnversion() 
{ 
    local cmdOpts=" -n --no-newline -c --committed -h --help --version ";
    local cur=${COMP_WORDS[COMP_CWORD]};
    COMPREPLY=();
    local options= wcpath= trailurl= last='none' stat= opt= i=-1 isCur=;
    for opt in ${COMP_WORDS[@]};
    do
        [[ $i -eq $COMP_CWORD ]] && stat=$last;
        let i++;
        isCur=;
        [[ $i -eq $COMP_CWORD ]] && isCur=1;
        if [ $last = 'none' ]; then
            last='first';
            continue;
        fi;
        if [[ $last != 'arg' && $opt == -* ]]; then
            if [[ $opt = '--' && ! -n $isCur ]]; then
                last='arg';
            else
                options="$options $opt ";
                last='opt';
            fi;
            continue;
        fi;
        if [[ $opt != -* ]]; then
            last='arg';
            if [[ ! -n $wcpath ]]; then
                wcpath=$opt;
            else
                if [[ ! -n $trailurl ]]; then
                    trailurl=$opt;
                fi;
            fi;
        fi;
    done;
    [[ -n $stat ]] || stat=$last;
    if [[ $cur != -* || $stat = 'arg' ]]; then
        [[ -n $wcpath && -n $trailurl ]] && COMPREPLY=('');
        return 0;
    fi;
    for opt in $options;
    do
        cmdOpts=${cmdOpts/ $opt / };
        case $opt in 
            -n)
                cmdOpts=${cmdOpts/ --no-newline / }
            ;;
            --no-newline)
                cmdOpts=${cmdOpts/ -n / }
            ;;
            -h)
                cmdOpts=${cmdOpts/ --help / }
            ;;
            --help)
                cmdOpts=${cmdOpts/ -h / }
            ;;
            -c)
                cmdOpts=${cmdOpts/ --committed / }
            ;;
            --committed)
                cmdOpts=${cmdOpts/ -c / }
            ;;
        esac;
    done;
    COMPREPLY=($( compgen -W "$cmdOpts" -- $cur ));
    return 0
}
function _sysvdirs() 
{ 
    sysvdirs=();
    [[ -d /etc/rc.d/init.d ]] && sysvdirs+=(/etc/rc.d/init.d);
    [[ -d /etc/init.d ]] && sysvdirs+=(/etc/init.d);
    [[ -f /etc/slackware-version ]] && sysvdirs=(/etc/rc.d)
}
function _terms() 
{ 
    COMPREPLY+=($( compgen -W         "$( sed -ne 's/^\([^[:space:]#|]\{2,\}\)|.*/\1/p' /etc/termcap             2>/dev/null )" -- "$cur" ));
    COMPREPLY+=($( compgen -W "$( { toe -a 2>/dev/null || toe 2>/dev/null; }         | awk '{ print $1 }' | sort -u )" -- "$cur" ))
}
function _testcomplete() 
{ 
    export COMP_LARGS=("$@");
    printf '[s[1;1H';
    cat  <<-EOF
Completion Statistics
-----------------------------------
COMP_CWORD      $COMP_CWORD
COMP_KEY        $COMP_KEY
COMP_LINE       $COMP_LINE
COMP_POINT      $COMP_POINT
COMP_TYPE       $COMP_TYPE
COMP_WORDBREAKS ${COMP_WORDBREAKS[@]}
COMP_WORDS      ${COMP_WORDS[@]}
COMP_LARGS*     ${COMP_LARGS[@]}
COMPREPLY       ${COMPREPLY[@]}
-----------------------------------
* this is \$1, \$2, etc
EOF

    printf '[u'
}
function _tilde() 
{ 
    local result=0;
    if [[ $1 == \~* && $1 != */* ]]; then
        COMPREPLY=($( compgen -P '~' -u "${1#\~}" ));
        result=${#COMPREPLY[@]};
        [[ $result -gt 0 ]] && compopt -o filenames 2> /dev/null;
    fi;
    return $result
}
function _ufw() 
{ 
    cur=${COMP_WORDS[COMP_CWORD]};
    prev=${COMP_WORDS[COMP_CWORD-1]};
    if [ $COMP_CWORD -eq 1 ]; then
        COMPREPLY=($( compgen -W "$(_ufw_commands)" $cur ));
    else
        if [ $COMP_CWORD -eq 2 ]; then
            case "$prev" in 
                app)
                    COMPREPLY=($( compgen -W "$(_ufw_app_commands)" $cur ))
                ;;
                status)
                    COMPREPLY=($( compgen -W "$(_ufw_status_commands)" $cur ))
                ;;
                delete)
                    COMPREPLY=($( compgen -W "$(_ufw_rule_commands)" $cur ))
                ;;
                logging)
                    COMPREPLY=($( compgen -W "$(_ufw_logging_commands)" $cur ))
                ;;
                show)
                    COMPREPLY=($( compgen -W "$(_ufw_show_commands)" $cur ))
                ;;
                default)
                    COMPREPLY=($( compgen -W "$(_ufw_default_commands)" $cur ))
                ;;
            esac;
        fi;
    fi
}
function _ufw_app_commands() 
{ 
    ufw --help | sed -e '1,/^Application profile commands:/d' -e '/^ [^ ]/!d' -e 's/[ \t]\+app[ \t]\+\([a-z|]\+\)[ \t]\+.*/\1/g'
}
function _ufw_commands() 
{ 
    commands=$(ufw --help | sed -e '1,/^Commands:/d' -e '/^Application profile commands:/Q' -e 's/^[ \t]\+\([a-z|]\+\)[ \t]\+.*/\1/g' -e 's/|/ /g' | uniq);
    echo "$commands app"
}
function _ufw_default_commands() 
{ 
    echo "allow deny reject"
}
function _ufw_logging_commands() 
{ 
    echo "off on low medium high full"
}
function _ufw_rule_commands() 
{ 
    echo "`_ufw_default_commands` limit"
}
function _ufw_show_commands() 
{ 
    echo "raw"
}
function _ufw_status_commands() 
{ 
    echo "numbered verbose"
}
function _uids() 
{ 
    if type getent &> /dev/null; then
        COMPREPLY=($( compgen -W '$( getent passwd | cut -d: -f3 )' -- "$cur" ));
    else
        if type perl &> /dev/null; then
            COMPREPLY=($( compgen -W '$( perl -e '"'"'while (($uid) = (getpwent)[2]) { print $uid . "\n" }'"'"' )' -- "$cur" ));
        else
            COMPREPLY=($( compgen -W '$( cut -d: -f3 /etc/passwd )' -- "$cur" ));
        fi;
    fi
}
function _update_initramfs() 
{ 
    local cur prev valid_options;
    cur=$(_get_cword);
    prev=${COMP_WORDS[COMP_CWORD-1]};
    if [[ "$prev" == '-k' ]]; then
        _kernel_versions;
        COMPREPLY=($( compgen -W '${COMPREPLY[@]} all' -- "$cur" ));
        return;
    fi;
    valid_options=$( update-initramfs -h 2>&1 | 		sed -e '/^ -/!d;s/^ \(-\w\+\).*/\1/' );
    COMPREPLY=($( compgen -W "$valid_options" -- $cur ))
}
function _upstart_events() 
{ 
    ( cd /etc/init && egrep --color=auto '^[[:space:]]*emits ' *.conf | cut -d: -f2- | sed 's/^[[:space:]]*emits //g' | tr ' ' '\n' | awk '{print $NF}' | grep --color=auto -P -v ^$ | sort -u )
}
function _upstart_initctl() 
{ 
    _get_comp_words_by_ref cur prev;
    COMPREPLY=();
    case "$prev" in 
        start)
            COMPREPLY=($(compgen -W "-n --no-wait $(_upstart_startable_jobs)" -- ${cur}));
            return 0
        ;;
        stop)
            COMPREPLY=($(compgen -W "-n --no-wait $(_upstart_stoppable_jobs)" -- ${cur}));
            return 0
        ;;
        emit)
            COMPREPLY=($(compgen -W "-n --no-wait $(_upstart_events)" -- ${cur}));
            return 0
        ;;
        -i | --ignore-events)
            for cmd in check-config;
            do
                cwords=${COMP_WORDS[@]##};
                filtered_cwords=${COMP_WORDS[@]##${cmd}};
                if [ "$filtered_cwords" != "$cwords" ]; then
                    COMPREPLY=($(compgen -W "$(_upstart_jobs)" -- ${cur}));
                    return 0;
                fi;
            done
        ;;
        -e | --enumerate)
            for cmd in show-config;
            do
                cwords=${COMP_WORDS[@]##};
                filtered_cwords=${COMP_WORDS[@]##${cmd}};
                if [ "$filtered_cwords" != "$cwords" ]; then
                    COMPREPLY=($(compgen -W "$(_upstart_jobs)" -- ${cur}));
                    return 0;
                fi;
            done
        ;;
        reload | restart)
            COMPREPLY=($(compgen -W "-n --no-wait $(_upstart_stoppable_jobs)" -- ${cur}));
            return 0
        ;;
        status)
            COMPREPLY=($(compgen -W "$(_upstart_jobs)" -- ${cur}));
            return 0
        ;;
        check-config)
            COMPREPLY=($(compgen -W "-w --warn -i --ignore-events= $(_upstart_jobs)" -- ${cur}));
            return 0
        ;;
        show-config)
            COMPREPLY=($(compgen -W "-e --enumerate $(_upstart_jobs)" -- ${cur}));
            return 0
        ;;
        -n | --no-wait)
            for cmd in start stop restart emit;
            do
                cwords=${COMP_WORDS[@]##};
                filtered_cwords=${COMP_WORDS[@]##${cmd}};
                if [ "$filtered_cwords" != "$cwords" ]; then
                    case "$cmd" in 
                        start)
                            COMPREPLY=($(compgen -W "$(_upstart_startable_jobs)" -- ${cur}))
                        ;;
                        stop)
                            COMPREPLY=($(compgen -W "$(_upstart_stoppable_jobs)" -- ${cur}))
                        ;;
                        restart)
                            COMPREPLY=($(compgen -W "$(_upstart_stoppable_jobs)" -- ${cur}))
                        ;;
                        emit)
                            COMPREPLY=($(compgen -W "$(_upstart_events)" -- ${cur}))
                        ;;
                    esac;
                    return 0;
                fi;
            done
        ;;
        --help | --version)
            COMPREPLY=();
            return 0
        ;;
    esac;
    opts="--help --version -q --quiet -v --verbose --session --system --dest=";
    cmds=$(initctl help|grep "^  [^ ]"|awk '{print $1}');
    COMPREPLY=($(compgen -W "${opts} ${cmds}" -- ${cur}))
}
function _upstart_jobs() 
{ 
    initctl list | awk '{print $1}' | sort -u
}
function _upstart_reload() 
{ 
    COMPREPLY=();
    _get_comp_words_by_ref cur prev;
    opts="--help --version -q --quiet -v --verbose --session --system --dest=";
    case "$prev" in 
        --help | --version)
            COMPREPLY=();
            return 0
        ;;
    esac;
    COMPREPLY=($(compgen -W "$opts $(_upstart_stoppable_jobs)" -- ${cur}));
    return 0
}
function _upstart_restart() 
{ 
    COMPREPLY=();
    _get_comp_words_by_ref cur prev;
    opts="--help --version -q --quiet -v --verbose --session --system --dest=         -n --no-wait";
    case "$prev" in 
        --help | --version)
            COMPREPLY=();
            return 0
        ;;
    esac;
    COMPREPLY=($(compgen -W "$opts $(_upstart_stoppable_jobs)" -- ${cur}));
    return 0
}
function _upstart_start() 
{ 
    COMPREPLY=();
    _get_comp_words_by_ref cur prev;
    opts="--help --version -q --quiet -v --verbose --session --system --dest=         -n --no-wait";
    case "$prev" in 
        --help | --version)
            COMPREPLY=();
            return 0
        ;;
    esac;
    COMPREPLY=($(compgen -W "$opts $(_upstart_startable_jobs)" -- ${cur}));
    return 0
}
function _upstart_startable_jobs() 
{ 
    initctl list | cut -d\, -f1 | awk '$2 == "stop/waiting" {print $1}'
}
function _upstart_status() 
{ 
    COMPREPLY=();
    _get_comp_words_by_ref cur prev;
    opts="--help --version -q -d --detail -e --enumerate --quiet -v --verbose --session --system --dest=";
    case "$prev" in 
        --help | --version)
            COMPREPLY=();
            return 0
        ;;
    esac;
    COMPREPLY=($(compgen -W "$opts $(_upstart_jobs)" -- ${cur}));
    return 0
}
function _upstart_stop() 
{ 
    COMPREPLY=();
    _get_comp_words_by_ref cur prev;
    opts="--help --version -q --quiet -v --verbose --session --system --dest=         -n --no-wait";
    case "$prev" in 
        --help | --version)
            COMPREPLY=();
            return 0
        ;;
    esac;
    COMPREPLY=($(compgen -W "$opts $(_upstart_stoppable_jobs)" -- ${cur}));
    return 0
}
function _upstart_stoppable_jobs() 
{ 
    initctl list | cut -d\, -f1 | awk '$2 == "start/running" {print $1}'
}
function _upvar() 
{ 
    if unset -v "$1"; then
        if (( $# == 2 )); then
            eval $1=\"\$2\";
        else
            eval $1=\(\"\${@:2}\"\);
        fi;
    fi
}
function _upvars() 
{ 
    if ! (( $# )); then
        echo "${FUNCNAME[0]}: usage: ${FUNCNAME[0]} [-v varname" "value] | [-aN varname [value ...]] ..." 1>&2;
        return 2;
    fi;
    while (( $# )); do
        case $1 in 
            -a*)
                [[ -n ${1#-a} ]] || { 
                    echo "bash: ${FUNCNAME[0]}: \`$1': missing" "number specifier" 1>&2;
                    return 1
                };
                printf %d "${1#-a}" &> /dev/null || { 
                    echo "bash:" "${FUNCNAME[0]}: \`$1': invalid number specifier" 1>&2;
                    return 1
                };
                [[ -n "$2" ]] && unset -v "$2" && eval $2=\(\"\${@:3:${1#-a}}\"\) && shift $((${1#-a} + 2)) || { 
                    echo "bash: ${FUNCNAME[0]}:" "\`$1${2+ }$2': missing argument(s)" 1>&2;
                    return 1
                }
            ;;
            -v)
                [[ -n "$2" ]] && unset -v "$2" && eval $2=\"\$3\" && shift 3 || { 
                    echo "bash: ${FUNCNAME[0]}: $1: missing" "argument(s)" 1>&2;
                    return 1
                }
            ;;
            *)
                echo "bash: ${FUNCNAME[0]}: $1: invalid option" 1>&2;
                return 1
            ;;
        esac;
    done
}
function _usb_ids() 
{ 
    COMPREPLY+=($( compgen -W         "$( PATH="$PATH:/sbin" lsusb | awk '{print $6}' )" -- "$cur" ))
}
function _user_at_host() 
{ 
    local cur prev words cword;
    _init_completion -n : || return;
    if [[ $cur == *@* ]]; then
        _known_hosts_real "$cur";
    else
        COMPREPLY=($( compgen -u -- "$cur" ));
    fi;
    return 0
}
function _usergroup() 
{ 
    if [[ $cur = *\\\\* || $cur = *:*:* ]]; then
        return;
    else
        if [[ $cur = *\\:* ]]; then
            local prefix;
            prefix=${cur%%*([^:])};
            prefix=${prefix//\\};
            local mycur="${cur#*[:]}";
            if [[ $1 == -u ]]; then
                _allowed_groups "$mycur";
            else
                local IFS='
';
                COMPREPLY=($( compgen -g -- "$mycur" ));
            fi;
            COMPREPLY=($( compgen -P "$prefix" -W "${COMPREPLY[@]}" ));
        else
            if [[ $cur = *:* ]]; then
                local mycur="${cur#*:}";
                if [[ $1 == -u ]]; then
                    _allowed_groups "$mycur";
                else
                    local IFS='
';
                    COMPREPLY=($( compgen -g -- "$mycur" ));
                fi;
            else
                if [[ $1 == -u ]]; then
                    _allowed_users "$cur";
                else
                    local IFS='
';
                    COMPREPLY=($( compgen -u -- "$cur" ));
                fi;
            fi;
        fi;
    fi
}
function _userland() 
{ 
    local userland=$( uname -s );
    [[ $userland == @(Linux|GNU/*) ]] && userland=GNU;
    [[ $userland == $1 ]]
}
function _valgrind() 
{ 
    local cur prev opts yesno tools choosen_tool;
    yesno="--trace-children\= --child-silent-after-fork\= --track-fds\= --time-stamp\= --log-fd\=  --log-socket\=";
    opts="--tool\= ";
    opts+="-h --help --help-debug --version -q --quiet -v --verbose --log-file\= ";
    COMPREPLY=();
    for ((i=0; i < ${#COMP_WORDS[@]}-1; i++ ))
    do
        if [[ ${COMP_WORDS[i]} == "--tool" ]]; then
            choosen_tool=${COMP_WORDS[i+2]};
        fi;
    done;
    case $choosen_tool in 
        'callgrind')
            opts+="--callgrind-out-file\= --dump-every-bb\= --dump-before\= --zero-before\= --dump-after\= --toggle-collect\= --separate-recs\= --separate-callers\= --fn-skip\= --fn-group< --separate-recs< --separate-callers< ";
            yesno+="--dump-instr\= --dump-line\= --compress-strings\= --compress-pos\= --combine-dumps\= --instr-atstart\= --collect-atstart\= --collect-jumps\= --separate-threads\= --skip-plt\= --simulate-cache\= --simulate-hwpref\= "
        ;;
        'cachegrind')
            opts+="--I1\= --D1\= --L2\= --cachegrind-out-file\= ";
            yesno+="--cache-sim\= --branch-sim\= "
        ;;
        'memcheck')
            yesno+="--undef-value-errors\= --track-origins\= --show-reachable\= --workaround-gcc296-bugs\= --partial-loads-ok\= ";
            opts+="--leak-check\= --leak-resolution\= --freelist-vol\= --malloc-fill\= --free-fill\= "
        ;;
        *)
            yesno+="--undef-value-errors\= --track-origins\= --show-reachable\= --workaround-gcc296-bugs\= --partial-loads-ok\= ";
            opts+="--leak-check\= --leak-resolution\= --freelist-vol\= --malloc-fill\= --free-fill\= "
        ;;
    esac;
    opts+="$yesno ";
    cur="${COMP_WORDS[COMP_CWORD]}";
    prev="${COMP_WORDS[COMP_CWORD - 1]}";
    if [[ "$prev" == "=" ]]; then
        prev="${COMP_WORDS[COMP_CWORD - 2]}";
    else
        if [[ "$cur" == "=" ]]; then
            cur="";
        fi;
    fi;
    if [[ "$prev" == "--tool" ]]; then
        tools="memcheck cachegrind callgrind massif helgrind lackey none drd exp-bbv exp-ptrcheck";
        COMPREPLY=($(compgen -W "$tools" -- $cur ));
        COMPREPLY+=" ";
        return 0;
    fi;
    if [[ "${yesno}" == *$prev* ]]; then
        COMPREPLY=($(compgen -W "yes no" -- $cur ));
        COMPREPLY+=" ";
        return 0;
    fi;
    case "$prev" in 
        --log-file)
            _filedir;
            return 0
        ;;
        *)

        ;;
    esac;
    if [[ "$cur" == -* ]]; then
        COMPREPLY=($(compgen -W "$opts" -- $cur));
        return 0;
    else
        _filedir;
        return 0;
    fi
}
function _variables() 
{ 
    if [[ $cur =~ ^(\$\{?)([A-Za-z0-9_]*)$ ]]; then
        [[ $cur == *{* ]] && local suffix=} || local suffix=;
        COMPREPLY+=($( compgen -P ${BASH_REMATCH[1]} -S "$suffix" -v --             "${BASH_REMATCH[2]}" ));
        return 0;
    fi;
    return 1
}
function _xfunc() 
{ 
    set -- "$@";
    local srcfile=$1;
    shift;
    declare -F $1 &> /dev/null || { 
        local compdir=./completions;
        [[ $BASH_SOURCE == */* ]] && compdir="${BASH_SOURCE%/*}/completions";
        . "$compdir/$srcfile"
    };
    "$@"
}
function _xinetd_services() 
{ 
    local xinetddir=/etc/xinetd.d;
    if [[ -d $xinetddir ]]; then
        local restore_nullglob=$(shopt -p nullglob);
        shopt -s nullglob;
        local -a svcs=($( printf '%s\n' $xinetddir/!($_backup_glob) ));
        $restore_nullglob;
        COMPREPLY+=($( compgen -W '${svcs[@]#$xinetddir/}' -- "$cur" ));
    fi
}
function add_find_dir() 
{ 
    if [[ -d $1 ]]; then
        echo "adding find directory $1..";
        echo "FIND_IN_EXTRAS+=\":$1\"" >> ~/.bashrc;
        FIND_IN_EXTRAS+=":$1";
    fi
}
function aliafun() 
{ 
    uses WARN;
    uses __isflag;
    case $# in 
        0)
            if __isflag ALIAFUN_USE_ALIAS_COMPATIBLE_LISTING; then
                WARN "Not yet available: ALIAFUN_USE_ALIAS_COMPATIBLE_LISTING";
            fi;
            declare -pf | perl -wen 'print if s/^\s+local\sALIAFUN_TAG=([^;]+)(;)/$1/'
        ;;
        1)
            set "${1%%=*}" "${1##*=}";
            eval "function $1() { local ALIAFUN_TAG=$1; $2; }"
        ;;
        *)
            for p in "$@";
            do
                aliafun "$p";
            done
        ;;
    esac
}
function alias() 
{ 
    if [[ $1 =~ (/|--?)(padd|premove) ]]; then
        case ${1##\/\-} in 
            padd)
                alias_add "$@";
                return $?
            ;;
            premove)
                alias_remove "$@";
                return $?
            ;;
        esac;
    fi;
    builtin alias "$@";
    return $?
}
function alias_add() 
{ 
    if [[ $2 == last ]]; then
        eval alias $1=`eval "history -p !"$[ HISTCMD-2 ]`;
    else
        if [[ $# -ge 2 ]] && [[ $2 -lt 1 || $2 -gt `histcount` ]]; then
            eval alias $1=\'${@: 2}\';
        else
            if [[ $# -ne 2 ]]; then
                echo "usage: alias_add [name] [alias-definition]";
                echo "	    alias_add [name] [valid history number]";
                echo "       alias_add [name] last";
                echo "       alias_add [name] last -[number-of-commands-ago]";
            else
                builtin alias $1=`history -p !$2`;
                builtin alias $1 >> ~/.bash_aliases;
            fi;
        fi;
    fi
}
function bindings() 
{ 
    __get_bindings
}
function bmenu() 
{ 
    for each in "$@";
    do
        [[ -z $each ]] && { 
            CRIT "Failing on EMPTY values cannot be passed to command line: $# (args=$@)";
            return 255
        };
    done;
    if [[ $# -le 1 ]]; then
        WARN "You MUST specify at least ONE menu item for there to be a menu!";
        INFO "A menu ${1+named \"$1\" }was requested, but there are no entries. Returning result as if CANCEL was pressed...";
        sleep 2;
        return 0;
    else
        declare caption="$1";
        shift;
        declare -A items;
        declare -A indicies;
        declare -i n=1;
        for i in "$@";
        do
            if [[ $i =~ ^[a-zA-Z_]+\|.+$ ]]; then
                name=${i%%|*};
                desc=${i##*|};
                items[$name]="$desc";
                indicies[$name]=$n;
                let n++;
            else
                WARN "While parsing in position $n, found invalid item: $i. [Items must be in the form of NAME(A-z_)|DESCRIPTION(^|)]";
            fi;
        done;
        [[ ${#indicies[@]} -lt 1 ]] && { 
            $FUNCNAME "$caption";
            return $?
        };
        local RESULTFILE RESULTFLAG RESULTITEM RESULTINDEX;
        RESULTFILE=$(mktemp);
        eval dialog --menu \""$caption"\" 0 0 0 `for k in ${!items[@]}; do echo -ne "$k" "\"${items[$k]}\" "; done` 2> $RESULTFILE;
        RESULTFLAG=$?;
        case $RESULTFLAG in 
            0)
                RESULTITEM=$(cat "$RESULTFILE");
                rm -f "$RESULTFILE";
                declare -gx BMENU_LAST_RESPONSE_ITEM=$RESULTITEM;
                RESULTINDEX=$(( ${indicies[$RESULTITEM]} ));
                declare -gxi BMENU_LAST_RESPONSE_INDEX=$RESULTINDEX;
                if [[ -v RESPONSE_TARGET ]]; then
                    if [[ -w "$RESPONSE_TARGET" ]]; then
                        DEBM "Response target was set to a writable file";
                        if [[ -s "$REPSONSE_TARGET" ]]; then
                            DEBM "The response target file is not empty, inserting a newline for the new record entry...";
                            echo -ne "\n" >> "$REPSONSE_TARGET";
                        fi;
                        echo -ne "$RESULTITEM::$RESULTINDEX" > "$RESPONSE_TARGET";
                        if (($?)); then
                            DEBM "The file $RESPONSE_TARGET was written to, the exit code ($?) was returned.";
                            DEBM "The operation succeeded";
                        else
                            WARN "The file $RESPONSE_TARGET attempted write, but failed with code ($?)";
                        fi;
                    else
                        eval "$REPSONSE_TARGET=$RESULTITEM";
                        DEBM "Response target refers to a variable name";
                    fi;
                    DEBM "Wrote: $RESULTITEM to $RESPONSE_TARGET";
                else
                    DEBM "RESPONSE_TARGET is not set, and will not be assigned to in any way";
                fi;
                return $RESULTINDEX
            ;;
            1)
                return 0
            ;;
            255)
                return 255
            ;;
        esac;
    fi
}
function bmenuif() 
{ 
    case $1 in 
        init)
            exec 7>&1;
            return 0
        ;;
        cleanup)
            exec 7> /dev/null;
            return 0
        ;;
    esac;
    if bmenu "$@" 1>&7; then
        echo $?;
    else
        echo 0;
    fi
}
function can_execute_x_progs() 
{ 
    xprop -root &> /dev/null
}
function cat_minus_line() 
{ 
    local -i RLINE=${1-0};
    head -n$(( RLINE -1 )) /home/gabriel/.bashrc;
    tail -n+$(( RLINE +1 )) ~/.bashrc
}
function cd() 
{ 
    if [[ -z $1 ]]; then
        command cd .;
        return $?;
    fi;
    function decho () 
    { 
        builtin echo "$@" > $(tty)
    };
    function echo () 
    { 
        true "$@";
        return $?
    };
    if [[ ${1: 0:1} == "@" ]]; then
        decho "guessing a switching to $1";
        if [[ $1 =~ @@.+ ]]; then
            PUSHMODE=1;
            TGT=${1: 2};
        else
            if [[ $1 =~ @.+ ]]; then
                TGT=${1: 1};
                PUSHMODE=0;
            else
                PUSHMODE=2;
            fi;
        fi;
        if [[ $PUSHMODE != 2 ]]; then
            decho "Target: $TGT";
            if locate -n1 "$TGT" &> /dev/null; then
                local LOC=`menu -vert $(locate "$TGT") '$RETRY_STR' '$CANCEL_STR'`;
                case "$LOC" in 
                    "$STR_RETRY")
                        decho -e "Attempting: $STR_RETRY ... (re-entering loop)";
                        cd "$@";
                        [[ $? -eq 0 ]] && return $(cd_cleanup);
                        decho "Failed Retry, Aborting";
                        cd_cleanup "$STR_RETRY" "$LOC";
                        return $?
                    ;;
                    "$CANCEL_STR")
                        decho -e "Cancelled!";
                        cd_cleanup "$CANCEL_STR" "$LOC";
                        return $?
                    ;;
                esac;
                decho -ne "Best Guess: $LOC";
                if [[ -d $LOC ]]; then
                    JMPLOC=$LOC;
                    decho " (directory)";
                else
                    JMPLOC=`dirname $LOC`;
                    JMPLOC=`realpath $JMPLOC`;
                    decho " (directory + file)";
                    if navshell "$LOC"; then
                        return 0;
                    else
                        decho "File $(basename $LOC) can't be navigated into, using it's parent directory: $JMPLOC";
                    fi;
                fi;
                [[ $PUSHMODE -eq 1 ]] && pushd . &> /dev/null;
                if builtin cd "$JMPLOC"; then
                    decho "Jump Ok";
                    cd .;
                    return 0;
                else
                    echo "Error ($?): $JMPLOC Inpenetrable, Passing Arguments Down The Line...";
                fi;
            else
                echo "Info: $TGT - no targets, handling $0 $*...";
            fi;
        fi;
    fi;
    if [[ $PERLCONSOLE_USESPECIALDIR -eq 1 ]]; then
        if [[ `realpath -s $* 2>&1` == "/perl-console" ]]; then
            perlconsole;
            echo "poping back to $PWD";
            return 0;
        fi;
    fi;
    if __isflag BASH_SPECIALDIR_APTSH && [[ "$(realpath -s $* 2>&1)" == "/apt" ]]; then
        echo "$PWD" > /tmp/lastdir.aptsh;
        xtitle "/apt (APT/DPKG Shell Interface)";
        sudo aptsh;
        local -i RETV=$?;
        if [[ $RETV == 12 ]]; then
            exit;
        else
            if [[ $RETV != 0 ]]; then
                cd /apt;
            fi;
        fi;
        local NEXTDIR="$(cat /tmp/lastdir.aptsh)";
        if [[ ! -z $NEXTDIR ]]; then
            cd /tmp;
            cd "$NEXTDIR";
        else
            echo "Notice: exited aptsh ungracefully, returning to previous directory!";
        fi;
        return 0;
    fi;
    if __isflag BASH_SPECIALDIR_GIT; then
        if [[ -n $GITDIR ]]; then
            OLDWD=$GITDIR;
        else
            OLDWD=NONE;
        fi;
        echo "LAST GIT DIR: $OLDWD";
        if builtin cd "$@" && RETCODE=$?; then
            echo "NEWWD: $PWD";
            echo "DIFWD: ${PWD#$OLDWD}";
            if [[ "$OLDWD" == "NONE" ]] || [[ "$PWD" == "${PWD#$OLDWD}" ]]; then
                echo "(changed into new parent)";
                if [[ -d .git ]] || parentshave .git; then
                    echo "(git dir detected)";
                    GITDIR="${PWD}";
                    INGIT=YES;
                else
                    echo "(git dir, not detected -- plain)";
                    INGIT=NO;
                    unset GITDIR;
                fi;
            else
                echo "(same root, no changes)";
                :;
            fi;
        else
            :;
        fi;
        case $INGIT in 
            YES)
                xtitle "$PWD (GIT Repository)";
                PS1=$PS1_GIT;
                PS2=$PS2_GIT;
                GITSPECIAL=SET;
                [[ $OLDGS != $INGIT ]] && source ~/.config/bashrc/shells/git/git.bashrcshell
            ;;
            NO)
                XTPWD="$PWD ";
                if parentshave .svn; then
                    XTPWD+="(SubVersion [svn] Tree Branch)";
                else
                    if parentshave .git; then
                        XTPWD+="(Git Repository Child)";
                    else
                        if parentshave .hg; then
                            XTPWD+="(Mercurial [hg] Tree Branch)";
                        else
                            if parentshave configure || parentshave configure.in || parentshave Makefile || parentshave automake; then
                                XTPWD+="(Generic SourceCode Tree)";
                            else
                                if parentshave vim-addons; then
                                    XTPWD+="(User's VIM Tree)";
                                else
                                    if parentshave mswin.vim; then
                                        XTPWD+="(System's VIM Tree)";
                                    fi;
                                fi;
                            fi;
                        fi;
                    fi;
                fi;
                xtitle "$XTPWD" > $(tty);
                if [[ $PWD != ${HOME} ]]; then
                    local -i XTCOLOR=${#PWD};
                    case $XTCOLOR in 
                        0 | 4 | 8 | 16 | 17 | 18 | 18 | 20 | 21 | 22 | 23 | 24)
                            ((XTCOLOR+=24))
                        ;;
                    esac;
                    PS1='\[[38;5;'${XTCOLOR}'m\]'"$PS1_NORMAL"'\[[0m\]';
                    PS2='\[[38;5;'${XTCOLOR}'m\]'"$PS2_NORMAL"'\[[0m\]';
                else
                    [[ $UID -eq 0 ]] && ROOTUSER="#" || ROOTUSER="$";
                    declare HOMEPROMPT="$USER@$HOSTNAME $PWD ${ROOTUSER}";
                    declare HOMEPROMPT_RB='\[[0m\]';
                    declare HOMEPROMPT_RB_P2='\[[0m\]';
                    declare -i m=0;
                    for ((k=0; k<${#HOMEPROMPT}; k++))
                    do
                        HOMEPROMPT_RB+='\['"[38;5;$(( (k + $Kofs) * $Kmul | $Korf ))m"'\]'"${HOMEPROMPT: $k:1}";
                        if [[ $k -lt ${#PS2_NORMAL} ]]; then
                            HOMEPROMPT_RB_P2+="\[[38;5;$(( (k + $Kofs) * $Kmul | $Korf ))m\]${PS2_NORMAL: $k:1}";
                        fi;
                    done;
                    PS1="${HOMEPROMPT_RB}\[[0m\] ";
                    PS2="${HOMEPROMPT_RB_P2}\[[0m\] ";
                fi;
                GITSPECIAL=UNSET;
                [[ $OLDGS != $INGIT ]] && source ~/.config/bashrc/shells/git/git.bashrcshell
            ;;
        esac;
        OLDGS=$INGIT;
    fi;
    unset -f echo;
    unset -f decho;
    return $RETCODE
}
function choice() 
{ 
    if __isflag ALLOW_CHOICEFILE; then
        if [ -r "$CHOICEFILE" ]; then
            CHOICEPROMPT=`cat $CHOICEFILE`;
        fi;
    fi;
    if [ -z "$CHOICEPROMPT" ] && [ "$1" ] && [ ! -r "$CHOICEFILE" ]; then
        CHOICEPROMPT="$*";
    fi;
    if ( tty -s ); then
        if [ ! -z "$CHOICEPROMPT" ]; then
            echo -n "$CHOICEPROMPT";
        else
            if [ -r "$CHOICEFILE" ]; then
                echo "${CHOICETITLE:-Proceed with this action?}";
                cat "$CHOICEFILE";
                echo "[Y=${CHOICEYESTXT:Yes} N=${CHOICENOTXT:No}]";
            else
                echo "[Y/N]?";
            fi;
        fi;
        unset REPLY;
        while [ "${REPLY^^}" != "Y" ] && [ "${REPLY^^}" != "N" ]; do
            read -sn1;
        done;
        if [ "${REPLY^^}" == "Y" ]; then
            true;
            return 0;
            ( exit 0 );
        else
            false;
            return 1;
            ( exit 1 );
        fi;
    else
        if [ ! -z "$CHOICEFILE" ]; then
            zenity --text-info --title="${CHOICETITLE:-Do you wish to perform this action?}" --ok-label="${CHOICEYESTXT:-Yes}" --cancel-label="${CHOICENOTXT:-No}" --file-selection "${CHOICEFILE}";
            return $?;
        else
            if [ -z "$CHOICEPROMPT" ]; then
                CHOICEPROMPT="Do you wish to perform this action?";
            fi;
        fi;
        zenity --question --text="$CHOICEPROMPT";
        return $?;
    fi
}
function chrome() 
{ 
    command chrome "$@" & disown
}
function colorcat() 
{ 
    command cat "$@" | colorit
}
function command_not_found_handle() 
{ 
    __bashrc_ext_command_not_found_handler "$@"
}
function coproc() 
{ 
    builtin coproc "$@" &> /dev/null;
    LAST_COPROC_PID=`jobs -p | grep -Po '[0-9]{3,32}'`;
    disown;
    echo "Started `which $*` : $LAST_COPROC_PID [detached]"
}
function declare_prevalent() 
{ 
    PREVALENT_NAME="$1";
    shift;
    eval "
	function ${PREVALENT_NAME}()
	{
		implement_prevalent ${PREVALENT_NAME}_stub \"\$@\"
	}"
}
function defined() 
{ 
    local searchkinds=(alias binding command disabled export function helptopic job running setopt signal user arrayvar builtin directory enabled file group hostname keyword service shopt stopped variable);
    if [[ $# -eq 1 ]] && [[ $1 == "list-kinds" ]]; then
        echo "The following values are acceptable for the KIND parameter:";
        echo;
        eval `resize`;
        echo "${searchkinds[@]}" | tr ' ' '\n' | column -c $COLUMNS;
        echo "";
        echo "${#searchkinds[@]} kind(s)";
        echo "";
        return 1;
    else
        if [[ $# -eq 1 ]]; then
            defined any "$@";
            return $?;
        else
            if [[ $# -ne 2 ]] || [[ $# -eq 1 && $1 == "--help" ]]; then
                echo "usage: $FUNCNAME [kind] [name]";
                echo "       $FUNCNAME [list-kinds]";
                echo "       $FUNCNAME [symbol]";
                echo "";
                echo "OPTIONS";
                echo "The second form will give you a list of items that are acceptable for the 'kind' parameter in the first.";
                echo "The third form will cause the symbol name to be guessed in the order of list-kinds";
                return 1;
            fi;
        fi;
    fi;
    local kind="$1";
    local name="$2";
    local FOUNDKIND=0;
    for item in "${searchkinds[@]}" any;
    do
        if [[ $item == $kind ]]; then
            FOUNDKIND=1;
        fi;
    done;
    if [[ $FOUNDKIND -ne 1 ]]; then
        echo "[1mError: kind \"$kind\" is not allowed![0m";
        defined list-kinds;
        return 1;
    fi;
    if [[ $kind == "any" ]]; then
        local searchitems=(`compgen -A ${searchkinds[@]}`);
    else
        local searchitems=(`compgen -A $kind`);
    fi;
    for item in "${searchitems[@]}";
    do
        if [[ "$item" == "$name" ]]; then
            return 0;
        fi;
    done;
    return 1
}
function dequote() 
{ 
    eval printf %s "$1" 2> /dev/null
}
function dialog() 
{ 
    if [[ $1 == "--help" ]]; then
        cat  <<EOF
cdialog (ComeOn Dialog!) version 1.2-20130928
Copyright 2000-2012,2013 Thomas E. Dickey
This is free software; see the source for copying conditions.  There is NO
warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.

* Display dialog boxes from shell scripts *

Usage: dialog <options> { --and-widget <options> }
where options are "common" options, followed by "box" options

Special options:
  --create-rc "file"		Dump a sample configuration file to "file"

Common options:
  --ascii-lines                 Rather than draw graphics lines around boxes, draw ASCII "+" and "-" in the same place.
  --aspect <ratio>              Number of characters wide to every line. Default value is 9 (9 chars wide for every line).
  --backtitle <backtitle>       Specifies a backtitle string to be displayed on the backdrop, at the top of the screen.
  --beep                        (obsolete) Beep when the separate process of tailboxbg widget repaints the screen.
  --beep-after                  (obsolete) Beep after a user completed a widget by pressing one of the buttons.
  --begin <y> <x>               Specify the position of the upper left corner of a dialog box on the screen.
  --cancel-label <str>          Override the label for the "Cancel" buttons.
  --clear                       Clears the widget screen keeping the screen_color background. Use with the "and widget" flag.
  --colors                      Translate \Z0-\Z7 to colors, \Zr to reset, \Zb for bold or \Zn to normal (default) color.
  --column-separator <str>      Tell dialog to split data for radio/checkboxes and menus on the occurrences of the given string
  --cr-wrap                     Interpret embedded newlines in the dialog text as a newline on the screen.
  --date-format <str>           specify the format of the date printed for the calendar widget if  the  host provides strftime.
  --default-button <str>        Set the button for the user to press Enter to proceed through a dialog with minimum interaction.
  --default-item <str>          Set the default item in a checklist, form or menu box.
  --defaultno                   Make the default value of the yes/no box a No.
  --exit-label <str>            Override the label used for "EXIT" buttons.
  --extra-button                Show an extra button, between "OK" and "Cancel" buttons.
  --extra-label <str>           Override the label used for "Extra" buttons. For inputmenu defaults to "Rename".
  --help-button                 Shows a help button after OK and Cancel. If used returns output token HELP. See item-help flag. 
  --help-label <str>            Overrides the label used for help buttons.
  --help-status                 If the help-button is selected, writes the checklist, radiolist or form information after the item-help "HELP" information.
  --help-tags                   Modify  the  messages written on exit for [help-button] by making them always just the item's tag.
  --hfile <str>                 Display the given file using a textbox when the user presses F1.
  --hline <str>                 Display the given string centered at the bottom of the widget.
  --ignore                      Ignore options that dialog does not recognize.
  --input-fd <fd>               Read keyboard input from the given file descriptor. The default is /dev/stdin.
  --insecure                    Makes the password widget friendlier but less secure, by echoing asterisks for each character.
  --item-help                   Interpret the tags data for check, radio and menu boxes adding a column which is displayed in the bottom line.
  --keep-tite                   Does not keep initializing the same xterm alt screen on consecutive runs, if available.
  --keep-window			Do not erase this widget when it becomes inactive (finishes).
  --last-key                    Report last keyboard key entered via the 'curses keycode'.
  --max-input <n>               Limit input strings to a given size (in <n>, naturally).
  --no-cancel                   Suppress the cancel button in dialogs that use it.
  --no-collapse                 disable converting tabs to spaces and reduction of multiple spaces to single spaces, etc.
  --no-cr-wrap                  
  --no-items
  --no-kill
  --no-label <str>
  --no-lines
  --no-mouse
  --no-nl-expand
  --no-ok
  --no-shadow
  --no-tags
  --nook
  --ok-label <str>
  --output-fd <fd>
  --output-separator <str>
  --print-maxsize
  --print-size
  --print-version
  --quoted
  --scrollbar
  --separate-output
  --separate-widget <str>
  --shadow
  --single-quoted
  --size-err
  --sleep <secs>
  --stderr
  --stdout
  --tab-correct
  --tab-len <n>
  --time-format <str>
  --timeout <secs>
  --title <title>
  --trace <file>
  --trim
  --version
  --visit-items
  --yes-label <str>
Box options:
  --buildlist    <text> <height> <width> <tag1> <item1> <status1>...
  --calendar     <text> <height> <width> <day> <month> <year>
  --checklist    <text> <height> <width> <list height> <tag1> <item1> <status1>...
  --dselect      <directory> <height> <width>
  --editbox      <file> <height> <width>
  --form         <text> <height> <width> <form height> <label1> <l_y1> <l_x1> <item1> <i_y1> <i_x1> <flen1> <ilen1>...
  --fselect      <filepath> <height> <width>
  --gauge        <text> <height> <width> [<percent>]
  --infobox      <text> <height> <width>
  --inputbox     <text> <height> <width> [<init>]
  --inputmenu    <text> <height> <width> <menu height> <tag1> <item1>...
  --menu         <text> <height> <width> <menu height> <tag1> <item1>...
  --mixedform    <text> <height> <width> <form height> <label1> <l_y1> <l_x1> <item1> <i_y1> <i_x1> <flen1> <ilen1> <itype>...
  --mixedgauge   <text> <height> <width> <percent> <tag1> <item1>...
  --msgbox       <text> <height> <width>
  --passwordbox  <text> <height> <width> [<init>]
  --passwordform <text> <height> <width> <form height> <label1> <l_y1> <l_x1> <item1> <i_y1> <i_x1> <flen1> <ilen1>...
  --pause        <text> <height> <width> <seconds>
  --prgbox       <text> <command> <height> <width>
  --programbox   <text> <height> <width>
  --progressbox  <text> <height> <width>
  --radiolist    <text> <height> <width> <list height> <tag1> <item1> <status1>...
  --rangebox     <text> <height> <width> <min-value> <max-value> <default-value>
  --tailbox      <file> <height> <width>
  --tailboxbg    <file> <height> <width>
  --textbox      <file> <height> <width>
  --timebox      <text> <height> <width> <hour> <minute> <second>
  --treeview     <text> <height> <width> <list-height> <tag1> <item1> <status1> <depth1>...
  --yesno        <text> <height> <width>

Auto-size with height and width = 0. Maximize with height and width = -1.
Global-auto-size if also menu_height/list_height = 0.
EOF

    else
        command dialog --backtitle 'General Extended Bourne Again Shell Extensions' "$@";
    fi
}
function eb() 
{ 
    while ! bmenu "Edit Bash Configuration" "rc|Main Configuration File" "aliases|Aliases" "completion|Completion" "dircolors.db|DirectoryColors" "git|GIT Integration" "hash|Hashtable" "helpers|Helpers" "history|History*" "logout|Logout" "settings|User Settings" "vars|User Variables" "xopen|X-Open All Files" "setup|Bash Setup Program	(Except This Menu)"; do
        case $BMENU_LAST_RESPONSE_ITEM in 
            rc)
                declare -ag EDITOR_FILE=(~/.bashrc)
            ;;
            xopen)
                declare -ag EDITOR_FILE=(~/.bashrc ~/.bash_!(*.swp))
            ;;
            setup)
                declare -ag EDITOR_FILE=(~/.config/bashrc/data/setup-bashrc)
            ;;
            *)
                declare -ag EDITOR_FILE=(~/.bash_$BMENU_LAST_RESPONSE_ITEM)
            ;;
        esac;
        for i in "${EDITOR_FILE[@]}";
        do
            if [[ ! -r $i && -w $(dirname $i) ]]; then
                if dialog.yesno "File $i does not exist, create a new one?"; then
                    maketemplate.sh;
                    HINT "You can edit the templates in the.";
                else
                    WARN "$i doesn't exist, but is still in the list, vim will create it for you if you save it";
                fi;
            fi;
        done;
        vim "${EDITOR_FILE[@]}";
    done;
    clear;
    DETA "Configuration Complete"
}
function find_in_path() 
{ 
    if [[ -z $1 ]]; then
        return 1;
    else
        if [[ ${1: 0:1} == "-" ]]; then
            return 1;
        fi;
    fi;
    local OLDIFS="$IFS";
    export IFS=":";
    local OLDPATH="$PATH";
    export PATH="$PWD:$PATH${FIND_IN_EXTRAS+:$FIND_IN_EXTRAS}";
    local -i RETV=1;
    for x in $PATH;
    do
        if [[ -f ${x}/$1 ]]; then
            echo ${x}/$1;
            RETV=0;
            break;
        fi;
    done;
    export PATH="$OLDPATH";
    export IFS="$OLDIFS";
    return $RETV
}
function firefox() 
{ 
    command firefox "$@" & disown
}
function fsdata_commit() 
{ 
    slice_func fsdata_commit_stub;
    fsdata_commit_stub "$@"
}
function fsdata_commit_stub() 
{ 
    local FSDIR="${BASH_CONFIG_DIRS[faststart]}";
    mkdir --parents "$FSDIR" &> /dev/null;
    if [[ ! -d "$FSDIR" ]]; then
        CRIT "$FSDIR cannot be created/used";
        (($?)) && return $? || return 1;
    fi;
    DETA "Using directory $FSDIR for snapshots";
    HINT "Use fsdata_load to reload the last snapshot data manually";
    DEBM "$? Exporting Shell Options";
    { 
        shopt -p;
        shopt -o -p
    } > ${FSDIR}/fscache_.bash_1;
    DEBM "$? Exporting Variables";
    declare -p > ${FSDIR}/fscache_.bash_2;
    DEBM "$? Exporting Function Table";
    declare -pf | sed -r 's/^(\S+)\s+\(\)/function \1()/g' > ${FSDIR}/fscache_.bash_3;
    DEBM "$? Exporting Programmable Completion Assignments";
    complete > ${FSDIR}/fscache_.bash_4;
    HASH
}
function fsdata_load() 
{ 
    echo "in development (not available yet)"
}
function git_item_help() 
{ 
    local _git_pager=$(git config core.pager);
    if [ $# = 1 ]; then
        git help $1;
    else
        ( _help_display | ${_git_pager:-${PAGER:-less}} );
    fi
}
function gitalias() 
{ 
    local alias="${1%%=*}" command="${1#*=}";
    local prog="${command##git }";
    prog="${prog%% *}";
    alias $alias="$command";
    gitcomplete "$alias" "$prog"
}
function gitcomplete() 
{ 
    local alias="$1" command="$2";
    complete -o default -o nospace -F _git_${command//-/_} $alias
}
function gitgui() 
{ 
    git gui &
}
function histcount() 
{ 
    local r=`history | tail -n-1 | grep -P '^\s*\d+' -o | tr -d ' '`;
    return $r
}
function idleprio() 
{ 
    if [[ $1 == -p ]]; then
        shift;
        sudo schedtool -D -n 20 "$@";
        sudo ionice -c 3 -p "$@";
    else
        sudo schedtool -D -n 20 -e ionice -c 3 "$@";
    fi
}
function implement_prevalent() 
{ 
    PREVALENTFUNC="$1";
    shift;
    if slice_func "$PREVALENTFUNC"; then
        "$PREVALENTFUNC" "$@";
        return $?;
    else
        echo "$(date +"%H:%M:%S") error [$BASH_SOURCE:$FUNCNAME:$(caller)]: could not execute prevalant function \"$1\" on line $LINENO";
        return 253;
    fi
}
function in_array() 
{ 
    local i;
    for i in "${@:2}";
    do
        [[ $1 = "$i" ]] && return;
    done
}
function install() 
{ 
    local RETV=$?;
    if ! __isflag DISABLE_SUPERCMD_INSTALL; then
        DEBM "install: supercmd disabled (DISABLE_SUPERCMD_INSTALL), running install normally [per session notice!]";
        HINT "unset the DISABLE_SUPERCMD_INSTALL before first call to use this feature again";
        command install "$@";
        RETV=$?;
        unset -f $FUNCNAME;
        DEBM "DISABLE_SUPERCMD_INSTALL: install returned $RETV, and UNSETTING install(), install will run directly for the remainder of this session!";
        HINT "(disable debug messages by unsetting ENABLE_DEBUG_MESSAGES or setting it to \"0\", or manipulating it's flag)";
        return $RETV;
    else
        if [[ "$BASH_SOURCE" == "" && -n "${#BASH_SOURCE[@]}" ]]; then
            DETA "BASH_SOURCE defined, which means this is a script, passing to regular program 'install'";
            command install "$@";
        else
            DETA "install called by user directly, using sc install...";
            INFO "$(date) $SECONDS Checking for valid apt-get install command line...";
            local S1=$SECONDS;
            if sudo apt-get install -s "$@" &> /dev/null; then
                INFO "Command Completed OK, Proceeding with Install [follow prompts as needed]...";
                sudo apt-get install "$@";
            else
                WARN "not a valid command line for apt-get, passing it to 'install'...";
                if ! command install "$@"; then
                    CRIT "Not a valid install command either, the return code was: $?";
                else
                    INFO "install command: success ($?)";
                fi;
            fi;
            local S2=$SECONDS;
            INFO "$(date) $SECONDS Installer Cycle Completed in $[ $S2 - $S1 ] second(s).";
        fi;
        RETV=$?;
        DEBM "Finished handler install($RETV)";
        return $RETV;
    fi
}
function isosched() 
{ 
    if [[ $1 == -p ]]; then
        shift;
        sudo schedtool -I -n -20 "$@";
        sudo ionice -c 2 -n 0 -p "$@";
    else
        sudo schedtool -I -n -20 -e ionice -c 2 -n 0 "$@";
    fi
}
function komodo() 
{ 
    command komodo "$@" > /dev/null 2>&1 & disown
}
function loadprs() 
{ 
    if [[ -z $1 ]]; then
        declare -a ITEMS=(`for i in ~/.config/bashrc/ps1colors/*; do basename "$i"; done`);
        if [[ ${#ITEMS} -lt 2 ]]; then
            echo "ERROR: Preset directory needs at least 2 entries (the RESET entry and 1 preset)!";
            echo -ne "Reset? ";
            if choice; then
                Korf=0;
                Kmul=0;
                Kofs=0;
                cd .;
                echo -e "\nReset Complete";
                return;
            else
                echo -e "\nReset Cancelled";
            fi;
        fi;
        LOADPRS=`menu "${ITEMS[@]}"`;
        echo -ne "[2K[0G[0m";
    else
        LOADPRS="$1";
    fi;
    if mapfile PRSLNS < ~/.config/bashrc/ps1colors/"$LOADPRS"; then
        if [[ ${PRSLNS[0]} != PRS100 ]] && [[ ${PRSLNS[4]} != END ]]; then
            echo "Failure: this is NOT a ps1 preset file! please delete invalid files from the presets!";
        else
            Kmul=${PRSLNS[1]};
            Korf=${PRSLNS[2]};
            Kofs=${PRSLNS[3]};
            cd .;
            printf "$LOADPRS" > ~/.config/bashrc/ps1colors.selection;
            echo "* Loaded $LOADPRS Home Colorscheme [configuration written to disk]";
        fi;
    else
        echo "Error $?: Failed to load $LOADPRS";
    fi
}
function makebashtags() 
{ 
    DEBM "Checking for tagfile command line option";
    touch "$1";
    if [[ -w $1 ]]; then
        DEBM "Using $1 for tagfile.. dont forget to change it in .bashrc!!";
        HINT "the tags are put on the modeline!";
    else
        set -- ~/tags;
        DEBM "Using default tagfile '~/.tags'";
    fi;
    INFO "Recreating tag database in $1 ...";
    if [[ -d $GXBASE_ROOT ]] && dialog --yesno "Use gxbase locations as well?" 0 0; then
        declare -a EXTRA_LOCS=($GXBASE_ROOT/gxbase $GXBASE_ROOT/core/* $GXBASE_ROOT/res/*);
    else
        declare -a EXTRA_LOCS=("");
    fi;
    INFO "gxbase xtra locations added: ${#EXTRA_LOCS[@]}";
    if /usr/bin/ctags-exuberant -f "$BASH_CTAGS_FILE" --language-force=sh "${BASH_CTAGS_INC[@]}" "${EXTRA_LOCS[@]}"; then
        DEBM "ctags exit code=$?";
        INFO "ctags completed making file ($(stat --format="%s" $1))";
        HINT "add \"vim:tags=$1\" to your .bashrc and other scripts (or insert to existing line)";
        return 0;
    else
        INFO "ctags failed to complete process ($?)";
        HINT "verify you have access to the bash system files located in /etc and /usr/share/bash-completion!";
        return 1;
    fi;
    CRIT "unreachable instruction reached. This usually means a serious bug (or more likely) hardware or power failure.";
    WARN "waiting for <ENTER>";
    read;
    return 254
}
function makeprs() 
{ 
    shopt -s extglob;
    local UIMENU='/g/b/menu';
    local ADJ=Knone;
    clear;
    setterm -cursor off;
    stty -echo;
    while ( true ); do
        echo -ne "[0;0H";
        cd .;
        echo $PS1 | sed --regexp-extended 's/\\(\[|\])//g';
        echo "";
        printf "Multiplier Orfactor Offset\n";
        printf "%05d\t%05d\t%06d\n" $Kmul $Korf $Kofs;
        printf "%05s\t%05s\t%06s\n" "UP/DN" "<-\->" "PUP/DN";
        printf "  KEY\t[END]\tQUITS";
        read -sn3;
        case $REPLY in 
            $Left)
                ((Korf--))
            ;;
            $Right)
                ((Korf++))
            ;;
            $Up)
                ((Kmul++))
            ;;
            $Down)
                ((Kmul--))
            ;;
            $PgUp)
                ((Kofs++));
                read -sn1
            ;;
            $PgDn)
                ((Kofs--));
                read -sn1
            ;;
            $Home)
                shufflehome
            ;;
            $End)
                setterm -cursor on;
                stty echo;
                echo -e "\nAborted\n";
                REPLY=`menu SAVE NOSAVE`;
                case $REPLY in 
                    SAVE)
                        printf "\nPreset Name: ";
                        read PRSNAME;
                        [[ ! -d ~/.config/bashrc/ps1colors ]] && mkdir --parents ~/.config/bashrc/ps1colors;
                        printf "PRS\n$Kmul\n$Korf\n$Kofs\nEND" > ~/.config/bashrc/ps1colors/$PRSNAME;
                        printf "\nSaved.\n"
                    ;;
                    NOSAVE)
                        printf "\nSkipped Save:\n";
                        printf "\nYou can save it later manually by re-entering and not changing anything.\n"
                    ;;
                esac;
                return
            ;;
        esac;
    done
}
function makerandomlscolorsdb() 
{ 
    unset USETRUE USE256 USE8 DOBG;
    [[ $1 == TRUE ]] && local USETRUE=1;
    [[ $1 == 256 ]] && local USE256=1;
    [[ $1 == 8 ]] && local USE8=1;
    [[ $2 == BG ]] && local DOBG=1;
    local BACKUPFILE=$(tempfile --suffix=dircolors.backupdb);
    echo "Backing up the old database in $BACKUPFILE...";
    declare -g DIRCOLORS_DBFILE="$HOME/.bash_dircolors.db";
    declare -g DIRCOLORS_SRC="$HOME/.bash_dircolors";
    touch $DIRCOLORS_DBFILE;
    touch $DIRCOLORS_SRC;
    if mv $DIRCOLORS_DBFILE $BACKUPFILE; then
        echo "Creating database, please wait a minute...";
        dircolors -p | sed 's/# .*//g;s/#//g' | tr -s '\n' > $DIRCOLORS_SRC;
        [[ -r $DIRCOLORS_SRC ]] && echo "$DIRCOLORS_SRC verfied existing";
        if [[ -n $USETRUE ]]; then
            [[ -n $DOBG ]] && perl -e 'for (<>) { unless (/^TERM/ || /^\s*$/) { s/^(\S+)(.*)$/\1/g; chomp; printf "%s 38;2;%d;%d;%d;48;2;%d;%d;%d\n",$_,int(rand(255)),int(rand(255)),int(rand(255)),int(rand(255)),int(rand(255)),int(rand(255)) } else { print } }' $DIRCOLORS_SRC > $DIRCOLORS_DBFILE;
            [[ -n $DOBG ]] || perl -e 'for (<>) { unless (/^TERM/ || /^\s*$/) { s/^(\S+)(.*)$/\1/g; chomp; printf "%s 38;2;%d;%d;%d\n",$_,int(rand(255)),int(rand(255)),int(rand(255)) } else { print } }' $DIRCOLORS_SRC > $DIRCOLORS_DBFILE;
        else
            if [[ -n $USE8 ]]; then
                [[ -n $DOBG ]] || perl -e 'for (<>) { unless (/^TERM/ || /^\s*$/) { s/^(\S+)(.*)$/\1/g; chomp; printf "%s %d;%d;%d\n",$_,int(rand(2)),int(rand(8))+30,int(rand(8))+40 } else { print } }' $DIRCOLORS_SRC > $DIRCOLORS_DBFILE;
                [[ -n $DOBG ]] && perl -e 'for (<>) { unless (/^TERM/ || /^\s*$/) { s/^(\S+)(.*)$/\1/g; chomp; printf "%s %d;%d\n",$_,int(rand(2)),int(rand(8))+30 } else { print } }' $DIRCOLORS_SRC > $DIRCOLORS_DBFILE;
            else
                [[ -n $DOBG ]] && perl -e 'for (<>) { unless (/^TERM/ || /^\s*$/) { s/^(\S+)(.*)$/\1/g; chomp; printf "%s 38;5;%d;48;5;%d\n",$_,int(rand(255))+1,int(rand(255))+1 } else { print } }' $DIRCOLORS_SRC > $DIRCOLORS_DBFILE;
                [[ -n $DOBG ]] || perl -e 'for (<>) { unless (/^TERM/ || /^\s*$/) { s/^(\S+)(.*)$/\1/g; chomp; printf "%s 38;5;%d\n",$_,int(rand(255))+1 } else { print } }' $DIRCOLORS_SRC > $DIRCOLORS_DBFILE;
            fi;
        fi;
        rm $DIRCOLORS_SRC;
        eval "$(dircolors -b $DIRCOLORS_DBFILE)";
        echo "Done.";
    else
        echo "Could not create backup, aborted (check permissions to $(dirname $BACKUPFILE))!";
    fi
}
function makerandomlscolorsdb_256() 
{ 
    makerandomlscolorsdb 256
}
function makerandomlscolorsdb_256_bg() 
{ 
    makerandomlscolorsdb 256 BG
}
function makerandomlscolorsdb_8() 
{ 
    makerandomlscolorsdb 8
}
function makerandomlscolorsdb_8_bg() 
{ 
    makerandomlscolorsdb 8 BG
}
function makerandomlscolorsdb_true() 
{ 
    makerandomlscolorsdb TRUE
}
function makerandomlscolorsdb_true_bg() 
{ 
    makerandomlscolorsdb TRUE BG
}
function needs() 
{ 
    until false; do
        if declare -pf "$1" &> /dev/null; then
            return 0;
        else
            case $2 in 
                outright)
                    slice_func "$1";
                    return 0
                ;;
                passive)
                    return 1
                ;;
                repugnant)
                    echo "Not Found: $1 ($2 failure, check your source(s)";
                    read -p "[A] $ABORT_STR [R] $RETRY_STR ${RESTART_LOOP+[ # $RESTART_LOOP ]} [I] $IGNORE_STR" -sn1 ARI;
                    case $ARI in 
                        A)
                            exit 251;
                            return 251
                        ;;
                        I)
                            echo "WARNING: instruction need($*) continuing ignored, program WILL have errors! [press a key]";
                            read -sn1 DISCARD;
                            return 0
                        ;;
                    esac
                ;;
            esac;
        fi;
    done
}
function parentshave() 
{ 
    declare -ig PARENTSHAVE_DEPTH_TO_TARGET=-1;
    declare -g PARENTSHAVE_TARGET="";
    builtin pushd . &> /dev/null;
    while [[ $PWD != "/" ]]; do
        let PARENTSHAVE_DEPTH_TO_TARGET++;
        if [[ -d "$1" ]]; then
            PARENTSHAVE_TARGET="$PWD";
            popd &> /dev/null;
            return 0;
        else
            builtin cd ..;
        fi;
    done;
    unset PARENTSHAVE_TARGET;
    builtin popd &> /dev/null;
    return 1
}
function prevlalent_function() 
{ 
    eval "function ${1}_stub"
}
function quote() 
{ 
    local quoted=${1//\'/\'\\\'\'};
    printf "'%s'" "$quoted"
}
function quote_readline() 
{ 
    local quoted;
    _quote_readline_by_ref "$1" ret;
    printf %s "$ret"
}
function rem_find_dir() 
{ 
    if [[ -d $1 ]]; then
        echo "removing find directory $1..";
        if ENTRYNO=$(grep -Poison "FIND_IN_EXTRAS\+=:$1" ~/.bashrc | grep -Poiso "^\d+"); then
            echo "found entry #$ENTRYNO, removing";
            cat_minus_line $ENTRYNO ~/.bashrc > .bashrc.tmp;
            mv ~/.bashrc /tmp/bashrc_rem_find_dir.tmp;
            mv ~/.bashrc.tmp ~/.bashrc;
        fi;
    fi
}
function select_prs() 
{ 
    loadprs "$@";
    return $?
}
function sessf() 
{ 
    [[ -z $1 ]] && { 
        echo "Need a command!";
        return 1
    };
    case $1 in 
        del)
            CMD=rm;
            ARG=$2
        ;;
        add)
            CMD=touch;
            ARG=$2
        ;;
        list)
            CMD="ls -C1";
            ARG='*'
        ;;
        query)
            CMD="test -r";
            ARG=$2
        ;;
        *)
            echo "Invalid command: $1, ${2+Args=}$2]";
            return 124
        ;;
    esac;
    $CMD ~/.config/bashrc/flags/${ARG}_SESSION;
    return $?
}
function set() 
{ 
    if [[ "$*" == "--help" ]]; then
        help $FUNCNAME;
        return 1;
    fi;
    echo "`caller` has called set with: $@";
    BASH_SET_STACK+=("$*");
    builtin set "$@";
    return $?
}
function setup-bashrc() 
{ 
    if ! which dialog &> /dev/null; then
        echo "The setup program requires the 'dialog' package, which you do not have. Please install dialog to use this feature!";
    else
        trap DEBUG;
        trap : SIGTSTP;
        trap : SIGSTOP;
        trap : SIGINT;
        trap 'setup-bashrc-cleanup' SIGKILL;
        test -r ~/.config/bashrc/shells/setup.bashshell && source ~/.config/bashrc/shells/setup.bashshell;
        defined function setup-bashrc-cleanup && setup-bashrc-cleanup;
    fi
}
function setup_progvars() 
{ 
    local -r ARG_COUNT=$#;
    eval set \"\${1..4}\";
    local -r VAR_NAME="$1";
    local -r VAR_LIST_OF_POSSIBLE_PROGNAMES="$2";
    local -r FLAG_OVERRIDE="$3";
    local -r FLAG_OVERRIDE_TARGET=`which $4`;
    case $ARG_COUNT in 
        4)
            if [[ -r ~/.config/bashrc/flags/$FLAG_OVERRIDE ]]; then
                if [[ -x $FLAG_OVERRIDE_TARGET ]]; then
                    echo "Overriding $VAR_NAME because of $FLAG_OVERRIDE - using $FLAG_OVERRIDE_TARGET";
                    local -rn FINAL_TARGET=FLAG_OVERRIDE_TARGET;
                    break;
                else
                    echo "Warning: $FLAG_OVERRIDE specified, but $4 not found, failing back to default(s)";
                fi;
            fi
        ;;&
        2)
            [[ -n $VAR_LIST_OF_POSSIBLE_PROGNAMES ]] && local -r VAR_LIST_OF_POSSIBLE_PROGNAMES_EXPANDED=`for p in "$VAR_LIST_OF_POSSIBLE_PROGNAMES"; do which "$p"; done`;
            if [[ ! -v VAR_LIST_OF_POSSIBLE_PROGNAMES_EXPANDED ]]; then
                { 
                    echo "Error: no programs found for $VAR_NAME in list ($VAR_LIST_OF_POSSIBLE_PROGNAMES)";
                    local -r FINAL_TARGET=""
                };
            else
                { 
                    for t in "${VAR_LIST_OF_POSSIBLE_PROGNAMES_EXPANDED[@]}";
                    do
                        if [[ -x "$t" ]]; then
                            local FINAL_TARGET="$t";
                            break;
                        fi;
                    done
                };
            fi
        ;;
        *)
            echo "Error: invalid combination of arguments -- arg list: $*";
            local FINAL_TARGET=""
        ;;
    esac;
    if [[ ! -v FINAL_TARGET ]] || [[ $FINAL_TARGET == "" ]] || [[ ! -x $FINAL_TARGET ]]; then
        return 1;
    else
        printf "$FINAL_TARGET";
        return 0;
    fi
}
function setvarif() 
{ 
    local _RV = $?;
    case $# in 
        0)
            [[ $_RV -eq 0 ]] && return 0 || return 1
        ;;
        1)
            [[ $_RV -eq 0 ]] && declare -g $1=1;
            return $_RV
        ;;
        2)
            if [[ ${2: 0:1} =~ [+-] ]]; then
                local FLAGNAME=${2: 1};
                if [[ -r ~/.config/bashrc/flags/$FLAGNAME ]] || grep --color=auto -P ^$FLAGNAME\$ ~/.config/bashrc/flagsrc -qP &> /dev/null; then
                    [[ ${2: 0:1} == "+" ]] && local FLAGVAL=1 || local FLAGVAL=0;
                    declare -g $1=$FLAGVAL;
                fi;
            else
                if [[ -r $2 ]]; then
                    declare -g $1="$2";
                    return 0;
                else
                    return 1;
                fi;
            fi
        ;;
        3)
            if [[ -r $3 ]]; then
                if [[ -r $2 ]]; then
                    declare -g $1="$2";
                    return 0;
                else
                    declare -g $1="$3";
                    return 1;
                fi;
            else
                if [[ -r $2 ]]; then
                    declare -g $1="$3";
                    return 0;
                fi;
            fi
        ;;
        4)
            if [[ -r $2 ]]; then
                declare -g $1="$3";
                return 0;
            else
                declare -g $1="$4";
                return 1;
            fi
        ;;
        *)
            echo "Error: $FUNCNAME - bad call (see docs) args=$* rv=$? RV=$_RV";
            return 127
        ;;
    esac
}
function shopt() 
{ 
    if [[ ! -v BASH_SHOPT_STACK ]]; then
        declare -agx BASH_SHOPT_STACK;
    fi;
    BASH_SHOPT_STACK+=("$*");
    builtin shopt "$@";
    return $?
}
function shopt_toggle() 
{ 
    if shopt "$@"; then
        shopt -u "$@";
    else
        shopt -s "$@";
    fi
}
function shopts() 
{ 
    { 
        shopt -o;
        shopt
    } | grep --color=auto -P "${1-.*}" | awk '{ printf("%-030s\t^[[1m%-3s^[[0m\n",$1,$2); }' | sed -r 's/(^[\[)1(mon)/\132;1\2/g;s/(^[\[)1(moff)/\130;1\2/g' | column -c $[ $COLUMNS + 27 ]
}
function show() 
{ 
    if compgen -A $1 2> /dev/null; then
        return;
    else
        if declare -fp $1 2> /dev/null; then
            return;
        else
            if declare -p $1 2> /dev/null; then
                return;
            else
                if alias $1 2> /dev/null; then
                    return;
                else
                    if bind -p | grep --color=auto -P $1 2> /dev/null; then
                        return;
                    else
                        if cat $1 2> /dev/null; then
                            return;
                        else
                            if ls -lh --color -d $1 2> /dev/null; then
                                return;
                            else
                                if help $1 2> /dev/null; then
                                    return;
                                else
                                    if man -f $1; then
                                        man $1;
                                        return;
                                    else
                                        if [[ -r /usr/share/info/$1?([0-9])?(-.[0-9]).*info?(-[0-9]).gz ]]; then
                                            info $1;
                                        else
                                            if apt-cache show "$1" 2> /dev/null; then
                                                return;
                                            else
                                                if [[ -z $(apt-cache search $1 2>/dev/null) ]]; then
                                                    bmenu "Cannot Locate Anything To Show" "Search|Find in Firefox" "Links|Find in Text Browser" "Nevermind|Don't Look";
                                                    case $? in 
                                                        0 | 3 | 255)
                                                            INFO "Aborted [$?]"
                                                        ;;
                                                        1)
                                                            firefox -newtab "http://www.google.com/search?q=${1// /+}"
                                                        ;;
                                                        2)
                                                            links2 "http://www.google.com/search?q=${1// /+}"
                                                        ;;
                                                        *)
                                                            CRIT "Error: unknown option returned = $?"
                                                        ;;
                                                    esac;
                                                else
                                                    apt-cache search $1 | less;
                                                fi;
                                            fi;
                                        fi;
                                    fi;
                                fi;
                            fi;
                        fi;
                    fi;
                fi;
            fi;
        fi;
    fi
}
function shufflehome() 
{ 
    Kmul=${RANDOM: 0:3};
    Korf=${RANDOM: 0:3};
    Kofs=${RANDOM: 0:3};
    if [[ $PWD == ~ ]]; then
        cd ~;
    fi
}
function slice() 
{ 
    local SPLICEMAN="$1"
}
function slice_func() 
{ 
    local default_slice="$BASH_SOURCE";
    case $# in 
        0)
            echo "usage: $FUNCNAME [file] target [ [file2] target2 ... ]";
            return 1
        ;;
        1)
            if [[ -r $default_slice ]]; then
                slice_func $default_slice "$1";
            else
                echo "critical error in $FUNCNAME: $default_slice not readable (anymore?) cannot default slice function!!!";
                return 254;
            fi;
            return $?
        ;;
        2)
            if [[ ! -r $1 ]]; then
                slice_func $1;
                RET1=$?;
                slice_func $2;
                [[ $RET1 == 0 ]] && return $? || return $RET1;
            else
                :;
            fi
        ;;
        *)
            for ((i=0; i<$#; i+=2))
            do
                if [[ $(( $i + 1 )) -le $# ]]; then
                    slice_func "${@: i:2}";
                else
                    slice_func "${@: i:1}";
                fi;
            done
        ;;
    esac;
    TMPFILE=$(mktemp);
    TMPLOG=$(mktemp);
    SOURCE="$1";
    TARGET="$2";
    cat "$1" | perl -ne "print if /^function $2/ .. /^}/;" > $TMPFILE;
    if [[ ! -s $TMPFILE ]]; then
        echo "$FUNCNAME fatal: sourcing $TMPFILE ($TARGET) yielded no code, so not loaded!";
    else
        source "$TMPFILE";
    fi;
    rm -f "$TMPFILE"
}
function slice_stub() 
{ 
    [[ -v SLICE_HOST ]] && [[ -x $SLICE_HOST ]] || local SLICE_HOST=/usr/bin/man;
    local SLICE_OUTPUT=$(mktemp);
    local -i RETURN=0;
    [[ -n $5 ]] && local SLICE_TAILCMD=(${*: 5}) || local SLICE_TAILCMD=(less -F);
    [[ -n $4 ]] && local SLICE_LINES="$4" || unset SLICE_LINES;
    [[ -n $3 ]] && local SLICE_INDENT="$3" || local SLICE_INDENT=7;
    [[ -n $2 ]] && local SLICE_SEARCH="$2";
    [[ -n $1 ]] && local SLICE_TOPIC="$1";
    [[ $SLICE_LINES == auto ]] && unset SLICE_LINES;
    [[ ! -x $SLICE_TAILCMD ]] && local SLICE_TAILCMD=(command cat);
    DEBM "calling $FUNCNAME with args [$@], EV's are: $SLICE_TOPIC (topic) $SLICE_SEARCH (search) $SLICE_INDENT (slice_indent)";
    [[ -n $SLICE_TOPIC ]] && [[ -n $SLICE_SEARCH ]] && { 
        if [[ -v SLICE_LINES ]] && "${SLICE_HOST[@]}" "$SLICE_TOPIC" | cat > $SLICE_OUTPUT; then
            if declare -n SLICE_START=`grep '^\s{'$SLICE_INDENT'}'$SLICE_SEARCH'.*$' "$SLICE_OUTPUT" -n | sed 's/:.*//g'`; then
                cat "$SLICE_OUTPUT" | tail -n+$SLICE_START | head -n+$SLICE_LINES | ${SLICE_TAILCMD[@]};
            else
                echo "Cannot get range, press to show: [A]ll Output  [N]o Output  [D]ump to log";
                while true; do
                    case "$(read -sn1;echo ${REPLY^^})" in 
                        A)
                            INFO "showing $SLICE_OUTPUT ($(stat --format='%s' $SLICE_OUTPUT))";
                            cat "$SLICE_OUTPUT";
                            break
                        ;;
                        N)
                            WARN "not showing $SLICE_OUTPUT ($(stat --format='%s' $SLICE_OUTPUT))";
                            rm "$SLICE_OUTPUT" -f;
                            break
                        ;;
                        D)
                            echo -n "please enter an absolute or relative file or directory name [ENTER=auto]: ";
                            read;
                            touch $REPLY &> /dev/null;
                            if [[ -w $REPLY ]]; then
                                INFO "using $REPLY, it is a valid location";
                                DUMPLOC=$REPLY;
                            else
                                if [[ $REPLY =~ (stdout|stderr|stdin|^/dev/fd/) ]]; then
                                    WARN "pointless recursion detected - reshowing file instead (stdout/err)";
                                    DUMPLOC=/dev/stdout;
                                else
                                    if [[ -d $REPLY ]]; then
                                        INFO "directory provided, will provide automatic filename";
                                        DUMPLOC=$(mktemp -p $REPLY --suffix=${USER}s.dumped-output.txt);
                                    else
                                        if [[ -r $REPLY || -s $REPLY || ! -w $REPLY || -n $REPLY ]]; then
                                            WARN "$REPLY is not writable, exists and/or is not zero length: will proceed with autonaming...";
                                        else
                                            if [[ -z $REPLY ]]; then
                                                INFO "Enter pressed without a filename, one will be created...";
                                            else
                                                WARN "Unknown reasons (or complex ones) we cant use $REPLY, using an automatic name...";
                                            fi;
                                        fi;
                                        DUMPLOC=$(mktemp --suffix=${USER}s.dumped-output.txt);
                                        INFO "dumping file contents to $DUMPLOC ...";
                                        if command touch "$DUMPLOC" && command cp "$SLICE_OUTPUT" "$DUMPLOC"; then
                                            INFO "file written ok from $SLICE_OUTPUT";
                                            DEBM "file $SLICE_OUTPUT copied from $DUMPLOC, with timestamp `date`";
                                            if rm $SLICE_OUTPUT; then
                                                DEBM "removed $SLICE_OUTPUT ok";
                                            else
                                                WARN "removal of $SLICE_OUTPUT was completed with error #$?, check the above message, if any.";
                                            fi;
                                        else
                                            CRIT "write operation (datestamp and data copy) to $DUMPLOC, with error #?, check any messages, and report them promptly!";
                                            HINT "if you want that $SLICE_OUTPUT file, you better do something with it before hitting enter";
                                            echo "failed! (press any key to continue)";
                                            read -sn1;
                                        fi;
                                    fi;
                                fi;
                            fi
                        ;;
                        *)
                            CRIT "invalid choice, try again";
                            HINT "some keys are CASE sensitive";
                            local DO_OVER=1
                        ;;
                    esac;
                    [[ -v DO_OVER ]] && unset DO_OVER || break;
                done;
            fi;
        else
            if "${SLICE_HOST[@]}" "$SLICE_TOPIC" | perl -ne 'print if /^\s{'$SLICE_INDENT'}'$SLICE_SEARCH'/ .. /^(\s{'$SLICE_INDENT'}(?!'$SLICE_SEARCH'| )|[A-Z]+)/' | head -n-1 > $SLICE_OUTPUT; then
                local -i SLICE_SIZE=`stat $SLICE_OUTPUT --format='%s'`;
                DETA "Slice Output is $SLICE_OUTPUT ($SLICE_SIZE byte$( [[ $SLICE_SIZE != 0 ]] && printf 's' )).";
                if (( SLICE_SIZE > 0 )); then
                    cat "$SLICE_OUTPUT";
                else
                    DEBM "Slice Output Zero-Length, Not Showing Anything";
                    HINT "Try adjusting the search indent to a larger value, the slice function will then staircase-down to the first readable level.";
                    RETURN=1;
                fi;
            else
                if [[ -s $SLICE_OUTPUT ]]; then
                    WARN "Error getting the slice, the partial output was returned:";
                    cat "$SLICE_OUTPUT";
                    RETURN=2;
                else
                    CRIT "Slice read error, and no text yeilded. Please check your regular expression and try again.";
                    RETURN=1;
                fi;
                rm "$SLICE_OUTPUT";
            fi;
        fi
    } || { 
        CRIT "Slice 'topic' and 'search' arguments/variables must be present! ($*) (TOPIC=${SLICE_TOPIC-empty} SEARCH=${SLICE_SEARCH-empty}"
    };
    unset SLICE_{OUTPUT,TOPIC,SEARCH,LINES_TO_OUTPUT,TAILCMD,INDENT}
}
function specialdiradded() 
{ 
    local CRV=$?;
    echo "* Special directory [1m${1}[0m added.";
    return $CRV
}
function src() 
{ 
    if [[ $1 =~ ^http://.*$ ]] || [[ $1 =~ ^git://.*$ ]]; then
        echo "Yup, it's a git url...'";
        return 0;
    fi;
    shopt -s nullglob;
    if sudo apt-get source "$@"; then
        if [[ -x clean ]]; then
            echo -n "clean found, running it...";
            ./clean;
        else
            echo -n "removing archive files...";
            for i in *.gz *.dsc *.xz *.tar *.ark *.arj *.zip *.rar;
            do
                [[ -r "${i}" ]] && rm -f "${i}" &> /dev/null;
            done;
        fi;
        echo "taking ownership...";
        eval chown $UID:$UID $*\* -R;
        if [[ $? -eq 0 ]]; then
            echo "ownership acquired";
        else
            echo "warning: ownership take may have failed... please take your ownership manually!";
        fi;
        echo "done";
    else
        echo "src failed ($?)";
    fi;
    shopt -u nullglob
}
function stow_bashrc() 
{ 
    cp ~/.bashrc ~/.bashrc_$(date +"%m%d%y_%H%M_%S")
}
function str2which() 
{ 
    local FIRST="";
    for i in "$@";
    do
        if [[ -z $FIRST ]]; then
            FIRST=1;
        else
            echo -ne " ";
        fi;
        nexti="$(switch_which "$i")";
        if [[ $nexti =~ " " ]]; then
            echo -ne "\"$nexti\"";
        else
            echo -ne $nexti;
        fi;
    done
}
function switch_which() 
{ 
    BASENAME=$(basename -- "$*");
    local sel="";
    if [[ -f "$*" ]]; then
        echo "$*";
    else
        if [[ "$BASENAME" =~ ^".".* ]]; then
            echo "$*";
        else
            if WHICH=$(which -- "$*" 2> /dev/null); then
                echo -ne "$WHICH";
            else
                if WHICH=$(find_in_path "$*" 2> /dev/null); then
                    echo -ne "$WHICH";
                else
                    echo "$*";
                fi;
            fi;
        fi;
    fi
}
function switch_which_text() 
{ 
    local NAME=$(switch_which "$*");
    if [[ -f $NAME ]]; then
        if file $NAME | grep --color=auto -P -q text; then
            echo -ne "$NAME";
        else
            echo -ne "$*";
        fi;
    else
        echo -ne "$*";
    fi
}
function systemsettings() 
{ 
    if ! tty -s || [[ ! -x /usr/bin/kcmshell4 ]] || [[ $KDE_FULL_SESSION != true ]] || [[ $KDE_SESSION_VERSION -lt 4 ]] || [[ $KDE_SESSION_UID -ne $UID ]]; then
        local USETTY=0;
    else
        local USETTY=1;
    fi;
    if [[ $USETTY == 1 ]]; then
        while true; do
            ( IFS='|';
            myvar=($(kcmshell4 --list | tail -n+2 | perl -le 'for (<>) { s/^(\S+)\s+-\s+(\S.*)$/\1\|\2\|/g; chomp $_; print $_; }; printf "Cancel\|Exit"' | tr -d '\n'));
            unset IFS;
            dialog --menu "KDE Options" 0 0 0 "${myvar[@]}" ) 2> response;
            response=`cat response`;
            [[ $reponse == "" ]] || [[ $? -ne 0 ]] && break;
            kcmshell4 $response;
        done;
    else
        command `which systemsettings` "$@";
    fi
}
function typeof() 
{ 
    local -i fcount=0;
    local searchkinds=(alias binding command disabled export function helptopic job running setopt signal user arrayvar builtin directory enabled file group hostname keyword service shopt stopped variable);
    for i in ${searchkinds[@]};
    do
        for k in `compgen -A $i`;
        do
            if [[ $k == $1 ]]; then
                if [[ $2 == long ]]; then
                    echo "$k($i)";
                else
                    echo $i;
                    fcount+=1;
                fi;
            fi;
        done;
    done;
    if ((!fcount)); then
        if [[ $2 == long ]]; then
            echo "$1(undefined)";
        else
            echo "<undefined>";
        fi;
        if [[ $2 == times ]]; then
            return 0;
        else
            return 1;
        fi;
    fi;
    if [[ $2 == times ]]; then
        return $fcount;
    else
        return 0;
    fi
}
function unaliafun() 
{ 
    if [[ `declare -pf $1 2>/dev/null` =~ ALIAFUN_TAG ]]; then
        unset -f $1;
    else
        echo "Unknown aliafun: $1";
    fi
}
function undo_last_change() 
{ 
    cp ~/.bashrc ~/.bashrc_$(date +"%m%d%y_%H%M_%S");
    mv ~/.bashrc_previous ~/.bashrc -f
}
function updatedb() 
{ 
    command updatedb "$@" & disown
}
function uses() 
{ 
    if declare -pf "$1" &> /dev/null; then
        return 0;
    else
        slice_func "$@";
    fi
}
function var() 
{ 
    case $# in 
        0)
            { 
                declare -pa;
                declare -pA
            } | grep -oPs '^declare[^=]+'
        ;;
        1)
            NAME=`echo $1  | grep '^[^\[]+'`;
            SUBSCRIPT=`echo $1 | grep '(?<=\[)[^\]]+'`;
            declare -pa $NAME | grep '\['$SUBSCRIPT'\][^\[]+'
        ;;
        *)
            echo "NYI: Not Yet Implemented"
        ;;
    esac
}
function vim_command() 
{ 
    "$@"
}
function vim_hook() 
{ 
    if __isflag NO_VIM_OVERRIDES; then
        if __isflag NO_LIVE_STUBS; then
            slice_func vim_stub;
        fi;
        vim_stub "$@";
    else
        command vim "$@";
    fi
}
function vim_old() 
{ 
    if [[ $* =~ --[a-z] ]] || [[ $* =~ ( |^)-[a-z]( |$) ]]; then
        DEBM "flags were given, direct mode selected!";
        __isflag AUTO_GVIM && GV=g$FUNCNAME || GV=$FUNCNAME;
        command vim "$@";
        return $?;
    else
        cat  <<-EOF |
vim smartlauncher(tm) v0.0.2
(C)2013-14 Paradisim LLC, Gabriel T. Sharp <osirisgothra@hotmail.com>
homepage: http://paradisim.github.com/gxbase-extras-vimsl.git
EOF
  WARN $(cat /dev/stdin);
    fi
    if ! vim_settings; then
        echo "Loader Stopped: vim_settings was unable to set up the required variables";
        echo "Pass command line directly? (vim $*)";
        if [[ `read -sn1; echo ${REPLY^^}` == 'Y' ]]; then
            vim "$@";
        else
            false;
        fi;
        return;
    fi;
    if [[ ! -v UNLOADABLES ]]; then
        declare -ga UNLOADABLES;
        UNLOADABLES+=(SUDO_EXECUTABLE VIM_EXECUTABLE);
    fi;
    local -i USESUDO=0;
    set -- $(str2which "$@");
    for i in "$@";
    do
        if [[ -f "$i" || -d "$i" ]]; then
            if [[ ! -w "$i" ]]; then
                ((USESUDO++));
                echo "$i -- file is write-protected, elevation level incremented" > $(tty);
            fi;
        fi;
    done;
    echo "command translation: $*";
    sleep 0.5;
    echo "executing vim...";
    if [[ $USESUDO -gt 0 ]]; then
        if [[ $(groups | grep -so sudo) == "sudo" ]]; then
            echo "authorized to level $USESUDO, must use sudo (and you are allowed)";
            vim_command "$SUDO_EXECUTABLE" -- "$VIM_EXECUTABLE" "${VIM_SERVER_COMMAND_LINE[@]}" "$@";
        else
            echo "authorized to level $USESUDO: not in sudoers group, you must take some action to edit these files!";
            while [[ ! -x $CMD ]]; do
                [[ ! -z $CMD ]] && echo "command does not exist, try again!" || echo "Enter a command to edit these files (ie, sudo vim, kdesudo mousepad, altprog vim, etc):";
                echo -ne "command-line? : ";
                read CMD;
            done;
            echo "Attempting launch: $CMD $*";
            $CMD "$@";
        fi;
    else
        DETA "Launching command line: command $VIM_EXECUTABLE \"$@\"";
        vim_command "$VIM_EXECUTABLE" "${VIM_SERVER_COMMAND_LINE[@]}" "$@";
    fi;
    if [[ $? -eq 0 ]]; then
        for i in "$@";
        do
            if file "$i" | grep --color=auto -P "script" -q; then
                echo "Setting executable: $i";
                sudo chmod a+x "$i";
            fi;
        done;
    fi
}
function vim_settings() 
{ 
    if __isflag VIM_DISABLE_SERVER; then
        INFO "Server (single-instance) Mode for VIM is disabled.";
        HINT "Declare VIM_DISABLE_SERVER=1 -or- move the VIM_DISABLE_SERVER flag into the active 'flags' directory";
        if [[ -v VIM_SERVER_COMMAND_LINE ]]; then
            DEBM "VIM_SERVER_COMMAND_LINE: with previous value of $VIM_SERVER_COMMAND_LINE is now UNSET";
            unset VIM_SERVER_COMMAND_LINE;
            read;
        else
            DEBM "VIM_SERVER_COMMAND_LINE: already unset, no action taken";
        fi;
    else
        unset VIM_SERVER_COMMAND_LINE;
        unset VIM_SERVER_LIST;
        declare -agx VIM_SERVER_LIST=(`/usr/bin/vim --serverlist`);
        for server in "${VIM_SERVER_LIST[@]}";
        do
            DEBM "Located Server $server";
            if [[ $server == GXBASE_VIM_INSTANCE ]]; then
                FOUND_SERVER=$server;
            fi;
        done;
        if [[ $FOUND_SERVER != GXBASE_VIM_INSTANCE ]]; then
            declare -agx VIM_SERVER_COMMAND_LINE=("--servername" "GXBASE_VIM_INSTANCE" "--remote");
            DEBM "VIM_SERVER_COMMAND_LINE: now is set to: ${VIM_SERVER_COMMAND_LINE[@]}";
            DEBM "VIM_SERVER_COMMAND_LINE: will be used in the calls to vim() that launch vim AFTER this point.";
        else
            if [[ ${#VIM_SERVER_LIST[@]} -gt 0 ]]; then
                SVRMSG="Our server isn't running, but there are others, would you like to use one?";
                bmenu "$SVRMSG" `for i in @{VIM_SERVER_LIST[@]}; do echo \"$i|$i\"; done`;
                response=$?;
                if [[ $reponse -gt 0 && $response -lt 255 ]]; then
                    declare -agx VIM_SERVER_COMMAND_LINE=("--servername" "${VIM_SERVER_LIST[$response]}");
                else
                    unset VIM_SERVER_COMMAND_LINE;
                fi;
            else
                unset VIM_SERVER_COMMAND_LINE;
            fi;
        fi;
    fi;
    [[ -v VIM_SERVER_COMMAND_LINE ]] || { 
        declare -g VIM_SERVER_COMMAND_LINE="" && DETA "No VIM Server Will Be Used This Session"
    };
    DEBM "VIM_SERVER_COMMAND_LINE parsing finished, moving on...";
    DEBM "VIM_EXECUTABLE setup in progress...";
    if [[ ! -x $VIM_EXECUTABLE ]]; then
        declare -g VIM_EXECUTABLE;
        if [[ $TERM =~ (cons|linux) ]]; then
            VIM_EXECUTABLE=`which vim`;
        else
            if can_execute_x_progs; then
                if __isflag AUTO_GVIM; then
                    INFO "Launching [gvim] since X is available, remove the AUTO_GVIM flag to disable this feature.";
                    if ! VIM_EXECUTABLE=`which gvim`; then
                        VIM_EXECUTABLE=`which vim`;
                    fi;
                else
                    VIM_EXECUTABLE=`which vim`;
                    HINT "Hint: X is running, you can set the AUTO_GVIM config flag to use it by default!";
                fi;
            fi;
        fi;
        if [[ -x $VIM_EXECUTABLE ]]; then
            INFO "VIM Executable chosen: $VIM_EXECUTABLE";
        else
            CRIT "ERROR: vim not detected, you must have vim/gvim in your path to use it!";
            return 1;
        fi;
    fi;
    if [[ ! -x $SUDO_EXECUTABLE ]]; then
        declare -g SUDO_EXECUTABLE;
        local -a SUDO_PROGS=(`which kdesudo` `which gksudo` /etc/alternatives/*sudo* `which sudo`);
        for sudoprog in "${SUDO_PROGS[@]}";
        do
            if [[ -x $sudoprog ]]; then
                echo "Selected Sudo Program: $sudoprog";
                SUDO_EXECUTABLE=$sudoprog;
                break;
            fi;
        done;
        if [[ ! -x "$SUDO_EXECUTABLE" ]]; then
            echo "ERROR: sudo not in path, you will NOT be able to use sudo (elevated privs) when editing!";
        fi;
    fi;
    DETA "Selected $SUDO_EXECUTABLE and $VIM_EXECUTABLE for handling the vim command!";
    HINT "You can change these anytime to your own values!"
}
function vim_stub() 
{ 
    local VIM_EXEC GVIM_EXEC SUDO_EXEC USE_SUDO USE_GVIM VIM_SERVER GVIM_SERVER SUDO_REQUIRED SUDO_SUGGESTED USE_SUDO_IN_CMD;
    local -a VIMARGS=();
    local -a VIM_SERVER_LIST=();
    local -a VIM_SERVER_LIST_PRE=();
    local -a V_S_L;
    VIM_EXEC=`which vim`;
    GVIM_EXEC=`which gvim`;
    SUDO_EXEC=`which sudo`;
    USE_SUDO=$( [[ $UID -eq 0 ]] && echo 0 || { groups | grep sudo -q && echo 1 || echo 0; } );
    USE_GVIM=$( __isflag AUTO_GVIM && echo 1 || echo 0 );
    VIM_SERVER="VIM_LEVEL${USE_SUDO}_SERVER_${UID}_$GROUPS";
    GVIM_SERVER="GVIM_LEVEL${USE_SUDO}_SERVER_${UID}_$GROUPS";
    VIM_SERVER_LOOKUPLIST=($VIM_SERVER $GVIM_SERVER);
    VIM_SERVER_LIST_PRE=(`/usr/bin/vim --serverlist`);
    if __isflag MIXING_VIM_AND_GVIM_SERVER_NAMES_OK; then
        VIM_SERVER_LIST=("${VIM_SERVER_LIST_PRE[@]}");
    else
        for i in ${VIM_SERVER_LIST_PRE[@]};
        do
            if ((USE_GVIM)); then
                if [[ ${i^^} =~ GVIM ]]; then
                    VIM_SERVER_LIST+=("$i");
                fi;
            else
                if ! [[ ${i^^} =~ GVIM ]]; then
                    VIM_SERVER_LIST+=("$i");
                fi;
            fi;
        done;
    fi;
    VIM_SERVER_RUNNING=$(( ${#VIM_SERVER_LIST[@]} != 0 ));
    SUDO_REQUIRED=0;
    SUDO_SUGGESTED=0;
    USE_SUDO_IN_CMD=0;
    VIM_SERVER_TO_USE=NONE;
    VIM_SERVER_TO_FIND=${VIM_SERVER_LOOKUPLIST[$USE_GVIM]};
    VIM_SERVER_INTERACT=$( __isflag NO_VIM_SERVERS && echo 1 || echo 0 );
    if [[ $VIM_SERVER_INTERACT == 1 ]]; then
        if [[ ${#VIM_SERVER_LIST[@]} > 0 ]]; then
            for i in "$VIM_SERVER_LIST";
            do
                case $i in 
                    "$VIM_SERVER_TO_FIND")
                        VIM_SERVER_TO_USE="$i";
                        break
                    ;;
                esac;
            done;
            if [[ $VIM_SERVER_TO_USE == NONE ]]; then
                if dialog --yesno "Couldn't locate any trusted vim server. There are OTHER servers running, would you like to connect to one?" 0 0; then
                    if RESPONSE=`dialog --no-tags --output-fd 1 --menu "Please Pick A Server" 0 0 0 $( for j in "$VIM_SERVER_LIST"; do echo -ne " $j $j "; done )`; then
                        VIM_SERVER_TO_USE="$RESPONSE";
                    fi;
                fi;
            fi;
        else
            if dialog --yesno "No vim servers are running, create one now?" 0 0; then
                VIM_SERVER_TO_USE="$VIM_SERVER_TO_FIND";
            fi;
        fi;
    else
        HINT "VIM Servers are disabled (NO_VIM_SERVERS flag has been set), you can enable them by getting rid of the flag!";
    fi;
    DEBM "Phase: untainting (scrubbing) arguments -- $@";
    for i in "$@";
    do
        if [[ $i =~ ^--(remote|time|help|\?|version|server|start|$) ]]; then
            echo "skipping illegal parameter: $i (eaten by this function)";
            continue;
        else
            if [[ $i =~ ^--?[-a-zA-Z0-9]*$ ]]; then
                echo "preserving parameter flag: $i";
                NEXT="$i";
            else
                NEXT=$(switch_which_text $i);
                if [[ -e "$NEXT" && -f "$NEXT" ]]; then
                    if [[ -r "$NEXT" && -w "$NEXT" ]]; then
                        echo "file found that was read/writable by uid $UID, no sudo tripped here";
                    else
                        echo "file $NEXT is not read/writable (or both) by uid $UID, sudo needed tripped";
                        SUDO_REQUIRED=1;
                    fi;
                else
                    if [[ -d "$NEXT" ]] && [[ ! -r $NEXT || ! -w $NEXT || ! -x $NEXT ]]; then
                        echo "directory $NEXT is not read/write/executable by $UID, should be sudo, tripping suggest";
                        SUDO_SUGGESTED=1;
                    else
                        echo "directory r/w/x ok by current uid, $UID, no trip needed on suggest sudo";
                    fi;
                fi;
            fi;
        fi;
        VIMARGS+=("$NEXT");
    done;
    DEBM "Phase: adding appropriate items to command line based on settings";
    if [[ $VIM_SERVER_TO_USE != NONE ]]; then
        if __isflag VIM_SILENT_FAIL_SERVER_OPS; then
            local VIMARG_REMOTESTR='--remotesilent';
        else
            local VIMARG_REMOTESTR='--remote';
        fi;
        VIMARGS=(--servername "$VIM_SERVER_TO_USE" "$VIMARG_REMOTESTR" "${VIMARGS[@]}");
    fi;
    if (( USE_GVIM )); then
        VIMEXEC="$GVIM_EXEC";
    else
        VIMEXEC="$VIM_EXEC";
    fi;
    if (( USE_SUDO )); then
        if (( SUDO_REQUIRED )); then
            USE_SUDO_IN_CMD=1;
        else
            if (( SUDO_SUGGESTED)); then
                if dialog --yesno "One of the directories in the command line cannot be used by user $USER($UID). This user has permissions to use sudo, would you like to enable it?" 0 0; then
                    USE_SUDO_IN_CMD=1;
                else
                    USE_SUDO_IN_CMD=0;
                fi;
            else
                USE_SUDO_IN_CMD=0;
            fi;
        fi;
    else
        (( SUDO_REQUIRED && SUDO_SUGGESTED != 1 )) && WARN "$@ : read/write not possible on some arguments' file components";
        (( SUDO_REQUIRED != 1 && SUDO_SUGGESTED )) && WARN "$@ : read/wr/ex not possible on some arguments' directory components";
        (( SUDO_REQUIRED == 1 && SUDO_SUGGESTED )) && WARN "$@ : read/wr/ex not possible on arguments' file and directory [separate] components";
        USE_SUDO_IN_CMD=0;
    fi;
    echo "server to use at this point: ${VIMARGS[@]}";
    if (( USE_SUDO_IN_CMD )); then
        VIMARGS=("$SUDO_EXEC" "$VIMEXEC" "${VIMARGS[@]}");
    else
        VIMARGS=("$VIMEXEC" "${VIMARGS[@]}");
    fi;
    DEBM "Phase: display pre-launch statistics to user";
    cat  <<-EOF |
[31;1mVim Launcher Statistics
[1;30mHRULE
[33;1mREQUIREMENTS     [33;1mState (0=no/off 1=yes/on)
[32;1mSUDO_REQUIRED    [34;1m$SUDO_REQUIRED [doesn't affect USE_SUDO]
[32;1mSUDO_SUGGESTED   [34;1m$SUDO_SUGGESTED [ditto]
[32;1mUSE_SUDO_IN_CMD  [34;1m$USE_SUDO_IN_CMD [final call for sudo's use]
[32;1mVIM_S..R_RUNNING [34;1m$VIM_SERVER_RUNNING (any servers running?)
[30;1mreserved         [30;1m-
[30;1m                 [30;1m
[33;1mEXECUTABLES      [33;1mPath/Executable
[32;1mVIM_EXEC         [34;1m$VIM_EXEC
[32;1mGVIM_EXEC        [34;1m$GVIM_EXEC
[32;1mSUDO_EXEC        [34;1m$SUDO_EXEC
[33;1mSETTINGS         [33;1mState (0=no/off 1=yes/on)
[32;1mUSE_SUDO         [34;1m$USE_SUDO
[32;1mUSE_GVIM         [34;1m$USE_GVIM
[30;1m                 [30;1m
[33;1mSERVER DETAILS   [33;1mSetting (String Value)
[32;1mVIM_SERVER       [34;1m$VIM_SERVER
[32;1mGVIM_SERVER      [34;1m$GVIM_SERVER
[32;1mVIM_SERVER_LIST  [34;1m${VIM_SERVER_LIST[@]}
[32;1mVIM_S_T_FIND     [34;1m$VIM_SERVER_TO_FIND
[32;1mVIM_S_T_USE      [34;1m$VIM_SERVER_TO_USE
[32;1mVIM_LOOKUPLIST   [34;1m${VIM_SERVER_LOOKUPLIST[@]}

[32;1m                 [34;1m
[32;1mARGS (IN)        [34;1m$FUNCNAME $@
[32;1mARGS (OUT)       [34;1m${VIMARGS[@]}
[32;1m                 [34;1m
[1;30mHRULE
[0;31;1mvim will be started with these settings
EOF
  sed "s/HRULE/$(__hrule)/g;s/\n/

/g"
    echo "${VIMARGS[@]}";
    if choice "Proceed?"; then
        command "${VIMARGS[@]}";
    fi;
    return 1
}
function vop() 
{ 
    voperate "$@"
}
function voperate() 
{ 
    while true; do
        VOP=$1;
        shift;
        [[ -z $VOP ]] && break;
        ACT=$1;
        shift;
        [[ -v $ACT ]] && VACT=${!ACT} || VACT=0;
        [[ -z $ACT ]] && { 
            CRIT "No Action Given with VOP: $VOP, failed to finish vop()";
            return 2
        };
        case $VOP in 
            DCOND)
                [[ $VACT -ne 0 ]] && unset $ACT || return 1
            ;;
            DDIR)
                [[ -d $VACT ]] && { 
                    !rmdir $VACT || return 1
                } || return 1
            ;;
            SWD)
                [[ -d $VACT ]] && { 
                    !builtin cd $VACT || return 1
                } || return 1
            ;;
            *)
                CRIT "Unknown VOPerative: $VOP [arg was $ACT]" && return 1
            ;;
        esac;
    done
}
function xterm() 
{ 
    command xterm "$@" > /dev/null 2>&1 &
}
function xtitle() 
{ 
    if [[ $TTY =~ ^/dev/tty\d+$ ]]; then
        true;
    else
        if [[ $TTY =~ ^/dev/\S*pt.+$ ]]; then
            if which xtitle &> /dev/null; then
                command xtitle "$@";
            else
                true;
            fi;
        else
            true;
        fi;
    fi
}
function zsnes() 
{ 
    command zsnes "$@" & disown
}
