#!/bin/bash
#
# gen-sudo
#
# delegate for running commands via sudo
# notes
#   use apt-sudo for apt- and dpkg- commands
#
# This is a multi-call script, if you want to sudoize an apt-command, please 
#  make a symbolic link to this file (example: ln -s /$PWD/apt-sudo aot-get) 
#

# Protect interactive shell's environment by forcing an execution rather
# than allowing this file to be sourced. [system.security]
case $- in *i*) eval $BASH_SOURCE "$@"; return $?;; esac
# since security measures taken, $0 will be the script's name always

# variables
# SUDOTHRESH (integer): minimum number of files that need admin rights to read/write before sudo kicks in (default=1)
declare -i SUDOTHRESH=1

case $UID in
0)
#	OLDPATH=$PATH
#	PATH=/usr/bin:/usr/sbin:/bin:/sbin:/lib/lsb
#	hash -r
#	if type $1; then
#		eval "$@"
#		exit $?
#	fi
#	PATH=$OLDPATH
	NOQUOTE=YES
	;;
esac


set ${GX_DEBUGMODE-+x}
BASENAME=$(basename $0)
set +x
unset HUSH
case $BASENAME in 
	gen-sudo)
		case $1 in
			hush)
				if [[ $2 == off ]]; then
					echo "hushmode off"
					rm ~/.hushgen -f
				else
					echo "hushmode on (use hush off to turn off)"
					touch ~/.hushgen
				fi
				exit 0
				;;
			*)	
				if [[ $1 ]]; then
					GNAME="$(basename $1)"
					NNAME="$PWD/$GNAME"
					if [[ -x "$1" ]] && [[ ! -x $NNAME ]]; then
						echo -ne "Create a link for $GNAME [at $NNAME] to $BASH_SOURCE? [y/n]:"
						if [[ $(read -sn1; echo $REPLY) == y ]]; then
							echo " creating a gen-sudo for $1 ..."
							if (ln -s "$BASH_SOURCE" "$NNAME" -f); then
								echo "successful! swapping hashtable entries to reflect changes..."
								hash -d "$GNAME"
								hash -p "$NNAME" "$GNAME"
								echo "done"
							else
								echo "failed ($?)"
								exit 1
							fi
						else
							echo "aborted."
						fi
						exit 0
					else
						echo "Bad argument: $1 is not a path to an executable file!"
						exit 1
					fi			
				# else == [[ -z $1 ]]
				else
					# the only way to beep when pcspkr is shut off (done by default in most modern installers)
					
					sudo modprobe pcspkr; beep; sudo modprobe -r pcspkr					
					echo
					echo "Error: you need to specify a name of the new command to make gen-sudoized."
					echo
					echo "example: gen-sudo /usr/bin/sudoedit"
					echo
					echo "You MUST supply the full path to the program because it will be used to remove"
					echo "it's entry from the hash table in order to allow you to run this command anew."
					echo "If you already have done this, just make sure $(dirname $BASH_SOURCE) is in"
					echo "your system's path variable. Edit your ~/.bashrc to do this. See below for more."
					echo
					echo "Your current .bashrc PATH assignment is:"
					echo "  $PATH"
					echo
					echo "Your current PATH variable status is:"
					oIFS=$IFS
					IFS=":"
					declare -i FOUND=0
					for i in $PATH; do
						if [[ "$i" == "$(dirname $BASH_SOURCE)" ]]; then
							((FOUND++))
						fi
					done
					
					if [[ $FOUND -gt 1 ]]; then
            echo "[33mOK: The PATH variable contains the correct path... however, it is present there $FOUND times, you"
						echo "    need it to be in there ONE time. More than this can cause performance issues. You should"
						echo "    revise your ~/.bashrc file!   Especially if it appears more than two or three times!!!!![0m"
					elif [[ $FOUND -eq 0 ]]; then
	        	echo "[31mWARNING: Your PATH variable does NOT contain the needed path. Please add this line "
						echo "         to the VERY LAST LINE of your ~/.bashrc file:"
						echo -e "        [1m        PATH+=\":$(dirname $BASH_SOURCE)\"[21m"
						echo -e "         \(The QUOTES are very important\!\)[0m"
						echo
					else
						echo "[32mOK: Your PATH variable contains the correct path, no modification of .bashrc needed![0m"
					fi

					exit 1
				fi
				;;
		esac
		;;
############################## Place Program Route Filters Here ###############	
## NOTICE: append routes with ;;& if you wish to continue execution
##         use ;; to stop execution, or use ;& to execute the next block 
##         UNCONDITIONALLY--if the ln) block ended with ;& then the ln)
##         block would execute the vim) block as well, and since vim
##         continues processing, it would inherit that behavior because of it.
##         The route would be: ln->vim->[any other blocks and conditions]->*
##         Please use this kind of routing with care!!

			# ln route filter, checks for overwrite (accidental misnaming arguments) 
			ln)				
				if [[ $1 == "-s" ]]; then
					[[ -r "$3"  ]] && {
							echo -ne "overwrite [1m$3[0m? (y/n) [n = 3 seconds]: "
							TMOUT=3
							REPLY=n
							if [[ $(read -sn1; echo $REPLY) != y ]]; then							
								echo $'\nAborted!'
								exit 1
							fi
						}											
			 		# continue

					fi
					# routing to continue evaluating for possible route matches
					;;& 
			vim|gvim|vim.*)					
				# vim route filter, simply checks the FILE components of the
				# command string, checks to see if they are read only, and
				# elevates if needed, with a brief warning.
				# NOTE: switch values are ignored however, the values immediately following switches that may actually be attributed to switches
				#       are not treated specially and could be misinterpreted as a false elevation case, in which case you should run vim directly
				#       or use the -direct as your first parameter afterwards. Example: vim -direct --vim-option vim-option-string file1 ...
				#       Beware that if you do this, there will be no elevation, that is why there is also a "vim -directsudo" argument, which works
				#       the same way except sudo is used by force:
				declare -i SUDOCOUNT=0
				case $1 in
					"-directsudo")
							((SUDOCOUNT++))							
							;&
					"-direct")
							SKIPCHECKS=1
							shift
							;;
					*)															
							for i in "$@"; do
								# do not process switch values
								if [[ "${i: 0:1}" == "-" ]]; then
									continue
								fi
								if [[ -e "$i" ]]; then
									# exists, check for write-ability/readability
									if [[ ! -r "$i" ]] || [[ ! -w "$i" ]]; then
										((SUDOCOUNT++))
									fi
								else
									# check for the file in PATH and VIM_SEARCHPATH (see default above)
									# dont walk through the PATH, make a temporary copy and possibly reinject
									# original copy to be restored after looking
	#						#	OLD_PATH=$PATH									
 #						 # 	[[ "$VIM_SEARCHPATH" == "" ]] && unset VIM_SEARCHPATH  # the next will fail if its empty but still set, correct that here 									
#	 IN PROGRESS	#						# note the +: which will only add the searchpath and the : preceding it if it is not empty
#								# PATH=$PATH${VIM_SEARCHPATH+:}${VIM_SEARCHPATH}
 #						# 	MATCH=$(type -p "$i")
									

									# doesn't	exist, check target's directory
									ITEMDIR=$(dirname "$i")							
									if [[ -d "$ITEMDIR" ]] && [[ ! -w "$ITEMDIR" ]]; then
										((SUDOCOUNT++))
									elif [[ -d "$ITEMDIR" ]] && [[ ! -r "$ITEMDIR" ]]; then
										((SUDOCOUNT++))						
									fi
								fi
							done
							;;
				esac
				VIMDESTS=($(type -pa $BASENAME))
				# default if no other found
				VIMSPEC=/usr/bin/vim
				unset VIMFOUND
				for kk in "${VIMDESTS[@]}"; do
					echo "comparing $kk against $BASH_SOURCE..."
					if [[ $kk != $BASH_SOURCE ]]; then
						echo "found one: $kk"
						VIMSPEC=$kk
						VIMFOUND=1
						break
					fi
				done
				[[ $VIMFOUND != 1 ]] &&	echo "Warning, could not find a copy of vim in your path, using the default: $VIMSPEC"			
				############### boundary check ######################
				
				# at  this point, there is a chance that the user may have 
				# double linked the vim in different locations, if this is 
				# the  case we cant have it  running forever in a loop, we 
				# will detect this and warn the  user so that he,  she, or 
				# it can resolve the issue:

				if [[ $VIM_RUNNING ]]; then
					echo "Error: infinite loop protection, terminating without running."
				else
          export VIM_RUNNING=1
					if [[ $SUDOCOUNT -ge $SUDOTHRESH ]]; then
						# one or more files tagged, and the tag threshold has been met
						[[ $SKIPCHECKS ]] && echo -ne "User evoked switcharg-ignoring \"directsudo\", " || echo -ne "One or more file system	object(s) are inaccessible, "
						echo "using root privileges."
						sleep 2						
						sudo -H "$VIMSPEC" "$@"
					else
            [[ $SKIPCHECKS ]] && echo -ne "User evoked switcharg-ignoring \"direct\": "
						echo "Editing using ${USERNAME}'s permissions."
						sleep 1						
						"$VIMSPEC" "$@"
					fi
					unset VIM_RUNNING
				fi
				exit $?

				
    	;;
	*)
		[[ ! -r ~/.hushgen ]] && [[ -z $NOQUOTE ]] && echo "[0;36m--- [1msudo $BASENAME $* [21m---[0m" || HUSH=1
		eval sudo "$BASENAME" "$@"
		ERR=$?
		case $ERR in
			0) clr=2		;;  	#     0 = no error = green
		  1) clr=3		;;  	#     1 = no successful, regular error = yellow
127|128) clr=1;41	;; 		# 127/8 = command not found = SEVERE = red on dark red
			*) clr=1		;;  	#   >=2 = fatal/unexpected error = red

		esac		
		[[ -z $HUSH ]] && [[ -z $NOQUOTE ]] && echo "[3${clr}m--- [1msudo $BASENAME $* = [46;7m $ERR [40;27;21m ---[0m" || unset HUSH
		exit $ERR
		;;
esac
[[ -z $NOQUOTE ]] && echo "Internal Error: $BASENAME, $*, $ERR - Notify the author if failure persists."
[[ -z $NOQUOTE ]] && exit 254



