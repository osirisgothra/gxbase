#!/bin/bash


# do x repeat disabling if exclusive child of the x session
if [[ $DISPLAY ]] && [[ -z $SSH_CLIENT_INFO ]]; then
	if ( for item in `pidof xinit`; do pgrep --parent $item ".*" -l; done ) | grep $PPID -q; then
		KEY_AGGRESSIVE_MODE=true
	else
		unset	KEY_AGGRESSIVE_MODE
	fi
fi

# TODO: if options exceed these two, use getopts to avoid complications
# h = draw horizonally, v = draw verticall
if [[ "$1" == "-vert" ]]; then
	DRAWMODE=v
	shift
else
	DRAWMODE=h
fi
if [[ "$1" == "-q" ]]; then
	QUIET=1
	shift
else
	unset QUIET
fi
# help anywhere in string
if [[ "$*" =~ .*--help.* ]]; then
	echo "Usage: $0 [-vert] [-q] {menutext1,menutext2,[menutext2] ... }"
	case $- in *i*) return 1;; esac; exit 1
fi

# disable echo, repeat(text ttys only), and hide the cursor
# which will also rid the screen of accidental key garbage
stty -echo
setterm -repeat off -cursor off
[[ $KEY_AGRESSIVE_MODE ]] && xset -r

# colors to use -- in x mode we use the 256 color palette
# for a bit more contrast. Change these if you like

[[ $DISPLAY ]] && 
{ 
	dim="38;5;238"
	sel="38;5;51" 
} || 
{
	dim="30;1"
	sel="36;1"
}

# shell options as needed
shopt -s interactive_comments
shopt -s xpg_echo

# codes
Margin=$(printf " %.0s" {0..${MENU_MARGIN-0}})
if [[ -z $MENU_MARGIN ]] || [[ $MENU_MARGIN == 0 ]]; then Margin=" "; fi
Anchor='[s' Return='[u'
Home='[H'   End='[F'
Up='[A'			Left='[D'
Down='[B'   Right='[C'
NewLine="
"


# numeric
declare -gi First=0				
declare -gi Last=$(( $# - 1 ))
declare -gi Current=$First
declare -ga ITEMS=("$@")
declare -g REPLY=""
declare -ig FirstDraw=0

function printf()
{
	command printf "$@" > $(tty)
}

function _draw()
{
	case $DRAWMODE in
		h)	_hdraw;;
		v)  _vdraw;;
		*)  echo "corrupted DRAWMODE variable: $DRAWMODE"; exit 1;;
	esac
}

function _vdraw()
{
	# first draw must init $First-$Last-1 extra lines first, this prevents the scrolling of the window by giving an extra line
	# (when the last line is written, a scroll happens, we must put that extra line blank so this does not happen!)
	if (( FirstDraw == 0 )); then
		for i in "\\\\n" "$Up"; do eval printf "${i}%.0s" {$First..$[Last-1]}; done               		# warning: eval used here (no sanitize)
		let FirstDraw++
	fi

	printf "$Anchor"
	
	for ((i=First;i<=Last;i++)); do
		local ti="${ITEMS[i]}"
		if ((i > First)); then
			printf "\n"
		fi
		if ((i == Current)); then
			printf "$Margin[${sel}m$ti[${dim}m$Margin"
		else
			printf "$Margin[${dim}m$ti[${dim}m$Margin"
		fi
	done
	printf "$Return"
}

function _hdraw()
{
printf "$Anchor"
for ((i=First;i<=Last;i++)); do
	local ti="${ITEMS[i]}"
	if ((i == Current)); then
		printf "$Margin[${sel}m$ti[${dim}m$Margin"
	else
		printf "$Margin[${dim}m$ti[${dim}m$Margin"
	fi
done
printf "$Return"
}

if (( $# <= 1 )); then
    echo "Not enough items -- you need at least 2 items to have a menu."
else
		_draw
		REPLY="NONE"
	while [[ $REPLY != "" ]]; do
		unset REPLY
		read -sn3
		case $REPLY in
			$Left|$Up)
			if ((Current > First)); then
				 ((Current--))
			else
				beep
			fi
			;;
			$Right|$Down)
			if ((Current < Last)); then
				((Current++))
			else
				beep
			fi                                                                                                                                                                                                                                                                                    
			;;
		esac
		_draw
	done
fi
case $- in
 #[i]nteractive mode no need to echo : grab the variable
	*i*)
			if [[ $DESTVAR ]]; then
				eval "$DESTVAR=\${ITEMS[Current]}"
			else
				REPLY=${ITEMS[Current]}
				RESULT="$REPLY"
			fi
			;;
	*)
			if [[ -z $QUIET ]]; then
				echo ${ITEMS[Current]}
			fi
			;;
esac
# return the terminal to it's former state
setterm -repeat on -cursor on
stty echo
[[ $KEY_AGRESSIVE_MODE ]] && xset r

# set return code to index (this works for both interactive and non
# the (parentheses) are very important or the interactive mode will kill the term!
(exit $Current)
		






