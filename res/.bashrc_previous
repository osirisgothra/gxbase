# ~/.bashrc: executed by bash(1) for non-login shells.
# see /usr/share/doc/bash/examples/startup-files (in the package bash-doc)
# for examples

# touches
touch -f ~/.bash-aliases
touch -f ~/.bash-helpers
touch -f ~/.bash-settings
touch -f ~/.bash-vars
touch -c ~/.bash-history
touch -c ~/.bash-logout
touch -c ~/.bash-profile
touch -f ~/.bash

# inclusions
source /gxbase/res/temp
source /gxbase/res/bash-functions
source ~/.bash-aliases

# pre-checks
check_interactive_shell


# variable declarations


# function declarations



# conditional statements

# If not running interactively, don't do anything

if [[ -r ~/.hushlogin ]] && [[ -z $GXBASH_REDIRECTING ]]; then
  # prevent infinite loop of redirected output until fo limit reached
	export GXBASH_REDIRECTING=TRUE
	source $BASH_SOURCE > /dev/null 2> ~/.bash-loginerrors
	unset GXBASH_REDIRECTING
	return $?
fi


# don't put duplicate lines or lines starting with space in the history.
# See bash(1) for more options
HISTCONTROL=ignoreboth


HISTSIZE=1000
HISTFILESIZE=2000

[ -x /usr/bin/lesspipe ] && eval "$(SHELL=/bin/sh lesspipe)"

# set variable identifying the chroot you work in (used in the prompt below)
if [ -z "${debian_chroot:-}" ] && [ -r /etc/debian_chroot ]; then
    debian_chroot=$(cat /etc/debian_chroot)
fi

# set a fancy prompt (non-color, unless we know we "want" color)
case "$TERM" in
    xterm-color) color_prompt=yes;;
esac

# uncomment for a colored prompt, if the terminal has the capability; turned
# off by default to not distract the user: the focus in a terminal window
# should be on the output of commands, not on the prompt
#force_color_prompt=yes

if [ -n "$force_color_prompt" ]; then
    if [ -x /usr/bin/tput ] && tput setaf 1 >&/dev/null; then
	# We have color support; assume it's compliant with Ecma-48
	# (ISO/IEC-6429). (Lack of such support is extremely rare, and such
	# a case would tend to support setf rather than setaf.)
	color_prompt=yes
    else
	color_prompt=
    fi
fi

if [ "$color_prompt" = yes ]; then
    PS1='${debian_chroot:+($debian_chroot)}\[\033[01;32m\]\u@\h\[\033[00m\]:\[\033[01;34m\]\w\[\033[00m\]\$ '
else
    PS1='${debian_chroot:+($debian_chroot)}\u@\h:\w\$ '
fi
unset color_prompt force_color_prompt

# If this is an xterm set the title to user@host:dir
case "$TERM" in
xterm*|rxvt*)
    PS1="\[\e]0;${debian_chroot:+($debian_chroot)}\u@\h: \w\a\]$PS1"
    ;;
*)
    ;;
esac

# enable color support of ls and also add handy aliases
if [ -x /usr/bin/dircolors ]; then
    test -r ~/.dircolors && eval "$(dircolors -b ~/.dircolors)" || eval "$(dircolors -b)"
    alias ls='ls --color=auto'
    #alias dir='dir --color=auto'
    #alias vdir='vdir --color=auto'

    alias grep='grep --color=auto'
    alias fgrep='fgrep --color=auto'
    alias egrep='egrep --color=auto'
fi

# some more ls aliases
alias ll='ls -alF'
alias la='ls -A'
alias l='ls -CF'

# Add an "alert" alias for long running commands.  Use like so:
#   sleep 10; alert
alias alert='notify-send --urgency=low -i "$([ $? = 0 ] && echo terminal || echo error)" "$(history|tail -n1|sed -e '\''s/^\s*[0-9]\+\s*//;s/[;&|]\s*alert$//'\'')"'

# Alias definitions.
# You may want to put all your additions into a separate file like
# ~/.bash_aliases, instead of adding them here directly.
# See /usr/share/doc/bash-doc/examples in the bash-doc package.


# GUI/TERMINAL determination, changes behavior based on whether or not
# there is an attached display server/window manager with capabilities
# of running graphical versions of certain programs, additionally we 
# will allow our host to run commands under another user even if we dont
# own this DISPLAY outright, but this only works on local accounts since
# the only host allowed is 127.0.0.1 [localhost]
if [[ $DISPLAY ]]; then
	# allow us to run programs when not the original user of the session
	xhost 127.0.0.1
	# setup aliases for normally textmode stuff
	alias nano=mousepad
	alias vim='vim_func -g'
else
	alias vim='vim_func -n'
fi

if [[ $UID -eq 1000 ]]; then
	for i in apt-get apt-add-repository dpkg mc mousepad chmod chown chgrp stat gzip tar cp ln aptsh; do
		alias $i='sudo '$i
	done
fi

function countof()
{
	unset n
	for i in "$@"; do declare -i n+=1; done
	echo $n
	return $n
}

# vim_func [-g | -n] vim-command-line
# runs vim [-n] or gvim [-g], and if not root, detects if sudoers and if is sudos the call
#
function vim_func()
{
	if [[ $1 == -n ]] || [[ $1 == -g ]]; then
		USUALFLAG=1
	else
		USUALFLAG=0
	fi
	if [[ $2 == ~/.bashrc ]] && [[ $USUALFLAG -eq 1 ]] && [[ $# -eq 2 ]]; then
		# straight edit of bashrc (user typed: vim ~/.bashrc)	
		# ignore flag and edit in-terminal
		shift
		if (cp ~/.bashrc /tmp/bashrc_last); then
			echo "failsafe backup created ok"
		else
			echo "can't make a failsafe backup, aborting"
			return 126
		fi
		/usr/bin/vim_target ~/.bashrc
		if (! diff ~/.bashrc /tmp/bashrc_last 2>/dev/null); then
			echo -ne "bashrc changed, resourcing..."
			source ~/.bashrc
			ERRC=$?
			echo "complete [$ERRC]" 
			echo "creating a persistent backup..."
			if (sudo cp /tmp/bashrc_last ~/.bashrc_previous -f); then
				echo "backup is in ~/.bashrc_previous, to restore it, copy it back over and source it."
			else
				echo "warning: persistent backup failed, but there is a temporary copy in /tmp/bashrc_last"
				echo "         however it will be deleted if the system reboots!"
			fi
			return $ERRC
		else
			echo "~/.bashrc unchanged, no resourcing or backup neccisary."
			return 0
		fi
	fi

  if [[ "$1" == "-g" ]]; then
		VIMCMD=gvim
	else
		VIMCMD=vim
	fi
	shift
	if [[ $UID -eq 0 ]]; then
		$VIMCMD "$@"
	else
		if [[ ! -w . ]] || [[ ! -w $1 ]]; then
			sudo $VIMCMD "$@"
		else
			$VIMCMD "$@"
		fi
	fi	
}
function lsfunc()
{
	
	# gather some details on filesystem (tail was faster than grep)
	FSDEV=`df --output . | tail -n1 | awk '{ print $1 }'`
  FSTYPE=`df --output . | tail -n1 | awk '{ print $2 }'` 
  FSSIZE=`df --output . | tail -n1 | awk '{ print $7 }'` 
  FSUSED=`df --output . | tail -n1 | awk '{ print $8 }'` 
  FSAVAIL=`df --output . | tail -n1 | awk '{ print $9 }'` 
  FSUSEPERC=`df --output . | tail -n1 | awk '{ print $10 }'` 
  FSMOUNT=`df --output . | tail -n1 | awk '{ print $11 }'` 
  # gather some details on current dir
	declare -i DIRCOUNT=$(countof `find -maxdepth 1 -type d`)
	declare -i FILCOUNT=$(countof `find -maxdepth 1 -type f`)
	declare -i SYMCOUNT=$(countof `find -maxdepth 1 -type l`)
	declare -i BDEVCOUNT=$(countof `find -maxdepth 1 -type b`)
	declare -i CDEVCOUNT=$(countof `find -maxdepth 1 -type c`)
	declare -i PIPECOUNT=$(countof `find -maxdepth 1 -type p`)
	declare -i SOCKCOUNT=$(countof `find -maxdepth 1 -type s`)
	# bytecount (uncomment the one you like best)
	# do this way if you want accurate uncached counts:
	#declare -i BYTECOUNT="$(unset n;for i in `find -maxdepth 1 -exec stat '{}' --format='%s' ';'`; do declare -i n+=$i;done;echo $n)"
	# done via ls instead so cache will be effective (much faster, default):	
	BYTECOUNT="$(command ls -sh | head -n1 | awk ' { printf $2 ; } ')"

	echo
	
	echo "Filesystem on Device $FSDEV is $FSTYPE on $FSMOUNT"
	echo "Directory Listing of $PWD"
	echo

	command ls "$@"

	echo
	if [[ $FILECOUNT -gt 0 ]] || [[ $DIRCOUNT -gt 0 ]] || [[ $SYMCOUNT  -gt 0 ]] || [[ $BYTECOUNT -gt 0 ]]; then
		echo "${BYTECOUNT}bytes in $FILCOUNT file(s), $DIRCOUNT dir(s), and $SYMCOUNT link(s)"
	fi
	if [[ $BDEVCOUNT -gt 0 ]] || [[ $CDEVCOUNT -gt 0 ]] || [[ $PIPECOUNT -gt 0 ]] || [[ $SOCKCOUNT -gt 0 ]]; then
		if [[ $SOCKCOUNT -eq 1 ]]; then
		 	SUFF="device"
		else
			SUFF="devices"
		fi
		echo "$BDEVCOUNT block, $CDEVCOUNT character, $PIPECOUNT pipe, and $SOCKCOUNT socket $SUFF"
	fi	
	if [[ $FSSIZE != 0 ]]; then
		echo "Using ${FSUSED}bytes of ${FSSIZE}bytes. ${FSAVAIL}bytes remaining ($FSUSEPERC in use)"
	fi
	echo

}
function lsfunc2()
{
	echo;
	if [[ -z $1 ]]; then
		ls --color -l | /usr/bin/columns
	else	
		ls --color -l "$@"
	fi
	echo;
}
alias dir='lsfunc -batchHs --color=always'
alias ls='lsfunc2'
alias grep='grep --color'
alias du='du --max-depth=1 -h'
alias df='df -h'
alias eb='vim ~/.bashrc'
alias rgx='source /etc/bash_completion; source /gxbase/gxbase'


# Only interested in doing this if we are on a LOCAL terminal (xterms are considered remote too)
CURTTY=$(tty 2> /dev/null | grep -o '[^\/]*$' | grep -o '[^0-9]*')
if [[ $CURTTY == tty ]]; then
	DISPLAY_PROPOSED=`ps avfx -e | grep -o "[ ][:][0-9][ .][0-9]{0,1}"`
	if [[ ! -z $DISPLAY_PROPOSED ]]; then
		echo "Allow access to session: $DISPLAY_PROPOSED?"
		echo "(this will run GUI applications in that X session, you may not want this)"
		echo -ne "Enter Choice [y = YES   n = NO [default=NO]]: "
		alias choice=read -sn1;echo $REPLY
		if [[ $(read -sn1; echo $REPLY) == y ]]; then
			echo "adding localhost to host list..."
			xhost 127.0.0.1 2> /dev/null 1>&2
			export DISPLAY=$DISPLAY_PROPOSED
		else
			echo "not adding localhost to host list."
		fi
	fi
fi
function color()
{
	[[ -z $2 ]] && echo -n "[3${1}m"
	[[ $2 ]] && echo -n "[${2};3${1}m"
	[[ -z $1 ]] && echo -n "[0m"
}

function addbashcmd()
{
  echo "Type new command, it will be sourced afterwards as well and in your startup .bashrc in future startups"
	echo "-PRESS ENTER WHEN DONE--------------------------------------------------------------------------------"
	if [[ -z $2 ]]; then
		read CMD_STR
		if [[ ${CMD_STR^^} == MULTI ]]; then
			echo "ENTERING MULTI-LINE MODE, TYPE THE WORD MULTI ON A LINE WHEN DONE:"
			unset CMD_STR CMD_MSTR
			while [[ $CMD_STR != MULTI ]]; do
				read CMD_STR
				if [[ $CMD_STR != MULTI ]]; then
					if [[ -z $CMD_MSTR ]]; then
						CMD_MSTR="$CMD_STR"
					else
						CMD_MSTR+="$(echo -ne '\n')"
						CMD_MSTR+="$CMD_STR"
					fi
				fi
			done
			echo "LEAVING MULTI-LINE MODE..."
			CMD_STR="$CMD_MSTR"
		fi
	else
		echo "Automatic: $2"
		CMD_STR="$2"
	fi
	RETVAL=0
  if [[ $CMD_STR ]]; then
		mkdir /home/gabriel/.config/bash -p 2> /dev/null
		echo "Type a name for this command [needed if you want to delete it later]"
		echo -ne "command identity: "
		if [[ -z $1 ]]; then
			read CMD_FNAME
		else
			echo "Automatic: $1"
			CMD_FNAME="$1"
		fi
		if [[ $CMD_FNAME ]]; then
			echo "writing new command, $CMD_FNAME..."
			CMD_FDEST="/home/gabriel/.config/bash/$CMD_FNAME"
			echo "$CMD_STR" > "$CMD_FDEST"
			echo "synchronizing with .bashrc..."
			pushd > /dev/null 2>&1
			source "$CMD_FDEST"
			echo -ne "restoring shell state..."
			unset IFS
			
			unset TMOUT
			# give 1/4 second time for synchronize in case command is sensitive to this
			sleep 0.25 
			sync
			popd > /dev/null 2>&1
			echo "done"
			echo "command $CMD_FNAME was added to .bashrc, use delbashcmd $CMD_FNAME to remove it."
		else
			echo "invalid command name, aborting."
			RETVAL=1
		fi
	else
		echo "no command given, aborting."
		RETVAL=2
	fi
	echo "freeing environment blocks: $[ ${#CMD_MSTR} + ${#CMD_FDEST} + ${#CMD_FNAME} + ${#CMD_STR} ] bytes freed."
	unset CMD_FDEST CMD_FNAME CMD_STR CMD_MSTR
	return $RETVAL
}
function delbashcmd()
{
	if [[ ! -w /home/gabriel/.config/bash/$1 ]]; then
		echo "Command not found, specify one that exists:"
		ls /home/gabriel/.config/bash
	else
		echo "Really delete it?"
		if [[ $(read -sn1 R; echo ${R^^}) == Y ]]; then
			if (rm -f "/home/gabriel/.config/bash/$1"); then
				echo "succeeded"
			else
				echo "did not succeed, check your permissions and the error string above, if any."
			fi
		else
			echo "cancelled!"
		fi
	fi
	return $?
}
# process commands added by addbashcmd
[[ -s /home/gabriel/.config/bash ]] && echo -ne "processing..."
for i in /home/gabriel/.config/bash/*; do
	echo -ne "$(basename $i) "
	source "$i"
done

[[ -s /home/gabriel/.config/bash ]] && echo " - done."
#prevent multiple reloading the path, which would become quickly a bad thing if bashrc is reloaded several times by some script
if [[ -z $PATH_IS_SET ]]; then
	export PATH=/gxbase/res:/gxbase:/gxbase/bin:/home/gabriel/bin:$PATH
	export PATH_IS_SET=1
fi

# confirm variable by showing name AND value
#  you can specify as many as you like (not limited to $1-$9, either) since shift is used and not $2, $3, etc
#  there is a delay so the user can read each variable's name and value
#  the more arguments passed, an additional second is added to the delay
function vconf()
{
	
	while [[ ! -z $1 ]]; do
		echo "$1: ${!1}"
		shift
	done
	for i in echo sleep clear false; do $i $[ $# / 2 ]; done

	
}
function xvim() { sudo chown gabriel:gabriel "$@"; sudo chmod a+rw "$@"; vim `command ls -C "$@"`; sudo chmod a+x "$@"; return $?; }
function makemine() { sudo chown $USERNAME:$USERNAME "$@"; echo "changed ownership to $USERNAME:$USERNAME"; }

# XINIT_MODE: xinit when wanting control over the vt and DISPLAY, startx when you want automatic control
# XINIT_DEVICE: the display you want to assign the X server (usually :0) here it is set up to automatically check for other running sessions (recommended)
# XINIT_VT: the terminal you want to use, default is to use vt12, but you can change this to anything, use ALT+F12 to get back to it
XINIT_MODE=xinit
XINIT_DEVICE=":$(ps avfx -e | grep 'X .*[:][0-9] ' --count)"
XINIT_VT=vt12
# if SESSNAME is not set, it will be set automatically to ~/.xsession-output which is probably NOT what you want because it can be overwritten if >1 sessions are in use from the same user
function do_xinit()
{
	# confirm vars:
	vconf XINIT_MODE XINIT_DEVICE XINIT_VT

	# update .xinitrc, regardless of choice	
	echo "exec $1 $SESSARGS" > ~/.xinitrc

	if (! touch $SESSNAME); then
		SESSNAME="~/.xsession-output"
	fi

	case $XINIT_MODE in
		xinit)
			command /usr/bin/xinit $1 $SESSARGS -- $XINIT_DEVICE $XINIT_VT > $SESSNAME 2>&1 &
			;;
		startx)
			command /usr/bin/startx > $SESSNAME 2>&1 &
			;;
		*)
			echo "Error: invalid value in XINIT_MODE: $XINIT_MODE"
			# prevent disown
			return 1
			;;
	esac
	disown %
	return $?	
}
alias startdwm='startx dwm'
alias startkde='startx startkde'
alias startlxde='startx startlxde'
if (echo $(tty)|grep "pts"); then
	# tty terms
	true       # placeholder
else

	# alias for non-pts terminals only	
	alias xterm='startx xterm -c "xterm -fullscreen"'
	alias st='startx st'
	alias firefox='startx firefox'
  alias chrome='startx chromium-browser'
	alias pcsx='startx pcsx'
	alias zsnes='startx zsnes'
	alias gvim='startx /usr/bin/gvim_target'
	alias gimp='startx gimp'
	alias blender='startx blender'
	alias modo='startx modo'
	alias vlc='startx vlc'
	alias firefoxp='startx firefox --private-window'
fi
function startx()
{
	unset SESSARGS
	if [[ -x "$1" ]]; then
		local NEXTONE="$1"
		shift
	elif [[ $1 ]] && [[ ! -x "$1" ]]; then
		local NEXTONE="$(locate */bin/$1 -l1)"
		shift
	else
		local NEXTONE=none
	fi
	local LASTONE=`cat ~/.xinitrc | grep -Po '(?<=exec ).*'`
	while [[ ! -x $NEXTONE ]]; do
		echo -ne "enter session name w/o path [ENTER=$LASTONE]: "
		read NEXTONE
		if [[ -z $NEXTONE ]]; then
			NEXTONE=$LASTONE
			break
		else
			if [[ -x /usr/bin/$NEXTONE ]]; then
				NEXTONE=/usr/bin/$NEXTONE
				break
			elif [[ -x $NEXTONE ]]; then
				break
			else
				echo "not executable, please type something else or hit ENTER for the default."
			fi
		fi
		# continue loop or (break) from it
	done
	echo "attempting to start x..."
	# REMOVED: echo "exec $NEXTONE" > ~/.xinitrc
	if [[ $? -eq 0 ]]; then
		SESSNAME="/var/tmp/startx-$USERNAME-$RANDOM-session.log" 
		SESSARGS="$*"
		# startx or xinit called from this subfunction
		#  REMOVED: command /usr/bin/startx > $SESSNAME 2>&1 & 
		#  REMOVED: disown %
		do_xinit $NEXTONE
		echo "Session Launched: $NEXTONE"
		echo
	else
		echo "cannot, write to ~/.xinitrc failed."
	fi
  local ERR=$?
	echo "function or session ended with code $ERR"	
	return $ERR
}
#bind '"\C-a": "ssh root@azura"'
#bind '"\C-p": "ssh root@peryite"'
#bind '"\C-f": "apt-cache search "'
#bind '"\C-i": "apt-get install --noremove --yes"'
#bind '"\C-l": "ls -C --color"'
#bind '"[1;5A": "cd .."'
#bind '"[1;5C": "cd 	"'

# correct should-be variables

export LD_LIBRARY_PATH=/usr/lib:/usr/lib/x86_64-linux-gnu/:/lib:/lib/x86_64-linux-gnu/:/usr/local/lib:/lib64:/lib/i386-linux-gnu/:/usr/lib/i386-linux-gnu:$LD_LIBRARY_PATH
export HOME=~
export USERNAME=$(id -un)
export GROUP=$(id -gn) 
export GROUPS=($(id -G))
export UID=$(id -u)
export LS_COLORS='rs=0:di=01;34:ln=01;36:mh=00:pi=40;33:so=01;35:do=01;35:bd=40;33;01:cd=40;33;01:or=40;31;01:su=37;41:sg=30;43:ca=30;41:tw=30;42:ow=34;42:st=37;44:ex=01;32:*.tar=01;31:*.tgz=01;36:*.arj=01;31:*.taz=01;31:*.lzh=01;31:*.lzma=01;31:*.tlz=01;31:*.txz=01;31:*.zip=01;31:*.z=01;31:*.Z=01;31:*.dz=01;31:*.gz=01;36:*.lz=01;31:*.xz=01;31:*.bz2=01;31:*.bz=01;31:*.tbz=01;31:*.tbz2=01;31:*.tz=01;31:*.deb=01;31:*.rpm=01;31:*.jar=01;31:*.war=01;31:*.ear=01;31:*.sar=01;31:*.rar=01;31:*.ace=01;31:*.zoo=01;31:*.cpio=01;31:*.7z=01;31:*.rz=01;31:*.jpg=01;35:*.jpeg=01;35:*.gif=01;35:*.bmp=01;35:*.pbm=01;35:*.pgm=01;35:*.ppm=01;35:*.tga=01;35:*.xbm=01;35:*.xpm=01;35:*.tif=01;35:*.tiff=01;35:*.png=01;35:*.svg=01;35:*.svgz=01;35:*.mng=01;35:*.pcx=01;35:*.mov=01;35:*.mpg=01;35:*.mpeg=01;35:*.m2v=01;35:*.mkv=01;35:*.webm=01;35:*.ogm=01;35:*.mp4=01;35:*.m4v=01;35:*.mp4v=01;35:*.vob=01;35:*.qt=01;35:*.nuv=01;35:*.wmv=01;35:*.asf=01;35:*.rm=01;35:*.rmvb=01;35:*.flc=01;35:*.avi=01;35:*.fli=01;35:*.flv=01;35:*.gl=01;35:*.dl=01;35:*.xcf=01;35:*.xwd=01;35:*.yuv=01;35:*.cgm=01;35:*.emf=01;35:*.axv=01;35:*.anx=01;35:*.ogv=01;35:*.ogx=01;35:*.aac=00;36:*.au=00;36:*.flac=00;36:*.mid=00;36:*.midi=00;36:*.mka=00;36:*.mp3=00;36:*.mpc=00;36:*.ogg=00;36:*.ra=00;36:*.wav=00;36:*.axa=00;36:*.oga=00;36:*.spx=00;36:*.xspf=00;36:';
export IFS=""
export TMOUT=0
alias date='date +"%c"'



# set shell options

set +o allexport                              
set +o errexit                
set +o errtrace                               
set +o ignoreeof              
set +o keyword                
set +o noclobber              
set +o noexec                                 
set +o noglob                 
set +o nolog                                  
set +o notify                 
set +o nounset                                
set +o onecmd                 
set +o physical                               
set +o pipefail               
set +o posix                                  
set +o privileged             
set +o verbose                                
set +o vi                     
set +o xtrace
set -o braceexpand            
set -o emacs                                  
set -o functrace              
set -o hashall                                
set -o histexpand             
set -o history                                
set -o interactive-comments                   
set -o monitor                                
shopt -s checkwinsize         
shopt -s cmdhist                              
shopt -s complete_fullquote                   
shopt -s direxpand            
shopt -s expand_aliases       
shopt -s extdebug                             
shopt -s extglob              
shopt -s extquote                             
shopt -s failglob             
shopt -s force_fignore                        
shopt -s globstar             
shopt -s histappend                           
shopt -s histreedit           
shopt -s interactive_comments 
shopt -s login_shell                          
shopt -s mailwarn             
shopt -s progcomp                             
shopt -s promptvars           
shopt -s sourcepath                           
shopt -s xpg_echo             
shopt -u autocd                               
shopt -u cdable_vars          
shopt -u cdspell                              
shopt -u checkhash            
shopt -u checkjobs                            
shopt -u compat31             
shopt -u compat32                             
shopt -u compat40             
shopt -u compat41                             
shopt -u compat42             
shopt -u dirspell                             
shopt -u dotglob              
shopt -u execfail                             
shopt -u globasciiranges                      
shopt -u gnu_errfmt           
shopt -u histverify                           
shopt -u hostcomplete         
shopt -u huponexit                            
shopt -u lastpipe                             
shopt -u lithist              
shopt -u no_empty_cmd_completion              
shopt -u nocaseglob           
shopt -u nocasematch                          
shopt -u nullglob             
shopt -u restricted_shell                     
shopt -u shift_verbose        
