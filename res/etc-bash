#!/bin/bash -e "echo \"don't execute this directly!\""
#
# origin name: /gxbase/res/bashrc (gxbase = wherever your GXBASE_ROOT lies)
# linked name: /etc/bash.bashrc
#
# To use an origin script you must create a symbolic link to it with the 'linked name'.
#
# System-wide .bashrc file for interactive bash(1) shells.
# 
# NOTE: this bash.bashrc is not compatible with shells other than bash!!
# Distributed with GXBASE (gitorious.org/gxbase)
# Some parts of this script may be originally from the bash.bashrc distributed with bash
# and most standard linux distributions. The credit for those parts are to their
# respective authors. See the bash and distribution manpages for author and 
# applicable licensing information.
#
# The rewritten majority of this script (which is almost all of it now) is not affiliated
# with the previous authors in any way, shape, or form. Note that this script is purely
# EXPERIMENTAL and I take NO RESPONSIBILITY in what might happen to you or yours while
# running this script. By using you agree that you use this of your own free will at your OWN RISK.
# If you have any questions about GXBASE and the related scripts in it's repository tree, be
# sure not to direct questions about this work to the bash and ld authors, direct them to:
# osirisgothra@hotmail.com
#

[[ -z ${-//[^i]} ]] && return

shopt -s extdebug
shopt -s checkwinsize

if [[ -r /etc/debian_chroot ]]; then
	debian_chroot=${debian_chroot:-$(cat /etc/debian_chroot)}
elif ! shopt -oq posix; then
  if [[ -f /usr/share/bash-completion/bash_completion ]]; then
    . /usr/share/bash-completion/bash_completion
  elif [[ -f /etc/bash_completion ]]; then
    . /etc/bash_completion
  fi
fi

if (groups | grep -q sudo) && [[ ! -r ~/.hushlogin ]]; then
    case " $(groups) " in 
			# i guess standard bashrc only want this information emitted to users in the 'admin' group
			# so i decided to keep it this way as to not invite problems into the script by accidental members
			*" admin "*)
			  if [ -x /usr/bin/sudo ]; then
					echo 'To run a command as administrator (user "root"), use "sudo <command>".'
					echo 'See "man sudo_root" for details.'					
		    fi
				;;				
	    esac
fi


####################### BEGIN bash.bashrc CUSTOMIZATIONS #####################################################################################

# these are experimental, dont use if you dont want problems potentially out of nowhere
# however they should not physically harm your computer but data loss can occur due to 
# this especially in the case of AUTOMATED systems!

if [[ -x /usr/lib/command-not-found ]] || [[ -x /usr/share/command-not-found/command-not-found ]]; then

	#
	# command_not_found_handle [command name] [args]
	# requires the command_not_found python script
	#
	function command_not_found_handle()
	{
		# prevent interaction when not in interactive mode
		case $- in *i*) 
			true #is interactive, go ahead and continue execution
			;;		
		*)
			# not interactive, do not attempt interaction mode
			echo "$BASH_SOURCE: command not found: $* (non interactive)"
			return 127;;
		esac
		# PREVENT interactive install mode when extdebug is disabled
		# because using it recklessly in scripts without this extra
		# information could cause bad things to happen, like big unwanted
		# programs being installed. Note that never would the situation
		# cause anything to be uninstalled or removed, and all installs
		# are logged and marked so they can be undone easily.
		if (! shopt -q extdebug); then
			echo "$BASH_SOURCE: command not found: $*"
			echo "Notice: extdebug is disabled, it is needed for the GXBASE interactive installer to work!"
			return 127
		fi
    #prevent interaction when sourcing from .bashrc
		# this MUST have extdebug on
		if [[ $BASH_ARGV[*] ]]; then
			for ((i=0;i<=$BASH_ARGC;i++)); do
				j=${BASH_ARGV[i]}	  		
				if [[ $j ]] && [[ $(basename "$j") == ".bashrc" ]]; then					
					echo "COMMAND NOT FOUND: $1 (bashrc loop prevention)"
					return 127
				fi
			done
		fi

			
		if [[ $DO_NOT_CNF == YES ]]; then
			echo "Command not found (loop prevention)"
			return 127
		fi
		# check because c-n-f could've been removed in the meantime
  	if [ -x /usr/lib/command-not-found ]; then			
			RESPONSE=$(/usr/lib/command-not-found -- "$1" 2>&1 | tr '\n' ' ')			
			echo "$RESPONSE"
			if (echo "$RESPONSE" | grep -q "apt-get"); then
				TMOUT=5
				echo -ne "Want to install it? Chosing Yes In 5 Seconds... [[y]/n]:"
				REPLY=n
				if [[ $(read -sn1 | echo $REPLY) == y ]]; then
					INSTALL=YES				
					echo "Installing (removal of packages disabled)"					
				else
					INSTALL=NO
					echo "Cancelled"
				fi
				unset TMOUT
				if [[ $INSTALL == "YES" ]]; then
					INSTALLCMD=$(echo $RESPONSE | grep -o "apt-get.*")
					PKGNAME=$(echo INSTALLCMD | grep -Po "(?<=apt-get install ).*")
					echo "Checking existence of package: $PKGNAME"
					if (apt-cache madison $PKGNAME -qq &> /dev/null); then
						echo "Package exists, starting download and install..."
						if [[ $UID -gt 0 ]]; then
							INSTALLCMD="sudo $INSTALLCMD"
						fi
						if (eval $INSTALLCMD --no-remove --yes); then
							echo "Updating auto-install records..."
							echo "$(date): $PKGNAME" >> ~/.autoinstalledpackages
							echo "Install Succeeded!"							
							echo "now running the command as originally requested... [press CTRL+BREAK or CTRL+C in 2 seconds to abort it]"
							sleep 2
							# use DO_NOT_CNF to prevent eternal loops in case some quirk manages to give us a bad exit code
							export DO_NOT_CNF=YES
							command "$@"
							ERR=$?
							export DO_NOT_CNF=NO
							return $ERR
						else
							echo "Error: installer reported failure, you will need to install it manually!"
							return 127
						fi
					else
						echo "Error: package $PKGNAME does not have any actual packages assigned to it"
						echo "       probably because it is either unsupported, depreciated, or virtual!"
					fi
				fi							
			fi
	    return $?
    elif [ -x /usr/share/command-not-found/command-not-found ]; then
		   /usr/share/command-not-found/command-not-found -- "$1"
       return $?
		else
		   printf "%s: command not found\n" "$1" >&2
		   return 127
		fi
	}

fi
