#!/bin/bash
#
# bash-helpers
#
# some functions that may come in handy either for .bashrc 
# or for the end user. They are used by the bashrc file included
# with gxbase, and are completely optional. I've included them
# because I have them and figured it's a cheap way of backing
# them up by including them in the project.                  
#                                                              

##
## \brief check_hushlogin checks if .hushlogin is in effect (present)
## \returns 1 if not present, 0 if present (false,true respectively)
## 
function nogui()
{
	if [[ $NOGUI ]]; then		
		unset NOGUI
	else
		export NOGUI=on
	fi;
	echo "GUI commands are now ${NOGUI-off}."
  [[ $NOGUI ]] && return 0
	return 1	
}

function check_hushlogon() 
{

	if [[ $BASH_REDIRECTING ]]; then
		return 0
	else
		if [[ -r ~/.hushlogin ]]; then  	
			for NEWVAR in stdout stderr
			do
				eval export BASH_REDIRECT_TO_${NEWVAR^^}=~/bash-login.${NEWVAR,,}
			done 
			declare -x BASH_REDIRECTING=YES
			eval source "$@" > $BASH_REDIRET_TO_STDOUT 2> $BASH_REDIRECT_TO_STDERR
			unset BASH_REDIRECTING
			return 1
		else
			return 0
		fi
	fi
}

##
## \brief countof() not only counts parameters but also 
## \returns that count as well
##
function countof()
{	
	declare -i n=$#
	builtin echo $n
	return $n
}

#
# \brief vim_func [-g | -n] vim-command-line
# runs vim [-n] or gvim [-g], and if not root, detects if sudoers and if is sudos the call
# \returns nonzero if error, zero if success (some error codes may come from vim itself)
# yes i know about the -gn flags for vim!
# but, this bypasses that because i need to also
# take into account whether or not NOGUI is enabled
function vim_func()
{
	if [[ $1 == -n ]] || [[ $1 == -g ]]; then
		USUALFLAG=1
	else
		USUALFLAG=0
	fi

	if [[ $2 == ~/.bashrc ]] && [[ $USUALFLAG -eq 1 ]] && [[ $# -eq 2 ]]; then
		# straight edit of bashrc (user typed: vim ~/.bashrc)	
		# ignore flag and edit in-terminal
		shift
		if (cp ~/.bashrc /tmp/bashrc_last); then
			echo "failsafe backup created ok"
		else
			echo "can't make a failsafe backup, aborting"
			return 126
		fi
		/usr/bin/vim_target ~/.bashrc
		if (! diff ~/.bashrc /tmp/bashrc_last 2>/dev/null); then
			echo -ne "bashrc changed, resourcing..."
			source ~/.bashrc
			ERRC=$?
			echo "complete [$ERRC]" 
			echo "creating a persistent backup..."
			if (sudo cp /tmp/bashrc_last ~/.bashrc_previous -f); then
				echo "backup is in ~/.bashrc_previous, to restore it, copy it back over and source it."
			else
				echo "warning: persistent backup failed, but there is a temporary copy in /tmp/bashrc_last"
				echo "         however it will be deleted if the system reboots!"
			fi
			return $ERRC
		else
			echo "~/.bashrc unchanged, no resourcing or backup neccisary."
			return 0
		fi
	fi

  if [[ "$1" == "-g" ]] && [[ -z $NOGUI ]]; then		
		# instead of using vim -g 
		VIMCMD=gvim
	else
		# instead of using vim -n
		VIMCMD=vim
	fi
	shift
	if [[ $UID -eq 0 ]]; then
		$VIMCMD "$@"
	else
		if [[ ! -w . ]] || [[ ! -w $1 ]]; then
			sudo $VIMCMD "$@"
		else
			$VIMCMD "$@"
		fi
	fi	
}

## \brief lsfunc() function for the enhanced ls command (annotated style)
function lsfunc()
{
	
	# gather some details on filesystem (tail was faster than grep)
	FSDEV=`df --output . | tail -n1 | awk '{ print $1 }'`
  FSTYPE=`df --output . | tail -n1 | awk '{ print $2 }'` 
  FSSIZE=`df --output . | tail -n1 | awk '{ print $7 }'` 
  FSUSED=`df --output . | tail -n1 | awk '{ print $8 }'` 
  FSAVAIL=`df --output . | tail -n1 | awk '{ print $9 }'` 
  FSUSEPERC=`df --output . | tail -n1 | awk '{ print $10 }'` 
  FSMOUNT=`df --output . | tail -n1 | awk '{ print $11 }'` 
  # gather some details on current dir
	declare -i DIRCOUNT=$(countof `find -maxdepth 1 -type d`)
	declare -i FILCOUNT=$(countof `find -maxdepth 1 -type f`)
	declare -i SYMCOUNT=$(countof `find -maxdepth 1 -type l`)
	declare -i BDEVCOUNT=$(countof `find -maxdepth 1 -type b`)
	declare -i CDEVCOUNT=$(countof `find -maxdepth 1 -type c`)
	declare -i PIPECOUNT=$(countof `find -maxdepth 1 -type p`)
	declare -i SOCKCOUNT=$(countof `find -maxdepth 1 -type s`)
	# bytecount (uncomment the one you like best)
	# do this way if you want accurate uncached counts:
	#declare -i BYTECOUNT="$(unset n;for i in `find -maxdepth 1 -exec stat '{}' --format='%s' ';'`; do declare -i n+=$i;done;echo $n)"
	# done via ls instead so cache will be effective (much faster, default):	
	BYTECOUNT="$(command ls -sh | head -n1 | awk ' { printf $2 ; } ')"

	echo
	
	echo "Filesystem on Device $FSDEV is $FSTYPE on $FSMOUNT"
	echo "Directory Listing of $PWD"
	echo

	command ls "$@"

	echo
	if [[ $FILECOUNT -gt 0 ]] || [[ $DIRCOUNT -gt 0 ]] || [[ $SYMCOUNT  -gt 0 ]] || [[ $BYTECOUNT -gt 0 ]]; then
		echo "${BYTECOUNT}bytes in $FILCOUNT file(s), $DIRCOUNT dir(s), and $SYMCOUNT link(s)"
	fi
	if [[ $BDEVCOUNT -gt 0 ]] || [[ $CDEVCOUNT -gt 0 ]] || [[ $PIPECOUNT -gt 0 ]] || [[ $SOCKCOUNT -gt 0 ]]; then
		if [[ $SOCKCOUNT -eq 1 ]]; then
		 	SUFF="device"
		else
			SUFF="devices"
		fi
		echo "$BDEVCOUNT block, $CDEVCOUNT character, $PIPECOUNT pipe, and $SOCKCOUNT socket $SUFF"
	fi	
	if [[ $FSSIZE != 0 ]]; then
		echo "Using ${FSUSED}bytes of ${FSSIZE}bytes. ${FSAVAIL}bytes remaining ($FSUSEPERC in use)"
	fi
	echo

}

# \brief lsfunc2() list directory contents, columnized
# \returns whatever ls command returns
function lsfunc2()
{
	echo;
	if [[ -z $1 ]]; then
		command ls --color -l | /usr/bin/columns
	else	
		command ls --color -l "$@"
	fi
	echo;
	return $?
}

## \brief color() changes color by sending ANSI codes to the terminal
## \returns 0 always
function color()
{
	[[ -z $2 ]] && echo -n "[3${1}m"
	[[ $2 ]] && echo -n "[${2};3${1}m"
	[[ -z $1 ]] && echo -n "[0m"
	return 0
}

# a bit more robust than the builtin help
# also tries to get help some other way(s)
function help()
{
	if (! builtin help "$1"); then
		if (! man "$1"); then
			if (! $1 --help); then
				man -k "$1"
			fi
		fi
	fi
	return $?
}
function ishell()
{
	case $- in
		*i*) [[ $1 == interactive ]] && return 0;;
		*P*) [[ $1 == physical ]] && return 0;;
	  *p*) [[ $1 == privileged ]] && return 0;;
  	*H*) [[ $1 == expandingexclamationmarks ]] && return 0;;
		*m*) [[ $1 == monitoringjobs ]] && return 0;;
		*h*) [[ $1 == hashingcommands ]] && return 0;;
		*b*) [[ $1 == jobtermbgverbose ]] && return 0;;
		*e*) [[ $1 == exitingonfailure ]] && return 0;;
	esac
	return 1
}

function xh()
{
	xhost "$@" &> /dev/null
	return $?
}
function xtty()
{
	echo $(tty) | grep -q "pts"
	return $?
}

## \brief addbashcmd() add an alias plus make it persistent across new shells, restarts, etc (permanent)
## \returns whatever
function addbashcmd()
{
  echo "Type new command, it will be sourced afterwards as well and in your startup .bashrc in future startups"
	echo "-PRESS ENTER WHEN DONE--------------------------------------------------------------------------------"
	if [[ -z $2 ]]; then
		read CMD_STR
		if [[ ${CMD_STR^^} == MULTI ]]; then
			echo "ENTERING MULTI-LINE MODE, TYPE THE WORD MULTI ON A LINE WHEN DONE:"
			unset CMD_STR CMD_MSTR
			while [[ $CMD_STR != MULTI ]]; do
				read CMD_STR
				if [[ $CMD_STR != MULTI ]]; then
					if [[ -z $CMD_MSTR ]]; then
						CMD_MSTR="$CMD_STR"
					else
						CMD_MSTR+="$(echo -ne '\n')"
						CMD_MSTR+="$CMD_STR"
					fi
				fi
			done
			echo "LEAVING MULTI-LINE MODE..."
			CMD_STR="$CMD_MSTR"
		fi
	else
		echo "Automatic: $2"
		CMD_STR="$2"
	fi
	RETVAL=0
  if [[ $CMD_STR ]]; then
		mkdir ~/.config/bash -p 2> /dev/null
		echo "Type a name for this command [needed if you want to delete it later]"
		echo -ne "command identity: "
		if [[ -z $1 ]]; then
			read CMD_FNAME
		else
			echo "Automatic: $1"
			CMD_FNAME="$1"
		fi
		if [[ $CMD_FNAME ]]; then
			echo "writing new command, $CMD_FNAME..."
			CMD_FDEST="${HOME}/.config/bash/$CMD_FNAME"
			echo "$CMD_STR" > "$CMD_FDEST"
			echo "synchronizing with .bashrc..."
			pushd > /dev/null 2>&1
			source "$CMD_FDEST"
			echo -ne "restoring shell state..."
			unset IFS
			
			unset TMOUT
			# give 1/4 second time for synchronize in case command is sensitive to this
			sleep 0.25 
			sync
			popd > /dev/null 2>&1
			echo "done"
			echo "command $CMD_FNAME was added to .bashrc, use delbashcmd $CMD_FNAME to remove it."
		else
			echo "invalid command name, aborting."
			RETVAL=1
		fi
	else
		echo "no command given, aborting."
		RETVAL=2
	fi
	echo "freeing environment blocks: $[ ${#CMD_MSTR} + ${#CMD_FDEST} + ${#CMD_FNAME} + ${#CMD_STR} ] bytes freed."
	unset CMD_FDEST CMD_FNAME CMD_STR CMD_MSTR
	return $RETVAL
}
function delbashcmd()
{
	if [[ ! -w ${HOME}/.config/bash/$1 ]]; then
		echo "Command not found, specify one that exists:"
		ls ${HOME}/.config/bash
	else
		echo "Really delete it?"
		if [[ $(read -sn1 R; echo ${R^^}) == Y ]]; then
			if (rm -f "${HOME}/.config/bash/$1"); then
				echo "succeeded"
			else
				echo "did not succeed, check your permissions and the error string above, if any."
			fi
		else
			echo "cancelled!"
		fi
	fi
	return $?
}

# confirm variable by showing name AND value
#  you can specify as many as you like (not limited to $1-$9, either) since shift is used and not $2, $3, etc
#  there is a delay so the user can read each variable's name and value
#  the more arguments passed, an additional second is added to the delay
function vconf()
{
	
	while [[ ! -z $1 ]]; do
		echo "$1: ${!1}"
		shift
	done
	for i in echo sleep clear false; do $i $[ $# / 2 ]; done

	
}
function xvim() { sudo chown ${USERNAME}:${USERNAME} "$@"; sudo chmod a+rw "$@"; vim `command ls -C "$@"`; sudo chmod a+x "$@"; return $?; }
function makemine() { sudo chown ${USERNAME}:${USERNAME} "$@"; echo "changed ownership to ${USERNAME}:${USERNAME}"; }

# if SESSNAME is not set, it will be set automatically to ~/.xsession-output which is probably NOT what you want because it can be overwritten if >1 sessions are in use from the same user
function do_xinit()
{
	# confirm vars:
	vconf XINIT_MODE XINIT_DEVICE XINIT_VT

	# update .xinitrc, regardless of choice	
	echo "exec $1 $SESSARGS" > ~/.xinitrc

	if (! touch $SESSNAME); then
		SESSNAME="~/.xsession-output"
	fi

	case $XINIT_MODE in
		xinit)
			command /usr/bin/xinit $1 $SESSARGS -- $XINIT_DEVICE $XINIT_VT > $SESSNAME 2>&1 &
			;;
		startx)
			command /usr/bin/startx > $SESSNAME 2>&1 &
			;;
		*)
			echo "Error: invalid value in XINIT_MODE: $XINIT_MODE"
			# prevent disown
			return 1
			;;
	esac
	disown %
	return $?	
}

function startx()
{
	unset SESSARGS
	if [[ -x "$1" ]]; then
		local NEXTONE="$1"
		shift
	elif [[ $1 ]] && [[ ! -x "$1" ]]; then
		local NEXTONE="$(locate */bin/$1 -l1)"
		shift
	else
		local NEXTONE=none
	fi
	local LASTONE=`cat ~/.xinitrc | grep -Po '(?<=exec ).*'`
	while [[ ! -x $NEXTONE ]]; do
		echo -ne "enter session name w/o path [ENTER=$LASTONE]: "
		read NEXTONE
		if [[ -z $NEXTONE ]]; then
			NEXTONE=$LASTONE
			break
		else
			if [[ -x /usr/bin/$NEXTONE ]]; then
				NEXTONE=/usr/bin/$NEXTONE
				break
			elif [[ -x $NEXTONE ]]; then
				break
			else
				echo "not executable, please type something else or hit ENTER for the default."
			fi
		fi
		# continue loop or (break) from it
	done
	echo "attempting to start x..."
	# REMOVED: echo "exec $NEXTONE" > ~/.xinitrc
	if [[ $? -eq 0 ]]; then
		SESSNAME="/var/tmp/startx-$USERNAME-$RANDOM-session.log" 
		SESSARGS="$*"
		# startx or xinit called from this subfunction
		#  REMOVED: command /usr/bin/startx > $SESSNAME 2>&1 & 
		#  REMOVED: disown %
		do_xinit $NEXTONE
		echo "Session Launched: $NEXTONE"
		echo
	else
		echo "cannot, write to ~/.xinitrc failed."
	fi
  local ERR=$?
	echo "function or session ended with code $ERR"	
	return $ERR
}
