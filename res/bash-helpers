#!/bin/bash -- Don't Execute Directly, Please note that this is an
#
# bash-helpers
#
# some functions that may come in handy either for .bashrc 
# or for the end user. They are used by the bashrc file included
# with gxbase, and are completely optional. I've included them
# because I have them and figured it's a cheap way of backing
# them up by including them in the project.                  
#                                                              

#
# guioff - enabled/disables GUI features of commands that support this variable
#


function guioff()
{
  [[ -z $1 ]] && set toggle
	case $1 in
		toggle)
			[[ $NOGUI ]] && unset NOGUI || NOGUI=1
			;;
		on)
			[[ $NOGUI ]] || NOGUI=1
			;;
		off)
			[[ $NOGUI ]] && unset NOGUI			
			;;
	esac	


	if [[ -z $NOGUI ]]; then				
		echo "Commands are now oblivious to GUI-disabling effects of guioff"	
	else	
		echo "Commands that support GxBase GUI-disabling are now: disabled"
	fi;

	echo "GUI commands are now ${NOGUI-off}."
  [[ $NOGUI ]] && return 0
	return 1	
}

##
## \brief countof() not only counts parameters but also 
## \returns that count as well
##
function countof()
{	
	declare -i n=$#
	builtin echo $n
	return $n
}

#
# \brief vim_func [-g | -n] vim-command-line
# runs vim [-n] or gvim [-g], and if not root, detects if sudoers and if is sudos the call
# \returns nonzero if error, zero if success (some error codes may come from vim itself)
# yes i know about the -gn flags for vim!
# but, this bypasses that because i need to also
# take into account whether or not NOGUI is enabled
function vim_func()
{
	 
		

	if [[ $1 == -n ]] || [[ $1 == -g ]]; then
		USUALFLAG=1
	else
		USUALFLAG=0
	fi

	if [[ ! -x /usr/bin/vim ]] && [[ ! -x /usr/bin/vim.tiny ]]; then
		if [[ $USUALFLAG ]]; then
			VIMFLAG=${1: 1:1}
			shift
		else
			VIMFLAG=n
		fi
		case $VIMFLAG in
			n)
				# normal but nowhere to go
				if [[ -x /etc/alternatives/editor ]]; then
					# should be almost standard by now
					EDITOR=/etc/alternatives/editor
				elif [[ -x /usr/bin/nano ]]; then
					# installed by default with almost all debian distros
					EDITOR=/usr/bin/nano
				else
					# or perhaps the EDITOR varible is valid (last chance)
					if [[ ! -x $EDITOR ]]; then
						# but not...
						echo "sorry, I can't guess what editor you are using, you'll have to type it in manually"
						echo "try \"man -k editor|grep text\" to see if you have one installed somewhere."
						echo "or do \"sudo apt-get install ubuntu-minimal --reinstall\" if youve lost your base system somehow!"
					fi
				fi
				# at this point we KNOW EDITOR is valid executable so:
				eval $EDITOR "$@"
				return $?
				;;
			g)
				# dont be overzealous, if they dont have vim, try starting in text mode since 
				# the command is intended to run vim, not a bunch of other stuff, serving text
				# other than vim might already be considered fanatical.
				vim_func -n "$@";
				return $?
				;;
		esac
		# this never happens but e-i-m-ing can cause this or corruptions can
		echo "unknown case: $*, exiting"
		return $?			
	elif [[ ! -x /usr/bin/vim ]] || [[ ! -x /usr/bin/gvim ]] &&  [[ -x /usr/bin/vim.tiny ]]; then
		# discard the flag , we dont want it
		if [[ $USUALFLAG ]]; then
			if [[ $1 == "-g" ]]; then
				VIMFLAG=$1
			fi
			shift
		fi
		# only use vim.tiny if we dont have vim
		# never use gvim since if it IS present, that means that vim is not in which case it would 
		# be bad install state, if by some miracle gvim works without being detected (like vim.gtk or some weird
		# thing like that, pass the flag to vim (but not vim.tiny)
		if [[ ! -x /usr/bin/vim ]]; then
			/usr/bin/vim.tiny "$@"
		else
			# the second VIMFLAG expansion removes the space when no VIMFLAG is present
			# (or better put, inserts it when it is)
			/usr/bin/vim $VIMFLAG${VIMFLAG+ }"$@"
		fi
		return $?
	fi	

	# at this time, we KNOW vim AND gvim are present on the system

	if [[ $2 == ~/.bashrc ]] && [[ $USUALFLAG -eq 1 ]] && [[ $# -eq 2 ]]; then
		# straight edit of bashrc (user typed: vim ~/.bashrc)	
		# ignore flag and edit in-terminal
		shift
		if (cp ~/.bashrc /tmp/bashrc_last); then
			echo "failsafe backup created ok"
		else
			echo "can't make a failsafe backup, aborting"
			return 126
		fi
		/usr/bin/vim_target ~/.bashrc
		if (! diff ~/.bashrc /tmp/bashrc_last 2>/dev/null); then
			echo -ne "bashrc changed, resourcing..."
			source ~/.bashrc
			ERRC=$?
			echo "complete [$ERRC]" 
			echo "creating a persistent backup..."
			if (sudo cp /tmp/bashrc_last ~/.bashrc_previous -f); then
				echo "backup is in ~/.bashrc_previous, to restore it, copy it back over and source it."
			else
				echo "warning: persistent backup failed, but there is a temporary copy in /tmp/bashrc_last"
				echo "         however it will be deleted if the system reboots!"
			fi
			return $ERRC
		else
			echo "~/.bashrc unchanged, no resourcing or backup neccisary."
			return 0
		fi
	fi

  if [[ "$1" == "-g" ]] && [[ -z $NOGUI ]]; then		
		# instead of using vim -g 
		VIMCMD=gvim
	else
		# instead of using vim -n
		VIMCMD=vim
	fi
	shift
	if [[ $UID -eq 0 ]]; then
		$VIMCMD "$@"
	else
		if [[ ! -w . ]] || [[ ! -w $1 ]]; then
			sudo $VIMCMD "$@"
		else
			$VIMCMD "$@"
		fi
	fi	
}

## \brief lsfunc() function for the enhanced ls command (annotated style)
function lsfunc()
{
	
	# gather some details on filesystem (tail was faster than grep)
	FSDEV=`df --output . | tail -n1 | awk '{ print $1 }'`
  FSTYPE=`df --output . | tail -n1 | awk '{ print $2 }'` 
  FSSIZE=`df --output . | tail -n1 | awk '{ print $7 }'` 
  FSUSED=`df --output . | tail -n1 | awk '{ print $8 }'` 
  FSAVAIL=`df --output . | tail -n1 | awk '{ print $9 }'` 
  FSUSEPERC=`df --output . | tail -n1 | awk '{ print $10 }'` 
  FSMOUNT=`df --output . | tail -n1 | awk '{ print $11 }'` 
  # gather some details on current dir
	declare -i DIRCOUNT=$(countof `find -maxdepth 1 -type d`)
	declare -i FILCOUNT=$(countof `find -maxdepth 1 -type f`)
	declare -i SYMCOUNT=$(countof `find -maxdepth 1 -type l`)
	declare -i BDEVCOUNT=$(countof `find -maxdepth 1 -type b`)
	declare -i CDEVCOUNT=$(countof `find -maxdepth 1 -type c`)
	declare -i PIPECOUNT=$(countof `find -maxdepth 1 -type p`)
	declare -i SOCKCOUNT=$(countof `find -maxdepth 1 -type s`)
	# bytecount (uncomment the one you like best)
	# do this way if you want accurate uncached counts:
	#declare -i BYTECOUNT="$(unset n;for i in `find -maxdepth 1 -exec stat '{}' --format='%s' ';'`; do declare -i n+=$i;done;echo $n)"
	# done via ls instead so cache will be effective (much faster, default):	
	BYTECOUNT="$(command ls -sh | head -n1 | awk ' { printf $2 ; } ')"

	echo
	
	echo "Filesystem on Device $FSDEV is $FSTYPE on $FSMOUNT"
	echo "Directory Listing of $PWD"
	echo

	command ls "$@"

	echo
	if [[ $FILECOUNT -gt 0 ]] || [[ $DIRCOUNT -gt 0 ]] || [[ $SYMCOUNT  -gt 0 ]] || [[ $BYTECOUNT -gt 0 ]]; then
		echo "${BYTECOUNT}bytes in $FILCOUNT file(s), $DIRCOUNT dir(s), and $SYMCOUNT link(s)"
	fi
	if [[ $BDEVCOUNT -gt 0 ]] || [[ $CDEVCOUNT -gt 0 ]] || [[ $PIPECOUNT -gt 0 ]] || [[ $SOCKCOUNT -gt 0 ]]; then
		if [[ $SOCKCOUNT -eq 1 ]]; then
		 	SUFF="device"
		else
			SUFF="devices"
		fi
		echo "$BDEVCOUNT block, $CDEVCOUNT character, $PIPECOUNT pipe, and $SOCKCOUNT socket $SUFF"
	fi	
	if [[ $FSSIZE != 0 ]]; then
		echo "Using ${FSUSED}bytes of ${FSSIZE}bytes. ${FSAVAIL}bytes remaining ($FSUSEPERC in use)"
	fi
	echo

}

# \brief lsfunc2() list directory contents, columnized
# \returns whatever ls command returns
function lsfunc2()
{
	echo;
	if [[ -z $1 ]]; then
		command ls --color -l | /usr/bin/columns
	else	
		command ls --color -l "$@"
	fi
	echo;
	return $?
}

## \brief color() changes color by sending ANSI codes to the terminal
## \returns 0 always
function color()
{
	[[ -z $2 ]] && echo -n "[3${1}m"
	[[ $2 ]] && echo -n "[${2};3${1}m"
	[[ -z $1 ]] && echo -n "[0m"
	return 0
}

# a bit more robust than the builtin help
# also tries to get help some other way(s)
function help()
{
	if (! builtin help "$1"); then
		if (! man "$1"); then
			if (! $1 --help); then
				man -k "$1"
			fi
		fi
	fi
	return $?
}
function ishell()
{
	case $- in
		*i*) [[ $1 == interactive ]] && return 0;;
		*P*) [[ $1 == physical ]] && return 0;;
	  *p*) [[ $1 == privileged ]] && return 0;;
  	*H*) [[ $1 == expandingexclamationmarks ]] && return 0;;
		*m*) [[ $1 == monitoringjobs ]] && return 0;;
		*h*) [[ $1 == hashingcommands ]] && return 0;;
		*b*) [[ $1 == jobtermbgverbose ]] && return 0;;
		*e*) [[ $1 == exitingonfailure ]] && return 0;;
	esac
	return 1
}

function xh()
{
	xhost "$@" &> /dev/null
	return $?
}
function xtty()
{
	echo $(tty) | grep -q "pts"
	return $?
}

## \brief addbashcmd() add an alias plus make it persistent across new shells, restarts, etc (permanent)
## \returns whatever
function addbashcmd()
{
  echo "Type new command, it will be sourced afterwards as well and in your startup .bashrc in future startups"
	echo "-PRESS ENTER WHEN DONE--------------------------------------------------------------------------------"
	if [[ -z $2 ]]; then
		read CMD_STR
		if [[ ${CMD_STR^^} == MULTI ]]; then
			echo "ENTERING MULTI-LINE MODE, TYPE THE WORD MULTI ON A LINE WHEN DONE:"
			unset CMD_STR CMD_MSTR
			while [[ $CMD_STR != MULTI ]]; do
				read CMD_STR
				if [[ $CMD_STR != MULTI ]]; then
					if [[ -z $CMD_MSTR ]]; then
						CMD_MSTR="$CMD_STR"
					else
						CMD_MSTR+="$(echo -ne '\n')"
						CMD_MSTR+="$CMD_STR"
					fi
				fi
			done
			echo "LEAVING MULTI-LINE MODE..."
			CMD_STR="$CMD_MSTR"
		fi
	else
		echo "Automatic: $2"
		CMD_STR="$2"
	fi
	RETVAL=0
  if [[ $CMD_STR ]]; then
		mkdir ~/.config/bash -p 2> /dev/null
		echo "Type a name for this command [needed if you want to delete it later]"
		echo -ne "command identity: "
		if [[ -z $1 ]]; then
			read CMD_FNAME
		else
			echo "Automatic: $1"
			CMD_FNAME="$1"
		fi
		if [[ $CMD_FNAME ]]; then
			echo "writing new command, $CMD_FNAME..."
			CMD_FDEST="${HOME}/.config/bash/$CMD_FNAME"
			echo "$CMD_STR" > "$CMD_FDEST"
			echo "synchronizing with .bashrc..."
			pushd > /dev/null 2>&1
			source "$CMD_FDEST"
			echo -ne "restoring shell state..."
			unset IFS
			
			unset TMOUT
			# give 1/4 second time for synchronize in case command is sensitive to this
			sleep 0.25 
			sync
			popd > /dev/null 2>&1
			echo "done"
			echo "command $CMD_FNAME was added to .bashrc, use delbashcmd $CMD_FNAME to remove it."
		else
			echo "invalid command name, aborting."
			RETVAL=1
		fi
	else
		echo "no command given, aborting."
		RETVAL=2
	fi
	echo "freeing environment blocks: $[ ${#CMD_MSTR} + ${#CMD_FDEST} + ${#CMD_FNAME} + ${#CMD_STR} ] bytes freed."
	unset CMD_FDEST CMD_FNAME CMD_STR CMD_MSTR
	return $RETVAL
}
function delbashcmd()
{
	if [[ ! -w ${HOME}/.config/bash/$1 ]]; then
		echo "Command not found, specify one that exists:"
		ls ${HOME}/.config/bash
	else
		echo "Really delete it?"
		if [[ $(read -sn1 R; echo ${R^^}) == Y ]]; then
			if (rm -f "${HOME}/.config/bash/$1"); then
				echo "succeeded"
			else
				echo "did not succeed, check your permissions and the error string above, if any."
			fi
		else
			echo "cancelled!"
		fi
	fi
	return $?
}

# confirm variable by showing name AND value
#  you can specify as many as you like (not limited to $1-$9, either) since shift is used and not $2, $3, etc
#  there is a delay so the user can read each variable's name and value
#  the more arguments passed, an additional second is added to the delay
function vconf()
{
	
	while [[ ! -z $1 ]]; do
		echo "$1: ${!1}"
		shift
	done
	for i in echo sleep clear false; do $i $[ $# / 2 ]; done

	
}
function xvim() { sudo chown ${USERNAME}:${USERNAME} "$@"; sudo chmod a+rw "$@"; vim `command ls -C "$@"`; sudo chmod a+x "$@"; return $?; }
function makemine() { sudo chown ${USERNAME}:${USERNAME} "$@"; echo "changed ownership to ${USERNAME}:${USERNAME}"; }

# if SESSNAME is not set, it will be set automatically to ~/.xsession-output which is probably NOT what you want because it can be overwritten if >1 sessions are in use from the same user
function do_xinit()
{
	# confirm vars:
	vconf XINIT_MODE XINIT_DEVICE XINIT_VT

	# update .xinitrc, regardless of choice	
	echo "exec $1 $SESSARGS" > ~/.xinitrc

	if (! touch $SESSNAME); then
		SESSNAME="~/.xsession-output"
	fi

	case $XINIT_MODE in
		xinit)
			command /usr/bin/xinit $1 $SESSARGS -- $XINIT_DEVICE $XINIT_VT > $SESSNAME 2>&1 &
			;;
		startx)
			command /usr/bin/startx > $SESSNAME 2>&1 &
			;;
		*)
			echo "Error: invalid value in XINIT_MODE: $XINIT_MODE"
			# prevent disown
			return 1
			;;
	esac
	disown %
	return $?	
}

function startx()
{
	unset SESSARGS
	if [[ -x "$1" ]]; then
		local NEXTONE="$1"
		shift
	elif [[ $1 ]] && [[ ! -x "$1" ]]; then
		local NEXTONE="$(locate */bin/$1 -l1)"
		shift
	else
		local NEXTONE=none
	fi
	local LASTONE=`cat ~/.xinitrc | grep -Po '(?<=exec ).*'`
	while [[ ! -x $NEXTONE ]]; do
		echo -ne "enter session name w/o path [ENTER=$LASTONE]: "
		read NEXTONE
		if [[ -z $NEXTONE ]]; then
			NEXTONE=$LASTONE
			break
		else
			if [[ -x /usr/bin/$NEXTONE ]]; then
				NEXTONE=/usr/bin/$NEXTONE
				break
			elif [[ -x $NEXTONE ]]; then
				break
			else
				echo "not executable, please type something else or hit ENTER for the default."
			fi
		fi
		# continue loop or (break) from it
	done
	echo "attempting to start x..."
	# REMOVED: echo "exec $NEXTONE" > ~/.xinitrc
	if [[ $? -eq 0 ]]; then
		SESSNAME="/var/tmp/startx-$USERNAME-$RANDOM-session.log" 
		SESSARGS="$*"
		# startx or xinit called from this subfunction
		#  REMOVED: command /usr/bin/startx > $SESSNAME 2>&1 & 
		#  REMOVED: disown %
		do_xinit $NEXTONE
		echo "Session Launched: $NEXTONE"
		echo
	else
		echo "cannot, write to ~/.xinitrc failed."
	fi
  local ERR=$?
	echo "function or session ended with code $ERR"	
	return $ERR
}

function hashdir()
{
	shopt -s nullglob

	if [[ -z $1 ]] || [[ ! -d $1 ]] || [[ -z $1/* ]]; then
		echo "error: need to specify an existing directory that contains FILES"
	else		
		pushd . &> /dev/null
		cd $1 &> /dev/null
		if [[ $? -eq 0 ]]; then
			for i in *; do
				echo "hashing $PWD/$i to command '$i'..."
				hash -p $PWD/$i $i
			done
		else
			echo "error while or after switching to: $1"
		fi		
		popd &> /dev/null		
	fi
}


# loadhashes [workdir] [target]
function loadhashes()
{
	if [[ -z $1 ]] || [[ $1 == "--help" ]]; then
		echo	"loadhashes [workdir] [target]"
		echo  "example: loadhashes /gxbase/bin/extras apt-sudo"
		echo  " would load all hashes for apt-sudo in the same working directory"
		return 0
	fi
	local IFS=$'\n'
	for i in $(cat $1/$2.hash); do
		hash -p "$1/$2" "$i"
	done

}


# warning: does not contain sanity checks!
# hashautocmd [workdir] [target]
# generates a list called "target.hash" in "workdir" of all items that link to "target"
# used to make hashes for gen-sudo and apt-sudo, plus gen-bg
# this is not done every time because it takes up alot of time to do this
# please use this after adding new items to the hashable list because they wont get called
# otherwise, even if gxbase/bin/extras is first in the path (bash by default looks in /bin and /usr/bin first i believe)
function hashautocmd()
{
  pushd .
  cd "$1"  
  {  
  for i in *; do 
    if [[ "$(basename "$(readlink "$i")")" == "$2" ]]; then 
			echo $i; 
    fi; 
  done
  } > "$2.hash"
}

function serv()
{
	unset BADSVC
	case $1 in
	status)
		if [[ -e /etc/init/${2}.conf ]]; then
			sudo status $2
		elif [[ -e /etc/init.d/$2 ]]; then
			sudo service $2 status
		else
			BADSVC=1
		fi
	;;
	start|restart|stop)
		if [[ -e /etc/init/${2}.conf ]]; then
			sudo $1 $2
		elif [[ -e /etc/init.d/$2 ]]; then
			sudo service $2 $1
		else
			BADSVC=1
		fi
	;;
	*)
		echo "Invalid Command"; false
	;;
	esac
	ERRVAL=$?

	if [[ $BADSVC ]]; then
		echo "The service name, $2, seems to be invalid, check again."
	elif [[ $ERRVAL -ne 0 ]]; then
			echo "Service operation was not reported as successful. Recheck and try again."
			echo "(you need root permissions, admin permissions, or sudo rights to run this command."
	else
			echo "Service operation reported: Success"	
	fi	
	return $ERRVAL
}

function serv_complete
{
	pushd . > /dev/null
	cd /etc/init
	ls -C *.conf | sed "s/\.conf//g" | tr -s ' ' | tr '\n' ' '
	cd /etc/init.d
  ls -C * --exclude=skeleton | tr -s ' ' | tr '\n' ' '
	popd > /dev/null
}


# end of file marker

