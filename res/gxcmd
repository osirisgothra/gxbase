#!/bin/bash
#
# gxcmd* (command script)
# 
#   - General system information getter script for gxbase and general use too  
#   - The only script that is runnable from the command line, all other scripts are components
#   - This script is NOT a component and NOT loaded at startup because it is used by most components
#   - See component use below if you want to use gxbase components without loading them all at startup  
#   - The help stub is used by the help command. If you remove it you will remove the help information.
#
#!gxbase-stub=help-begin
#  general system information
#
#  syntax: $0 [command | help ]
#
#  commands: 
#    cputemp				get entries (from sensors command) that reflect temperature readings
#    uniquesessid   write unique session name to stdout (pipe)
#    uniquesessidv	[var]	put unique session name in variable $[var]
#    help						this help text
#
#  different command use:
#    gxcmd exists stand-alone and also as a gxbase component stub. When running gxbase,
#    you will be able to run it directly by typing the 'gx.gxcmd' command. Also, when
#    gxbase is loaded, completion is available and getting help the old-fashioned way is
#    not needed (just hit tab whilest' entering input).
#	 license info distributed with the script in the LICENSE document, see README for details
#  (C)2014 Gabriel Thomas Sharp, All Rights Reserved - LGPL2+ 
#!gxbase-stub=help-end
#   (*=not related to the "gxcmd" command in the 'ggxcmd' project at http://sourceforge.net/ggxcmd)

unset IFS


# 0 source checks 

# 0.1 - guard when sourced -- so we can use exit later safely
case $- in 	*i*) 	$BASH_SOURCE "$@"; return $?;; esac


# uniqsessidv (echos to stdout)
function uniqsessid()
{
	echo -n ${RANDOM: 0:2}$*$RANDOM$(tty) | tr -d " " | tr -d "/" | tr -d "." | sed "s/[aeiouyAEIOUY]//g"
	echo -n $(id -un)_$(id -gn)
}

# uniqsessidv [varname]
function uniqsessidv()
{
	if [[ -z $1 ]]; then
		# try to act as read would when no variable name is given
		set REPLY
	fi
	local PRESERVED_ERR=$?
	eval $1=$(uniqsessid)
	return $PRESERVED_ERR
}

# getrainge [filespec] [regex1-start] [regext-end] [skip-at-begining(0)] [stop-short-of-lines(0)]
function getrange()
{
	FILESPEC="$1"
	REGEX1="$2"
	REGEX2="$3"
	declare -i SKIP_START=0
	declare -i SKIP_END=0
	TMPFILE=$(tempfile --suffix=getrange.gxbasedata)
	
	cat $FILESPEC | grep "$REGEX1" -A$[ `cat gxcmd | grep "$REGEX2" --line-number | grep "[0-9]*" -o` - `cat $FILESPEC | grep $REGEX1 --line-number | grep "[0-9]*" -o` ] > $TMPFILE

#	if [[ $SKIP_START > 0 ]] || [[ $SKIP_END > 0 ]]; then
#		SKIP_END=$[ $(cat "$TMPFILE" | wc --lines) - $SKIP_END ]
#	fi

	return 0;
}

# experimental (you may need to edit your /etc/sensors.conf to get this to work right)
function cputemp()
{
	if [[ $# -gt 1 ]]; then
		echo "too many arguments"
	elif [[ $# -eq 0 ]]; then
		set -- -h
	fi
	case $1 in
		-h)
			ISHORIZ=1;;
		-v)
			unset ISHORIZ;;
		*)
			echo "bad options: $1, must be -h or -v (or none)"
			return 1;;
	esac
	# TODO: need to tweak color for ALARM states but didnt add it, it doesnt work for things like the STDOUT plasmoid
	#       maybe add a flag for colorized temps at alarm state (and maybe need a COLOR STDOUT plasmoid, or cairodock, etc)
	if [[ $ISHORIZ ]]; then
		sensors | grep -P "(temp[0]|Mainboard|CPU [12]|thermistor)" | grep -P "\s\s+[-+][0-9]{1,3}...[CF]" -o | tr -d ' ' | tr '\n' ' '
		unset ISHORIZ
	else
		sensors | grep -P "(temp[0]|Mainboard|CPU [12]|thermistor)" | grep -P "\s\s+[-+][0-9]{1,3}...[CF]" -o | tr -d ' '
	fi
	return $?
}

ARGS=`getopt -l help -o h -n gxcmd -- "$@"`
if [[ $? == 0 ]]; then

	eval set -- "$ARGS"

	while [[ $1 != "--" ]]; do
		case $1 in
			--help|-h)
				# shell magic to print a range of lines based on two regular expressions
       	echo "Help Placeholder"
				exit 0
				;;
			*)
				echo "internal error near argument $1"
				exit 254
				;;
		esac
		shift
	done
	shift

	CMD_VALID=0

	for CMD in help `cat $BASH_SOURCE | grep -Po "(?<=function )[^\(]*"`; do
		if [[ $1 == $CMD ]]; then
			CMD_VALID=1
			shift
			break
		fi
	done

	if [[ $CMD_VALID -eq 1 ]]; then
		if [[ $CMD == help ]]; then
			$BASH_SOURCE --help			
			exit 0
		else
			# function command
			$CMD $@
			exit $?
		fi
	else
		if [[ $1 ]]; then
			echo "Bad command given $1"
		else
			echo "Requires a command name or --help"
		fi
	fi
else
	exit 2
fi

