#!/bin/bash
#
# gxcmd* (command script)
# 
#   - General system information getter script for gxbase and general use too  
#   - The only script that is runnable from the command line, all other scripts are components
#   - This script is NOT a component and NOT loaded at startup because it is used by most components
#   - See component use below if you want to use gxbase components without loading them all at startup  
#   - The help stub is used by the help command. If you remove it you will remove the help information.
#
#!gxbase-stub=help-begin
#  general system information
#
#  syntax: $0 [command | help ]
#
#  commands: 
#    cputemp				get entries (from sensors command) that reflect temperature readings
#    uniquesessid   write unique session name to stdout (pipe)
#    uniquesessidv	[var]	put unique session name in variable $[var]
#    help						this help text
#
#  different command use:
#    gxcmd exists stand-alone and also as a gxbase component stub. When running gxbase,
#    you will be able to run it directly by typing the 'gx.gxcmd' command. Also, when
#    gxbase is loaded, completion is available and getting help the old-fashioned way is
#    not needed (just hit tab whilest' entering input).
#	 license info distributed with the script in the LICENSE document, see README for details
#  (C)2014 Gabriel Thomas Sharp, All Rights Reserved - LGPL2+ 
#!gxbase-stub=help-end
#   (*=not related to the "gxcmd" command in the 'ggxcmd' project at http://sourceforge.net/ggxcmd)


# 0 source checks 

# 0.1 - guard when sourced -- so we can use exit later safely
case $- in 	*i*) 	alias exit="unalias exit;return";; esac

# 0.2 - guard when GXBASE_LOADING is not present
#f [[ ! -d $GXBASE_ROOT ]] || [[ -z $GXBASE_LOADING; then
#echo "warning: g
# TODO: finish this

# 1 primary stuff, must be first because it is used by this file too (and most other components!)

 

# uniqsessidv (echos to stdout)
function uniqsessid()
{
	echo -n ${RANDOM: 0:2}$*$RANDOM$(tty) | tr -d " " | tr -d "/" | tr -d "." | sed "s/[aeiouyAEIOUY]//g"
	echo -n $(id -un)_$(id -gn)
}

# uniqsessidv [varname]
function uniqsessidv()
{
	if [[ -z $1 ]]; then
		# try to act as read would when no variable name is given
		set REPLY
	fi
	local PRESERVED_ERR=$?
	eval $1=$(uniqsessid)
	return $PRESERVED_ERR
}

# experimental (you may need to edit your /etc/sensors.conf to get this to work right)
function cputemp()
{
	unset FLGS NODEC
  ARGS=`getopt -n $FUNCNAME-${LINENO[*]} -o fdhzvi: -l no-decimal,fahrenheit,help,horiz,vert,index: -- "$@"`
	[[ $? -ne 0 ]] &&	return $?
	declare -i IDX=0
	eval set -- "$ARGS"
	while [[ $1 != '--' ]]; do
		case ${1//-/} in
			h|help)
				echo "$BASH_SOURCE -- $0 -hzv -i[= ][index] -fd --horiz --vert --index [index] --fahrenheit --no-decimal"
				return 0
				;;
			z|horiz)
				ISHORIZ=1
				;;
			f|fahrenheit)
				FLGS="-f"
				;;
			v|vert)
				unset ISHORIZ
				;;
			i|index)
				IDX=$2
				((IDX++))
				# one more for $2 as well
				shift 
				;;
			d|nodecimal)
				NODEC=1
				;;
			*)
				echo "internal error: $0 [$1]"
				return 126
				;;
		esac
		shift
	done	
	# TODO: need to tweak color for ALARM states but didnt add it, it doesnt work for things like the STDOUT plasmoid
	#       maybe add a flag for colorized temps at alarm state (and maybe need a COLOR STDOUT plasmoid, or cairodock, etc)
 	for i in `sensors $FLGS | grep -P "(temp[0]|Mainboard|CPU [12]|thermistor)" | grep -P "\s\s+[-+][0-9]{1,3}...[CF]" -o | tr -d ' '`; do 	
		if [[ $NODEC == 1 ]]; then
			ITEMS+=(${i//\.[0123456789]/})
		else
 			ITEMS+=($i)
		fi
	done
	
	# debug: echo -en "\nITEMS: ${ITEMS[*]}   IDX: $IDX  ISHORIZ: ${ISHORIZ-not set}"
	if [[ $IDX -gt 0 ]] && [[ $IDX -le ${#ITEMS[@]} ]]; then
		# convert back to 0-based for actual use
		echo -ne "${ITEMS[IDX-1]}"
	else
		if [[ $IDX -ge ${#ITEMS[@]} ]]; then
			echo "INDEX out of range ($IDX), displaying all values!"
		fi
		ISFIRST=1
		for ((j=${#ITEMS[@]};j>=0;j--)); do
			if [[ -z $ISFIRST ]]; then
				if [[ $ISHORIZ == 1 ]]; then
					echo -ne " "
				else
					echo -ne "\n"
				fi
			else
				unset ISFIRST
			fi
			echo -ne "${ITEMS[$j]}"
		done
	fi
	return $?
}

ARGS=`getopt -l help -o h -n gxcmd -- "$@"`
if [[ $? == 0 ]]; then
	eval set -- "$ARGS"
	while [[ $1 != "--" ]]; do
		case $1 in
			--help|-h)
				echo "help placeholder here"
				exit 0
				;;
			*)
				echo "internal error near argument $1"
				exit 254
				;;
		esac
		shift
	done
	shift

	CMD_VALID=0
	for CMD in help `cat $BASH_SOURCE | grep -Po "(?<=function )[^\(]*"`; do
		if [[ $1 == $CMD ]]; then
			CMD_VALID=1
			shift
			break
		fi
	done

	if [[ $CMD_VALID -eq 1 ]]; then
		if [[ $CMD == help ]]; then
			echo "help not available yet"
			exit 0
		else
			# function command
			$CMD "$@"
			exit $?
		fi
	else
		echo "Bad command given ($1)"
	fi
else
	exit 2
fi

