#!/bin/bash
#
# gxcmd* (command script)
# 
#   - General system information getter script for gxbase and general use too  
#   - The only script that is runnable from the command line, all other scripts are components
#   - This script is NOT a component and NOT loaded at startup because it is used by most components
#   - See component use below if you want to use gxbase components without loading them all at startup  
#   - The help stub is used by the help command. If you remove it you will remove the help information.
#
#!gxbase-stub=help-begin
#  general system information
#
#  syntax: $0 [command | help ]
#
#  commands: 
#    cputemp				get entries (from sensors command) that reflect temperature readings
#    uniquesessid   write unique session name to stdout (pipe)
#    uniquesessidv	[var]	put unique session name in variable $[var]
#    help						this help text
#
#  different command use:
#    gxcmd exists stand-alone and also as a gxbase component stub. When running gxbase,
#    you will be able to run it directly by typing the 'gx.gxcmd' command. Also, when
#    gxbase is loaded, completion is available and getting help the old-fashioned way is
#    not needed (just hit tab whilest' entering input).
#	 license info distributed with the script in the LICENSE document, see README for details
#  (C)2014 Gabriel Thomas Sharp, All Rights Reserved - LGPL2+ 
#!gxbase-stub=help-end
#   (*=not related to the "gxcmd" command in the 'ggxcmd' project at http://sourceforge.net/ggxcmd)


# 0 source checks 

# 0.1 - guard when sourced -- so we can use exit later safely
case $- in 	*i*) 	alias exit="unalias exit;return";; esac

# 0.2 - guard when GXBASE_LOADING is not present
#f [[ ! -d $GXBASE_ROOT ]] || [[ -z $GXBASE_LOADING; then
#echo "warning: g
# TODO: finish this

# 1 primary stuff, must be first because it is used by this file too (and most other components!)






 

# uniqsessidv (echos to stdout)
function uniqsessid()
{
	echo -n ${RANDOM: 0:2}$*$RANDOM$(tty) | tr -d " " | tr -d "/" | tr -d "." | sed "s/[aeiouyAEIOUY]//g"
	echo -n $(id -un)_$(id -gn)
}

# uniqsessidv [varname]
function uniqsessidv()
{
	if [[ -z $1 ]]; then
		# try to act as read would when no variable name is given
		set REPLY
	fi
	local PRESERVED_ERR=$?
	eval $1=$(uniqsessid)
	return $PRESERVED_ERR
}

# experimental (you may need to edit your /etc/sensors.conf to get this to work right)
function cputemp()
{
	if [[ $# -gt 1 ]]; then
		echo "too many arguments"
	elif [[ $# -eq 0 ]]; then
		set -- -h
	fi
	case $1 in
		-h)
			ISHORIZ=1;;
		-v)
			unset ISHORIZ;;
		*)
			echo "bad options: $1, must be -h or -v (or none)"
			return 1;;
	esac
	# TODO: need to tweak color for ALARM states but didnt add it, it doesnt work for things like the STDOUT plasmoid
	#       maybe add a flag for colorized temps at alarm state (and maybe need a COLOR STDOUT plasmoid, or cairodock, etc)
	if [[ $ISHORIZ ]]; then
		sensors | grep -P "(temp[0]|Mainboard|CPU [12]|thermistor)" | grep -P "\s\s+[-+][0-9]{1,3}...[CF]" -o | tr -d ' ' | tr '\n' ' '
		unset ISHORIZ
	else
		sensors | grep -P "(temp[0]|Mainboard|CPU [12]|thermistor)" | grep -P "\s\s+[-+][0-9]{1,3}...[CF]" -o | tr -d ' '
	fi
	return $?
}

CMD_VALID=0
for CMD in help `cat $BASH_SOURCE | grep -Po "(?<=function )[^\(]*"`; do
	if [[ $1 == $CMD ]]; then
		CMD_VALID=1
		shift
		break
	fi
done
if [[ $CMD_VALID -eq 1 ]]; then
	if [[ $CMD == help ]]; then
		
		exit 0
	else
		# function command
		$CMD "$@"
		exit $?
	fi
else
	CMD_STATUS=${1+empty}${1=bad}
	echo "Bad command given ($1)"dd
	

fi



if [[ $1 ]] && [[ $1 != help ]]; then
	CMD=$1
	shift
	case $CMD in 
		cputemp) cputemp "$@";;
	      	*) echo "invalid command: $CMD"; exit 1;;
	esac
else
	echo "available commands: help cputemp"

fi
		

